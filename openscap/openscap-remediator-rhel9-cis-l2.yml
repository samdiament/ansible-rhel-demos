---
# Red Hat Insights has recommended one or more actions for you, a system administrator, to review and if you
# deem appropriate, deploy on your systems running Red Hat software. Based on the analysis, we have automatically
# generated an Ansible Playbook for you. Please review and test the recommended actions and the Playbook as
# they may contain configuration changes, updates, reboots and/or other changes to your systems. Red Hat is not
# responsible for any adverse outcomes related to these recommendations or Playbooks.
#
# openscap-remediator
# https://console.redhat.com/insights/remediations/613f7d24-34a6-4c74-a894-9b8643fd4de9
# Generated by Red Hat Insights on Tue, 12 Aug 2025 18:42:37 GMT
# Created by samueldiament

# Set Account Expiration Following Inactivity
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Account Expiration Following Inactivity
  hosts: all
  become: true
  vars:
    var_account_disable_post_pw_expiration: '45'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      bHRZMUF2VWtWdlJuTjBPVFZVVFZoSGFWSjFORk5vUVRaVGIwZ0tPRXhIU0ZSNWJtVjVkVzlxUW1z
      M2JVdFVUMGxFY0RKU2NGVTFXblJ6VjJJMlJIRjZjbTV0WVV4Rk9VeHVTak5XUTFock1YUXljbU01
      UTJselNUQkRMd3B6UWxwV01rSkVlVGxUVHpJNU9DdFZOekp3Ymt4bk9WbFhZekp3TmpKbVRXaHNh
      SEJLYUd4WVZVZHRORk0wT1drNFZIRk5OU3N3TlhRdlVIVjNOWEZyQ21WaVNuRjZWbVZOTkhkUlNp
      OVJhV3R2TUhaUll6RnFTVzFoYW1jNFlsVjVkalpUUldWdlYxYzNjRkpRYUVGeFYzSjZXRWwyWjB0
      alRDOUtaM0JtY0VnS056SlJWSFY1Y1c4MVp6bDFjMjgzYlVwS01rYzFia3B4ZFhsS1lWQm1WVXR1
      UzJSUVFXb3hia1ZSVDBsaFJHbFphRE15S3l0elYySm5kMDAxVGpJNGJBcHdjR0pUWmxwQ05tcHBR
      bVp0WkhoVE1ESjNPVlIwVGl0TFl6bEdTVVp3YzJsdVNYaFlSMFpOTldaWVRscFBSbWc0TWxCdGFI
      YzFPVlIwUzB0UU5rYzJDbWxGTmk5VFZ6SlNWMmdyU1RGMWJrVk5aekZ3UWpGM1FYRk5lVGh2ZW1w
      dWJqQnROMDFVV2pCemJUWnZSVkpXVkhwUGNWa3liallyUlV0aWVqQjZUazRLTWxwS2RHODVRbEZD
      ZVZGek5TOUlOMFZ5Y2tweFZETkVVbE5FUlZCdloxUkNhWHBGUTBGTU5GVlpWbmh2WjNsUFNHVTBU
      VVZJTlhoeE9XcE5Nbk54UkFvNVNIVlNURU5MZEZCM1pFVnVhV2d6VlZsSFpucG5VVGhLVFdSVkt6
      UXdOVEpNUWxWaFUxVlFXU3MxWVU1aEwwazJRV3RNWTNWUk5USkZXbWhGTVM5NkNtWnFSVlZwZFRa
      bE9WUmFTVkZCVjJWemExcHVVREJwWm1neVVHSkpNbEozVGtzelJYRnNSbUoyUzFnM09VRmxRWE5u
      VUdreFFYTXdPVTlyTTI5VVNuY0tNV0ZOUVZjMGNXWnpSMGxZWmtsRWMzcExlV05HVkZKa1MwcHJZ
      M1ZtVDBocE1rRnpWbWc1YjBKdlpHMXhTbE5sV25selMwWlFTV2R3UTJOSGVtTjNZZ3BvTVVJd1Fu
      b3lZV0ZqY0RWRFpHZHZjbmhuTkFvOVNtc3pTQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83627-0
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-09-411050
    - NIST-800-171-3.5.6
    - NIST-800-53-AC-2(3)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-4(e)
    - PCI-DSS-Req-8.1.4
    - PCI-DSSv4-8.2
    - PCI-DSSv4-8.2.6
    - account_disable_post_pw_expiration
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Account Expiration Following Inactivity
      lineinfile:
        create: true
        dest: /etc/default/useradd
        regexp: ^INACTIVE
        line: INACTIVE={{ var_account_disable_post_pw_expiration }}
      when: '"shadow-utils" in ansible_facts.packages'


# Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File.
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_account_password_pam_faillock_password_auth,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File.
  hosts: all
  become: true
  tags:
    - CCE-86932-1
    - DISA-STIG-RHEL-09-611035
    - NIST-800-53-AC-7 (a)
    - account_password_pam_faillock_password_auth
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      SlJTVkF2VWpCcVFWSkJSSEkyVkdwWVJtZ3dWbmxHVlhaVGNHb0thREJ5UlROTGJVbHBRMEpGVXpK
      SlZUZDJiSGgxYTNkTmRGVldjM0pzYzJaNVJVcFVhelpETHpaV2RuRk1ZbFIxUm1KNFoxVmtXVEJz
      ZGxWSmJUazRMd28xTTFSVmFIUkNhVFJvWVZwWWJWQk1lV05oWWpoaGMzWTJjelZzTnpWMGNXeEJN
      VE13UlhOT05rMDVWMmxDYjBrMWFHRm1PVVJqV25KQ1kwZE5iRlpQQ25wakwxTTFZVzF4WVhwaVNF
      MW9UVWhFWVRsTlFtY3lWM2x2VEZkclpUbGFUa2RCVGxJMU9XcHJjRVJTYld4clYzbHVRVlp1VVVW
      RFlXcG1NbWhrVWxJS1NrWXJOblZDYlRNd04yWnVUSGg1V1hSelpITkhVVms1TUVWRVpWSXdRVVkz
      TUdSVmJGTjFLMEp1WjFsb1MyRnFTRUp4WmtwbVoycFdOVkIwYW1rdlpncEtkWE01VUdwNWFWQXZX
      WGQwVUZNcldGWXhXbGhpYUdKR2MzVjNOalJ4VmxWdVJ6WllSak4zV2sxSk0ybHFZV2x1VGxkamN6
      aG5RM0ZCV2tGMGMyWlVDbkpJTUROUFZHMTNWVEIxVmpSM2NYTTRSVUp3YTJGcWIyaGxNVlptTjNV
      M1ZuUmpVV1oyT1ZoVVkyTTBjRzVUUWpFM1YzTlpiM05HZVN0bFNYZG9ZUzhLU0dSeWJIVm1jRTVZ
      Y1ROWWVUZFpWbGRWVmxaVlZ6aHNjREY1UlRZMGNDOVhUM0pXYkdnM1pVOHhMMVZETUV3eUwyOWpl
      U3NyZUZweGRUWnFVMEZWT1FwVk0xSnBhU3RzUkVGWVIwcDFabUZ4VVhaWlNsY3haakJIVjJnd1pu
      YzJXWGw2YUdadmQwMUhNUzk0ZVVGd2FFZDRRV1pvUW0xS04wOTJjMlJqUldkNUNtY3liSEIyVDJw
      UFVVRktRVk40YmtreGFqVkVORTVCUVZsMldpOVBTMnRyTlU5R2JVRktZa1p0VFdobWMyTmFhVzVL
      ZVV0SU9Tc3dNUzgwY1dKSVdXWUtWMWhDWmpaNlpWZHNkbTh6Y21ST1pHdzFSamRUVW1SeGQzZE9W
      VmRvVUVOMFIwUlRaMDV2V2xwblpGWmlkalJCYnpsSFFVdEVSMFI2WjFsclpVWlVSUXA2S3pCcWJY
      WjBhMjU0VTJkdlpGZElPRzFoUkFvOU5FaHpRd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Check if system relies on authselect tool
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Remediation where authselect tool is present
      block:

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Ensure "with-faillock" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature with-faillock
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-faillock")

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when: result_authselect_present.stat.exists

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Remediation where authselect tool is not present
      block:

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Check if pam_faillock.so is already enabled
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail)
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_is_enabled

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Enable pam_faillock.so preauth editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so preauth
            insertbefore: ^auth.*sufficient.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Enable pam_faillock.so authfail editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so authfail
            insertbefore: ^auth.*required.*pam_deny\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File. - Enable pam_faillock.so account section editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: account     required      pam_faillock.so
            insertbefore: ^account.*required.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0
      when: not result_authselect_present.stat.exists


# Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File.
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_account_password_pam_faillock_system_auth,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File.
  hosts: all
  become: true
  tags:
    - CCE-86917-2
    - DISA-STIG-RHEL-09-611030
    - NIST-800-53-AC-7 (a)
    - account_password_pam_faillock_system_auth
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      ZDJhMUF2YVdSVUwwMDBWbmRJY0VJemQzZFplbGd5UmpCSFIwb0tWRGxCUkZoVWVqRndXa2c0T0c5
      bmVuaFFSSFJTVVV4V2NucEdVQzh2TkUxb2JYQkRibWxMVTNKdlp6YzBibVZ0UjIwdk9VSklUMDVX
      YldWdU9IVmlRZ296TUM5TlRpOVdRMmhHWkVoUE0wZFBlRVF2VFU5ek9FVndWMncyUzFreVYwdFZR
      VmxSZUZwQlp6Qm5WV3BoVG5walRtUlpkbXRMWVdSdlRWSXJUMWR3Q2sxbWNHRmFWVE5YWmtSYVRY
      bDBjMEoxUTNwaGVYVlZhbmRVVDBoVE1XMWpZV280WkVsRk5XeEtjVzl5ZG5GeVpqaENaeTlaVVVs
      T055OW9PRWhCVkM4S1IzVTVNa055Tms5ak1XbGpVSEkwUVN0d1RtSTJkMWxKTm5Cb1NXbHVka3RW
      VjNVMGRHRlhUMDlhWTBNdmRtbFRUamRaTmprdk0wUnNORTFOUm5Gbk1Bb3JTblJVY21FNVZXdE9i
      MU4xVVVscVRtcHdVSGxOVVRRclVYZFhXV3hKYWtGSFVFWm5UbEZwT1RoNFkyMUxhVzk2YzFoaFJt
      SjBMME5KTWk5VVNYbFBDbFJsY2toaVJIQjBkamcxT1ZJelQzTmtRbkJwVmxsWlVrRktUR0ZTU1ZK
      VllrTlVTbU5zVVVKWE1tUnRPVTB5UzBGdlF5dHpZM2t6SzBvNEsyeHhSakVLZWtjMVp6RjBSU3M0
      T1V4dGJsbEtjVFJNYTI1cVFXZDNVVE4zU25nMkswSm5RVEZhSzJsckwwdHVlalZOUzFOdldHRkZN
      azVaWkdOUFRsQTRVVlY1Y3dwWlRETkJPV0V4TlZWTlEwZ3JSVUpsZWxKTlJYTmlUVGwxSzBobWRX
      UkNPRkEwUm5oVWRHdDJiWEpVYTFaWVZVNUNSRTVxYTBjelJXdzROazh2WWpkbkNsWm9VRGhyUlVv
      M1pXdEdhSFZpVmpkS2QxQTJURmMxTW1aSVdHRjJTbFpGYTBnck1FOWpZUzlNT1dVeWJERnhNRTAx
      UjFsNFdXbDNkVU51YnpNNFozY0thRXhVUkRFeU1VaHhRWGxsY2poeU5qUklNMlpyYm1kNlFqQmxV
      bHB6T0Rkb01qWklOVUpZYjFwbllVbG9TM1V3UzBaRlRXOVBOSGhOTVZaRmRtcFVTQXA0VUhwU2Qy
      NXllR3h3VTFBM2MzZENSMDVKZWdvOVVGWm1id290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Check if system relies on authselect tool
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Remediation where authselect tool is present
      block:

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Ensure "with-faillock" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature with-faillock
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-faillock")

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when: result_authselect_present.stat.exists

    - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Remediation where authselect tool is not present
      block:

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Check if pam_faillock.so is already enabled
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail)
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_is_enabled

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Enable pam_faillock.so preauth editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so preauth
            insertbefore: ^auth.*sufficient.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Enable pam_faillock.so authfail editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so authfail
            insertbefore: ^auth.*required.*pam_deny\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File. - Enable pam_faillock.so account section editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: account     required      pam_faillock.so
            insertbefore: ^account.*required.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0
      when: not result_authselect_present.stat.exists


# Set Password Maximum Age
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_debian,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Password Maximum Age
  hosts: all
  become: true
  vars:
    var_accounts_maximum_age_login_defs: '365'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      WnNkMUF2TWtnMGVuUllPRTltYTBWaVR6QXlWV2c1YkZCNGRHUUtNelp0ZUZCTFRXZHRWMDF5VG5O
      WFluZGtPQzlMY3pKaFRDOWlkMk5PVm5ocmRTdDNiRkkxVUVsaU9FdHJMMHBDUzJsMVUxQlBhemhN
      V0hWUFExSkJOUXBxYjNNMWRXUmtRekpvTkRsbVpHMVJNRGhNTW10VGMxUjBXR05EV1VKcGNVaFhS
      Q3ROZW5wNloyeEdUMUZpVkhOWGFEVndSVmhaVWtOR05YZFBUMlJuQ25KdGRYUndTM05RYm5wSFZr
      bzFSMDVLVTFOcFJVMVNhR3hWTlhwdU1VeERXVXh2ZVVKaE5UQnVSRVJrV1hOaEwyZGlMMjgyTVVv
      eVNFTkdkVXRaY2tvS2NqazNjMkZ0WjBkdlNWWnpWbEYwUjNoSVZGWXJhMFpuT1VsdU5rVnZTMnB1
      TDBKWmFtNVVkbEJTVG5kMFpVeG5aSFJTUW1sS1VsWlhjRzlXVlVrdk1BcEZNa0k0WXpaU1ZTdDNk
      WGh0TURreFJHRjRiMGRsY3pscVZGcENaVTkyVURaMmRYbEhVM0kzVm5Cb2FXRnNiRFZTWlhGUWRH
      bHllaXRGVVhSUWRXY3hDazEwY0VsdE1YUkZWWGxGUjI5eVZsRmhlV2xZVFZWRmF6WXhTRVZyWTJk
      Mk5sSmFOQ3MwTm1VclVGaGhhbkJoU0dWSFYyUlVTblZWYlRKTU5tbGpXVWtLUWpJdmJUUXhkV1Z1
      WmxnNGRGaFdlbGRDY1dSQmJuQkVURTVGZGxod1puRnJWMUV6VDJOUWNYbG9hRVZyZFU1dE5tOURk
      SFJhZVRkcWFISlNhbmRwTWdwMFlYZENjbkI1Um1vMFFtNHdialpIZURJclIzRjZZMll3Y2tsWWRq
      aE1WR3RCT1ZOTU5EQXJZamw0U2t0Q2EwcFlVVkJRWkdOTlV5c3lja2x5Ym5WNUNrbFlLMmRSWjFS
      WVIzQmtWVGc0VDBsQlduUnhTVEIxWTBWbFducFVkM0ZKUWtsMVQySlFaRUZ5U25sWlZtOVFkbkI1
      UVhRMlRHSXdiVzVGTUdaVGVXc0tjeTlIU0RGcVZEWkpkblpIY1ROcGFWUmhSMmN6VDJoalJHcEpa
      azl3WkZWUWRrMW9WWE5NYVZoQ2VVeHBObEprV0ZSWFltOW9aRU5aVW1oU1pIWkdOQXAyZG1WS01U
      SXhNemhUVFdzemVUUktTWGN2VHdvOVFub3hPQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83606-4
    - CJIS-5.6.2.1
    - DISA-STIG-RHEL-09-411010
    - NIST-800-171-3.5.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(d)
    - NIST-800-53-IA-5(f)
    - PCI-DSS-Req-8.2.4
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.9
    - accounts_maximum_age_login_defs
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Password Maximum Age
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^#?PASS_MAX_DAYS
        line: PASS_MAX_DAYS {{ var_accounts_maximum_age_login_defs }}
      when: '"shadow-utils" in ansible_facts.packages'


# Set Password Minimum Age
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Password Minimum Age
  hosts: all
  become: true
  vars:
    var_accounts_minimum_age_login_defs: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      TkxTVkF2YWtSck5uaFVPRmhhYUhwd2NUUmpkMVZZTURNMmNESUtUbWhqT1VwVFFUQnRVbkZ5WTFw
      M1lsTTFNWEpFZUd4TFVYWnZOa3RLS3pOdmExVlZZMngwYWtob2VXeDNjR2xhTTBFNVlVeHVRM2xU
      YzBOQlFpdExhZ3B0ZGxjMFVGTmlSRzkyYjFaaVprdENRMUpWUlZOVWNXOXFTMEZRV1RCdE5WUTRi
      RUZSVVhodmFESjJhSFZOVEU5RlUxcGFUMnRqY1RKd1lucG1ORmc0Q21ONFJqSklkRUlyUjNoQ04y
      OUxPQ3RHVFc5T1pVWkhNVFYyY21aNWVFSlhZbTFYZVdWaWJ6Tk5kWGxpVkhOSGVsRm1hM1pwTUc5
      RmRGVlJWbXhEZUd3S01uRkRRa3BMT0Zjd1JIUXJkbWhpTlVKb1FsZFVXbUpoWW1saWNXRXdXRzVD
      VjNFeU0xTXpSVEo1UTJScWJ6Sm5hbVk0ZEZWRWNXWlFaRm96VW5sME53cEdhM0pEZFZoRmVGTmFj
      bXhZZUdaQk5VUlhNMEpuVG5Ob1YyVXdRa0ZQVlVOM05IVmpaek54TWtkcVFVeGFNMjFvZHl0NGJu
      Tk9NVXg0V25Cd1pWVm5Dblp0ZVhBclprbGhOV2d6VlVwNWFXSTVTRGRCYjJKT2FYUlhTRGxFZVZV
      clpIcG9XazVtU1hFME56QkdTRkI1VW5sdGJXSlZObGN6YkZoaWJVSmlialVLUm5sdlMxTTJlV2xs
      UVhOWGFVbDVjVGc0ZDNORGFucDZRMkY0ZVZnNFFrdERVSFZOYUZCRE0wSlZMMlZ2WmxCT2RtMVph
      WEpETVRoWkwyc3JkalY2S3dwWFpuVnphMFo0VUVoWU1XVjJkSGhsY25SbFZrSktVMW96VDNkVVFq
      Rk9hVVJXYWxORmEydDJWMUJFVlhWc1RqZFNjaTlVUkdreUwyMVpXREJvWjBGbUNsRnNOMXB2V0dZ
      MlZVRmlkR0Z4WVZRd1JteG5WbTh2YTNkSU5sWmtjM2hTUW1jM1lWTjFSelEyVGpCUGRWWnZUazVz
      ZUZWamJWVnNVVkIwUW1wUU5Vb0tNV2RKVDNBeGRsVTNiRXhvUjJOemNWQk1NMlkwZW1Od2VIWkhU
      a0p0Y0RoalFXOTRjVFZ1TUN0TWRHbFdWMHRLYkRCWGFGVXdlRmN3UTNCdVlqbEpNd3BJZFZKWUsy
      bFVkakpETlhGUlZIaDBXR2RJWmdvOVdXZ3ZlZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83610-6
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-09-611075
    - NIST-800-171-3.5.8
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(d)
    - NIST-800-53-IA-5(f)
    - accounts_minimum_age_login_defs
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Password Minimum Age
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^#?PASS_MIN_DAYS
        line: PASS_MIN_DAYS {{ var_accounts_minimum_age_login_defs }}
      when: '"shadow-utils" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words
  hosts: all
  become: true
  vars:
    var_password_pam_dictcheck: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      aE1kMUZCU2xoU1J6Z3ZVMU5JWkV0WFZEZFdiRGwyYjJwak0xWUtja2hLZVZCeVRVTlNjM1JaYVdW
      NVJWWlJNMlZyU2xaSVZTdEdUM2xhZHpCRllXVjBaM05KT1V0YVptVlRZM0ZVUVhZNVNEQkdNaXRJ
      VmxkMFkwOVJVUW94V21Wc1NUQm9VMHMwUm5acVdYSlRMMnhTTDBkSE5VZG1UMGxGWVZwblEzQlZZ
      M2xPV1ZGeWNtcFdOUzlGY205Qk56VjBObGxWYjBnclRrRk1SVzVEQ2s1SllWbE9TSGx4TlhNd1lW
      cExibkJ2WW5Od1NtWnFOVTRyUVhsUVlYVnFibmxzT1hBeGJrRjZiME5tY2pSYVpqVlRaR1ZDWjFK
      cVV6aFZibWRpUkd3S2JUTXdjMVZKWWpReFZqbFFRbTEzU1hreVNURlZLMHhWV0hONWFtOXZVelZD
      TlU1NWEwaHBXR0pIUm5CdFNUZ3dURzV0V0ZoelJ6Tlpaek5oYXpCd01BcGlORWRTTm1ZMmNYUlNN
      a2RYVUc1SmJtMDBPV0ZKYnpCS1NVSXdLelpIV0ZreVFVaHViRVF3ZVd4VlNtZHNPVTAwY1ZWQlNI
      bGtlR3R5Wm0xWFpWQXJDa1ZpZFhreU1EbHdMek5rYlZkT1V6UjJSRGRHTVZoS1dtRTRUM2RRT1N0
      R2Jrc3ljMWh2VGxCS2NqWkpSbVZETTBZNFRFbHdUMlJCYjBWS05tMXhWVGtLTUhselYyTkZLM0JF
      YTFOcmN6SkZOek4xVERCMEx6STRXRU14VVVKNFFXZDFiME5hYlhKRFlYTndTa1pPZWxod1VEVTNS
      V1l4ZHpsT2FVOU9Oa294ZUFvNFMzTlFNbEJETTBSSk5FdHRiRXhrVGsxdFZITnlUakJDVFRac2VI
      aFpPVkp5YWxwcGFHUnVVWGgwVlhWTlZIRjRNelJFTWtoak5VSlRZbWxIYm00MkNsSnplbWhRYkRa
      SFprYzJWRFZvZUhaQlNHMWxaamhIYjBWT2JHeDBNSE4xTHpaUU1XWnVZbVpqTkhaRFYyWjBSV0ZY
      Y20xeVlraHhNbmx6UXpsWmNIb0tTM1ZQUW10aU1XUm1jV3B2V1dkVWJHZEZRazg1Y1hORlVqWXdT
      bUUzVW1oaGRHRTJkMEoxVVVaU1pXUnFOR2xGWmxNMllXbDJlRzR2YzFkbmQyeFZNZ3BMWW5NNU5F
      ZEdWSEJ1WXpkclJHbFZXRGhVV2dvOWEwcHlVZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-88413-0
    - DISA-STIG-RHEL-09-611105
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - accounts_password_pam_dictcheck
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words - Find pwquality.conf.d files
      ansible.builtin.find:
        paths: /etc/security/pwquality.conf.d/
        patterns: '*.conf'
      register: pwquality_conf_d_files
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words - Ensure dictcheck is not set in pwquality.conf.d
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^\s*\bdictcheck\b.*
        state: absent
      with_items: '{{ pwquality_conf_d_files.files }}'
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words - Ensure PAM variable dictcheck is set accordingly
      ansible.builtin.lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*dictcheck
        line: dictcheck = {{ var_password_pam_dictcheck }}
      when: '"libpwquality" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Different Characters
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_difok,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Different Characters
  hosts: all
  become: true
  vars:
    var_password_pam_difok: '2'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      TkJPRkZCU2pJck9TOUlhakZEUW5WSVMwdHVUR05QWW0xQmRITUtZalkyWmtNck1tbFBjRVJ6VEd0
      SWFHeHJNRFJYVWpsc2QxRkViSFY2TUZsV2VuQTBaMmRET0dkdFJsQkhLMEZpUzNkU1EweDRhaXN4
      Vms0d2VuWlNRZ3BwV25KS016QlFjbTAzYmxKdFVGTjFUVkZ6UTJ0RVVETk5NbkZLYWpSS1JUTkJa
      MGxLVUdwSWNtVnJSMW8zVHpsa1NuZERORlpDYnpSM1QxaGxiRkpCQ2tSUFFqTnBURlk0ZFdkemRH
      TnZXVlY0Vm01VFowTlJUMFZwTUdodFRtcFBhRmhSYUVvNVlUbGpRbU5MVEUwd2JHOXJVMFl3YVVV
      clpXRkRkMGh0WVdFS1RrVkhUWEEzUVhoVk1uQjRlbUpyYmxndlZFOVVVVTVGV1drek0zUXZkWFow
      TjJoYVJYQTNWU3QwWlM5VFFrRmpka2R1Y1RGTFFqRnBNMnRIVm5KYWFRcEdZMjFrVFV3MFowaFJi
      bTFEV0dGa1IxZE5abE5yY1dGQmFGbFZabXQxT0dzNVpUTjRVbTB3UmtkSVNHNXVOSFpaZVZSWWFV
      SnZLekZ1YUVGSVRVZGhDbVkyWWtGSFprTk1TelkzVVZGT09HZEZiSEY0ZUVOM0syWlBiQzkzYzJw
      bFpsbE9lVEZ2VTFaMlQzaDJZazF5WVdNMVMycEViVzh3YzI1WFYzZHJWRE1LWlRCNFZGZFRUbFZF
      ZUZFclJWVXZia3BKUzJaSFVtUXhZbUZwUXpaMmRqWlpXbTQzU1U5Qk9WVTRaVVIzVUdoTVFVTkVW
      SGxIY3pWVlVYaE1ka0U1Y2dwUWVHbDVabnBvU2tsMVRrSjBObTl0VkdWYVdqa3JjV3c1YWpNemJG
      QTVPRWRTVjA5blZHODBiQzh4UWtFeGVsQlBlRmh1V0c4ek0wWmxZVzVFVnpBMkNqbFdNRzFLU1cw
      MmIyeGxWVVZhVFcxQlZUZDJNSFk0ZVhnNVZIbEJOamxZV2tsb2FIcERXbk5yWkZSNVZFMXBhR2hY
      WW5GUGREUnFObVF5UWxBM2JXa0tZaTgzVmt0WU9EQk5kSFZYVTBOSGJtbGtUalEyU1RGS2N6aHJh
      ekJTZWxSSFZrMXhLemgwT1VWME9Xd3ZRMU5tVFZkQlYwc3djazl6V0dsUVFVSktOd3BXUmtwR1VV
      UkVWMGxCVFhsVFZURlJPVmM1VHdvOVIwZFBOQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83564-5
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-09-611115
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(b)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - accounts_password_pam_difok
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Characters - Find pwquality.conf.d files
      ansible.builtin.find:
        paths: /etc/security/pwquality.conf.d/
        patterns: '*.conf'
      register: pwquality_conf_d_files
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Characters - Ensure difok is not set in pwquality.conf.d
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^\s*\bdifok\b.*
        state: absent
      with_items: '{{ pwquality_conf_d_files.files }}'
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Characters - Ensure PAM variable difok is set accordingly
      ansible.builtin.lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*difok
        line: difok = {{ var_password_pam_difok }}
      when: '"libpwquality" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Enforce for root User
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_enforce_root,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Enforce for root User
  hosts: all
  become: true
  tags:
    - CCE-86356-3
    - DISA-STIG-RHEL-09-611060
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - accounts_password_pam_enforce_root
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      VXdkMUF2TUd0d1J6Uk5iRnBGWmxCMGMwWlZOa0p5Y2twalZFTUtaamRuY3pGTGNFWktXbEJuV1Ux
      WFprNXBRbFZNVkVWT2RpOUNUVUVyUjA4M1RFZGhSbGswV1hReUt6TTJOVmQxYkdvNFUySm5kbEkz
      VGxwMlkwYzFiUXA1TkdSek1YWTVVeXRPU3pFM1VXSjRWMk5UT0U1MWFYZEVhMVZrT0VoR1dqUlha
      bmR0TVdFMWVIaDVjR1l3TlRkNFp6VjNjemhpTjAxSE9GZHpMMkUzQ2l0UFZXNXJabnBCVG5KT2FF
      VmtVRE51TTI4MVVWcHZkakJvYWxZd1pUZFBNWGhpTUhGMWFWSk1NalpTZFhGcGNraHJUR2hKWjFr
      MU9EQjZNazAxYkZVS2JFTldVblpyUzBFeFVWcDVaak16Tld4aFMwdHJiMU1yTUd0eFkzRnhhREp4
      UW1KMWRUZDFWSGsxTUZsdFdrOUhlRU55WVdkcVNscDJSRTB6ZVdzNGRRcEVLM0Z6Y1dkaGRHVndk
      RmxaZEhObGEzSnVTMWsyT0RoVFZraHBWM04wVUhGeVRWQkdSSFl3UmtwTE4yRjVSbG80YWpoemFY
      TkxiRXN5UWpaamRqaDBDbnBMTUU1c1puSjNlVEJ0VGxsME5HMUJlVUpqVWt4V1ZGbFRSbEpKWlRW
      RFMwVTNRV3BsV1hwVmRtUnJSRTlSUW5NelFrY3pURGxSV25VNVVtRkxlbFlLUVVweFJXRnBRM1pu
      TUZOa1oxUnNlSE53ZFZkckwycEVVRkJ5VmxaWVJGbHhTbmhyUWxwelRuRlVOMGcxUjNOQ2JtVjZR
      akpWUzNCT09VWmlhbkJNU3dwbk4zWjRaRWhFT1V4eWNIa3hNelZHWlhCcWVrTnhSR1JDYlN0R1Yx
      UTRjREpGTlhSNFVqZFNZV3hWYjJOSFFYVk9la3N5SzI5YVpIaG9NVkp3WkdWQkNrWTVNR016Y1VK
      WVdEUkNhbFZFWTNsNlpsZEZlSGw2Tlhaa2QzbzFRV0ZEYzFoblRXZEJSVkZXTHpRM2RUTnFlR1Uz
      WTJoTmJITmthVTVQVDFCbk9GQUtUUzlJVG01cVJWaFBSM1JQWlhaeVNDOHJSamhDYkVaWlFuSnJO
      bTlxWVdKdGVYTnBkV0Y1T1UxM01rdEJkbEUyUTFabGVIcE9LMDFuUTFKUFUwTkRWd3BuYW1sSlUy
      b3JZVElyWkRVeldDOWtOM1ZSZHdvOWFWZEdlQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM Enforces Password Requirements - Enforce for root User
      lineinfile:
        path: /etc/security/pwquality.conf
        create: true
        regexp: ''
        line: enforce_for_root
        state: present
      when: '"libpwquality" in ansible_facts.packages'


# Set Password Maximum Consecutive Repeating Characters
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_maxrepeat,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Password Maximum Consecutive Repeating Characters
  hosts: all
  become: true
  vars:
    var_password_pam_maxrepeat: '3'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      ZFhiMUF2TTAwMVZ5dFhOWFZqZW1aVVJubHVSRVJaU1doRGIyb0tTVXhXYjJvdlEyZHhkMlZ1Y0dn
      MmFrMVNWSGhvTWpadlRXcFZTRlpoUlRsblpqVmxTVVk0TmpkS2NXNUplV3AwUXpoeVFucFVhV3RT
      Y2tORWFFOWFZZ3BhWTFadlIySklWakZLZWpBd1pVeDBhRU5RZG14MlRtUlJOSFpCVG00d1dVeFRU
      a2RrUTBkQ1ZGWXlXRVk1WlZCdE0waGtOV2RMT0c0M09XcHhVUzluQ2xOWWRISXpORWxvVldGeWFG
      ZFdhbVZ6Wmt0bVl6bEJjbEJsVVZKSFpXbHdOVEZMU21SSFIwUkJWMHh2VG05c1ZVNXZXbVF6VFVj
      eVprMTRUazVEVG5nS2FWTm1NMWcwYkUxckt5OVJWSEV5VW5aQlZuWjRha0ZCYWxKTVVrYzBaVWhz
      Y1VaRFR6WXhSalpwV25wNVpUaG9RbTh5TXpKb1YxUnZSMWN4ZGxrNFF3cEtibWx4YkZoTE5qVXJT
      WEJ5TlZWaU1YWnVkQzluWVhKQ00xUjNSbk42Tmt0aFdVRXZRMjFoWWtzM09XVnFOVXRyY2tKMVIz
      SjZlR0ZNZHpoeVQybENDbmRKYjJsTVYwRjRMemRyVlZGUVVGWkVlRTFzVUc5a1JXcG5jbUpTV25o
      cU0wRkJlVzU0YjA1bU1YTklOVElyZEVGU1VUWlhUbmRaVVc4M1RYSTNaMVFLVW5wVmVHZHZXa2xT
      WjFJMlFuUm1kR3h1U3pOUVMzazJhbXROWjFaa2VEQlRNMFpvU20xRlluUTVSRFE1VmtKSGFVOUJh
      VXhMY1hFNGNUSTViak4zVEFwMUswUm9Mek5IWkU0MWJUSnlTMGRrUlZwcE0xWTVXRXhNYkZaWVMx
      ZHBhMlUxYkV3MWExSXJkbGxVWjB4SlR6WXhkbUp0UzJGVGNEQllObTFzZVd0SUNtODJVa3RFWldN
      MlQwWXJjSG80VlVoVlFWWjNNbUpHYzB0VWRscEllblZOSzFGWGEyMXhXbE0xUm1KYVoyUjJRVFpN
      VWtkMFVVNVFiMDh4ZDFGS0wyOEtSbTlEUXk5M0wzVXhObUZJV1hkcWJqRkpaa0ZaWkVkMEsweHhN
      MUZhTW1KNlVHZHdiMFI0ZDJwbWMyOTZRVlJoTkVzdmVHMXNLMlJyUW5GWk1GTmlUUXBEWVRKTU1H
      RkxPSHBvVDNSc1VFeDNWV1UxTmdvOVV6aFFOUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83567-8
    - DISA-STIG-RHEL-09-611125
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - accounts_password_pam_maxrepeat
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Password Maximum Consecutive Repeating Characters - Find pwquality.conf.d files
      ansible.builtin.find:
        paths: /etc/security/pwquality.conf.d/
        patterns: '*.conf'
      register: pwquality_conf_d_files
      when: '"libpwquality" in ansible_facts.packages'

    - name: Set Password Maximum Consecutive Repeating Characters - Ensure maxrepeat is not set in pwquality.conf.d
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^\s*\bmaxrepeat\b.*
        state: absent
      with_items: '{{ pwquality_conf_d_files.files }}'
      when: '"libpwquality" in ansible_facts.packages'

    - name: Set Password Maximum Consecutive Repeating Characters - Ensure PAM variable maxrepeat is set accordingly
      ansible.builtin.lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*maxrepeat
        line: maxrepeat = {{ var_password_pam_maxrepeat }}
      when: '"libpwquality" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Different Categories
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_minclass,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Different Categories
  hosts: all
  become: true
  vars:
    var_password_pam_minclass: '4'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      NDNaMUF2TWl0S2RHRjZOR3hMVDFKV09VZHNka1JCTkV0T1FqUUtZM2g2Y0RBM1ZUUlphR2swY1dO
      dFUwTmlUalpOVWpKNlZtcGFWV1pHTlhkamFqbG1lamxVVm10SFkyOUpSV3htZVhocGN6WXZWbmRV
      VnpCcU4yMTZZUXBIYTA0eVVubDRhVTR3V0hCMmFUTnBTVTgyVldKRk9YZHVRbTFKTld3eVlqQkNh
      RkJJYkRsVU5VaHJiRVpNVUhOTU5EbHpOM2xJVlZkWWFpOXFhVkIzQ2xseVIxVjVTVGR4YmtZeFpH
      aFJSbmRyTldORU1saG5kVzVSYVVaaE5GSklOMmRwVldVelRWaGlkbE5RVVVSc09VdzFXRzhyU0hW
      MWRFODNMMHh2YUhRS2JHdEtjRVZWTDNOUldqRXhZMHhDTXpocmFVOTZURkIxTjBWRlNEQmhTa1JD
      WjNWc2FYcFpaREI1WnpCdmFWSmxUbTgwUzNCbk5pODFXRzlqZUhsbVZ3cFVSRXRQVlV4b2RsRlhU
      MUJzYUhKV01pOUJVMnhDY1cxeWRHdEtlVVUwV2tZMUx6bFRabFpYT1Raa04wdDZRMkpKUVVaMVlX
      OTRUWHAzU25GaUsyTTJDbFV5WVZkQ2JVOWtXV1ZpZG1ONk1IWkNRMjE2WTB0UlExcHFPRll3Tnpn
      M1ZURnlNWGQzYVVnM1Z5dFpWVWRxZDNWTWRVNHJjM1ZGVmtSbVZHVnJUMkVLUlRSSFFVMWFiV2Mw
      TTNaemFIRkZVRW94YVM5U1FWWm5hVWhRUlNzcksycElZVVl2VUd0aU5sYzNOMkUzU0VGSU9EQkNi
      RnBNVFhCR056Qm1abmxrV2dwMlJVczJTV2swU0hGS1VtcExVME5TUzNRemIycFZNVEZZVlRWWVIy
      TlBTa2N4WlZsRFptZDBOV3hTSzFCelFrRmxXVzl6YzI1WGMxQlhkRkJQVUhaVENqaGFaVXRsZEho
      Sk5IWlZjSFZhWTFJdk9WTlJjbWd5U1VSS1owbE5SM1U0Y1U5aVptTXlNMlpSWmpocE1FOTRXVWRQ
      UjA1bFUwdzBRbFpXWkVGaFZESUtlRlJ1U1c5bFRtVnBRamhJZWtadGRUY3lPRzFRVDBNMFQyWkZZ
      WFJXVjI5MVZteHNPRUpqWm1WRVNHTlZTVk5qUWs5WFMzaHFlV2wxVXpCS1NYZGxaQXAxVGpVNVR6
      a3ZPVGh0YW13eWVGSm5WMkZTY0FvOWJsVklUQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83563-7
    - DISA-STIG-RHEL-09-611130
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - accounts_password_pam_minclass
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Categories - Find pwquality.conf.d files
      ansible.builtin.find:
        paths: /etc/security/pwquality.conf.d/
        patterns: '*.conf'
      register: pwquality_conf_d_files
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Categories - Ensure minclass is not set in pwquality.conf.d
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^\s*\bminclass\b.*
        state: absent
      with_items: '{{ pwquality_conf_d_files.files }}'
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Different Categories - Ensure PAM variable minclass is set accordingly
      ansible.builtin.lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*minclass
        line: minclass = {{ var_password_pam_minclass }}
      when: '"libpwquality" in ansible_facts.packages'


# Set Password Minimum Length
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Length
  hosts: all
  become: true
  vars:
    var_password_pam_minlen: '14'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      bExXVkFyWjBsa05GUjNTWEUwVDFCWlJrNDFUREU0WWtabldXTUtkek13SzBRNFYyRlpiVnBKTWpW
      WUwwUm5iblIyTm5VeVV6WnZibVp1VVc4MlZVNHpkaXR1TUVSSlpXWnVOWFoyU25OdlNpdG5kMDV1
      WlVnMVFsWkROZ294VEROWlRpODRVRTF1VVVGb2VrbDBTRXBrT0VOUE9HSlZhWFpsTjNRMVZEaDRT
      MGhFUW1KNGJVWkVSR1kzVDIxNGRtZ3ZTMnBqVFRSYVEyd3hRVTF0Q21kYVUxaGpValJzYWs5TVVr
      NXJZbWxUWjFab1N6QjFiVUZYUVc0MlFqTXllbTV6ZUVzNWJqaDVla3A2VURkcFFVaHRVVUZqUWtZ
      dmRXZHZkR3gwYlRrS1puRkNTVEJRVGtNd1ptdE1TMWhWWjFWWFVteHpibGhDYUdkTk1IZHJOak5D
      TkRaamJHSkJUVGRxTjFwTGJFUlZPVlo2UkRKV1owNXZVekoyUkcxc2FncGpiVXczWkZCQlZUTmpN
      RkF2VmxsdGNpdG1OR2Q2YzFsTWRFY3ZkRmczY21JMVpGTnNjVVZPYjFGVmVHWlNSMmhPZDNKS1ZX
      ZFVZbTgyT1dGVk1DdE9DaTlTY2pCWWFHRmFSM2d6UVcxUWMyVkhSMjFUYlVKSVNGTk1ZelZFVW5W
      VVpYRmxNVVJTU1VkNGRVUXZLMDlvZVdweVZFWXZSbVJFWVRjM1dFZFZUVmNLVTNwaFVWazBkbmxz
      UjB3NVIzSkROakk0ZDBwWmVtRnlUazByUkZaYVkzWllZVXh1YTJWTlpXcFFhVmx6SzBVeVpWTXpR
      V1k1WkRaM2JEaDBaRmhhUlFwUmVGRnRVMkZJV1UxWU5WcHNjR3RaTW5KTFEzUnpjRFUyT1RVd1Vq
      ZHFPVXB2UldFMlJTdEJNV3cwU1hWcVJqSkljbE5YZWtvMmEzaFpPSGsxVFVsbENtOVBTVmxRVjFC
      cWN5dE1kalpEYW5nNVFXWnJlVnBCVEVSMFNHdGtPVXRwVERVMlEwYzVja2hVVjNCNVRGZzNlamhu
      YmtaRk16aE9TWGR5WTBOaGJWb0tNRWRIVlZsb1pVSkpjRTFZTjA5R01HdG1OaXNyTDJWSFkydHlh
      M2xYZGpONWRGRnRhVkZxY1V0b2VqTXZhRTVOV1RsV2NrZ3ZkakJCZFRsaU1USkxRd3BxTUc1MFYw
      RlFPRTE2TDJZdlZUWjFiMUJRUWdvOWRtaHdkUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83579-3
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-09-611090
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.6
    - accounts_password_pam_minlen
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM Enforces Password Requirements - Minimum Length - Find pwquality.conf.d files
      ansible.builtin.find:
        paths: /etc/security/pwquality.conf.d/
        patterns: '*.conf'
      register: pwquality_conf_d_files
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Length - Ensure minlen is not set in pwquality.conf.d
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^\s*\bminlen\b.*
        state: absent
      with_items: '{{ pwquality_conf_d_files.files }}'
      when: '"libpwquality" in ansible_facts.packages'

    - name: Ensure PAM Enforces Password Requirements - Minimum Length - Ensure PAM variable minlen is set accordingly
      ansible.builtin.lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*minlen
        line: minlen = {{ var_password_pam_minlen }}
      when: '"libpwquality" in ansible_facts.packages'


# Limit Password Reuse: password-auth
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_pwhistory_remember_password_auth,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_almalinux
# reboot = false
# strategy = configure
# complexity = low
# disruption = medium
- name: 'Limit Password Reuse: password-auth'
  hosts: all
  become: true
  vars:
    var_password_pam_remember: '24'
    var_password_pam_remember_control_flag: requisite,required
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      bHRXVkF2YWt3emVubzBVbk55V1daVFQxbHliU3RqWmtKM01FRUtWWGx1THpWbmRrRmlUVEJvWlhG
      YVMydFhhRU40TTFoMUx5dEZTbE5sZFhKemVGZDFiRFZ1TkRSallYZGhXWEZ3WlZwcGFHVjNNRWxa
      UTFFeUt5dGtTUXBGZG5NMVkwVlZiblEyTWs1d1VEZzBVM050ZFdSb2JFTktkelV3UTBKQ1VVODRj
      R1ozZHpWRVpXVTNXbk16TkZOMVRHcHhORW8yYUdSSmN6aEtjalpzQ2xKak1GZE9XbmR1TURkWVZE
      VTJUMHRYY0ZBdmFuWjZhMVJwTjBwQ05Fa3ZVMmxFUkc1Wk1ITTJaakEwY25VelZtRmxVVlpyTm10
      UU5IazJWVlprYmpnS2EwWkxkVkY0T0ZWRlJEZHFTemhzYURWa2JsRlZlalZNTDBvMkswSjFhR3d5
      TkRsb1JqbHZVRmhtWWxKUFRGQjBURzA1WWxoaGRXcDBiMlZFTDNsNlZ3cEtVV1oxZW1GSVYyaEdk
      Mll6YmpSemNrTmlXREJrV0hNMldYbENOMXBEZDFGRmRsQm1iSGxYZW5SeE1XVk1WMkpsTTNkamVU
      QTVVR3BSVWxaV1J5ODVDa3AzVVc1TU1FbEdNeXR1WXk5bVJtbDBiRkpKUTI5VVFreHhiRmRJWkVa
      T2MwUkZXbVJGZDAxVk1FaE9hV3hsVUhSNFdVdEtlRXRwTHpsNmIydGFVVlFLUlRGdE0wUnNhVzVu
      UkRCamFHWkplVFJNVkZKMGExQklXakZoVkVVMmFqVTBXSGgzVGtGMVRGVTBUSG95TDNvMGRWaDFh
      azVSZEVOWE0ybFdWMlphY0FwaWVtMTBZMFpZU0RWNE5TOTFOV1J2VDNjd1IycEhVMkZvY0ZsSWVu
      SlNRblpFZEZVM09Ga3dWM1p5VGtWTFZIVm5TVlJwYlRKTFVIWTBWSEpqYjFGSENqaDVjVk0zVjJa
      Vk9ESlBVbXRJTkdJeFNEQm9RblJYT1V3clpYUTBVekpOWlVKMVRrOTRZbHBrWjNGMVdXTjRUVVJV
      Vm1Gc05tODJRMFpRTnpaRWJtb0tjWFpXZDFBclQyMUNlVkE1UVZoQlRVTndSWEUxYlRKS1RrZERS
      VFpEYkVGU2MyeFlRbGRRUjNSaWRVOXRabWR5UzNaMmJVUkdRVTR4TjBWeE5GWkVVd3BJY2xGQlJH
      NHdNRTlDTTAxWWVtNVhOWFJJY1FvOWJHaHpPUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86354-8
    - CJIS-5.6.2.1.1
    - NIST-800-171-3.5.8
    - NIST-800-53-IA-5(1)(e)
    - NIST-800-53-IA-5(f)
    - PCI-DSS-Req-8.2.5
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.7
    - accounts_password_pam_pwhistory_remember_password_auth
    - configure_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - no_reboot_needed
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: 'Limit Password Reuse: password-auth - Check if system relies on authselect tool'
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"pam" in ansible_facts.packages'

    - name: 'Limit Password Reuse: password-auth - Collect the available authselect features'
      ansible.builtin.command:
        cmd: authselect list-features sssd
      register: result_authselect_available_features
      changed_when: false
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: 'Limit Password Reuse: password-auth - Enable pam_pwhistory.so using authselect feature'
      block:

        - name: 'Limit Password Reuse: password-auth - Check integrity of authselect current profile'
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: 'Limit Password Reuse: password-auth - Informative message based on the authselect integrity check result'
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: 'Limit Password Reuse: password-auth - Get authselect current features'
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: 'Limit Password Reuse: password-auth - Ensure "with-pwhistory" feature is enabled using authselect tool'
          ansible.builtin.command:
            cmd: authselect enable-feature with-pwhistory
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-pwhistory")

        - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists
        - result_authselect_available_features.stdout is search("with-pwhistory")

    - name: 'Limit Password Reuse: password-auth - Enable pam_pwhistory.so in appropriate PAM files'
      block:

        - name: 'Limit Password Reuse: password-auth - Define the PAM file to be edited as a local fact'
          ansible.builtin.set_fact:
            pam_file_path: /etc/pam.d/password-auth

        - name: 'Limit Password Reuse: password-auth - Check if system relies on authselect tool'
          ansible.builtin.stat:
            path: /usr/bin/authselect
          register: result_authselect_present

        - name: 'Limit Password Reuse: password-auth - Ensure authselect custom profile is used if authselect is present'
          block:

            - name: 'Limit Password Reuse: password-auth - Check integrity of authselect current profile'
              ansible.builtin.command:
                cmd: authselect check
              register: result_authselect_check_cmd
              changed_when: false
              failed_when: false

            - name: 'Limit Password Reuse: password-auth - Informative message based on the authselect integrity check result'
              ansible.builtin.assert:
                that:
                  - result_authselect_check_cmd.rc == 0
                fail_msg:
                  - authselect integrity check failed. Remediation aborted!
                  - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                  - It is not recommended to manually edit the PAM files when authselect tool is available.
                  - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                success_msg:
                  - authselect integrity check passed

            - name: 'Limit Password Reuse: password-auth - Get authselect current profile'
              ansible.builtin.shell:
                cmd: authselect current -r | awk '{ print $1 }'
              register: result_authselect_profile
              changed_when: false
              when:
                - result_authselect_check_cmd is success

            - name: 'Limit Password Reuse: password-auth - Define the current authselect profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is match("custom/")

            - name: 'Limit Password Reuse: password-auth - Define the new authselect custom profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: custom/hardening
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Get authselect current features to also enable them in the custom profile'
              ansible.builtin.shell:
                cmd: authselect current | tail -n+3 | awk '{ print $2 }'
              register: result_authselect_features
              changed_when: false
              when:
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Check if any custom profile with the same name was already created'
              ansible.builtin.stat:
                path: /etc/authselect/{{ authselect_custom_profile }}
              register: result_authselect_custom_profile_present
              changed_when: false
              when:
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on the current profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is not match("^(custom/|local)")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on sssd profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b sssd
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is match("local")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: password-auth - Ensure the authselect custom profile is selected'
              ansible.builtin.command:
                cmd: authselect select {{ authselect_custom_profile }}
              register: result_pam_authselect_select_profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: password-auth - Restore the authselect features in the custom profile'
              ansible.builtin.command:
                cmd: authselect enable-feature {{ item }}
              loop: '{{ result_authselect_features.stdout_lines }}'
              register: result_pam_authselect_restore_features
              when:
                - result_authselect_profile is not skipped
                - result_authselect_features is not skipped
                - result_pam_authselect_select_profile is not skipped

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - result_pam_authselect_restore_features is not skipped

            - name: 'Limit Password Reuse: password-auth - Change the PAM file to be edited according to the custom authselect profile'
              ansible.builtin.set_fact:
                pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
          when:
            - result_authselect_present.stat.exists

        - name: 'Limit Password Reuse: password-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: '{{ var_password_pam_remember_control_flag.split(",")[0] }}'

        - name: 'Limit Password Reuse: password-auth - Check if expected PAM module line is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_line_present

        - name: 'Limit Password Reuse: password-auth - Include or update the PAM module line in {{ pam_file_path }}'
          block:

            - name: 'Limit Password Reuse: password-auth - Check if required PAM module line is present in {{ pam_file_path }} with different control'
              ansible.builtin.lineinfile:
                path: '{{ pam_file_path }}'
                regexp: ^\s*password\s+.*\s+pam_pwhistory.so\s*
                state: absent
              check_mode: true
              changed_when: false
              register: result_pam_line_other_control_present

            - name: 'Limit Password Reuse: password-auth - Ensure the correct control for the required PAM module line in {{ pam_file_path }}'
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: ^(\s*password\s+).*(\bpam_pwhistory.so.*)
                replace: \1{{ pam_module_control }} \2
              register: result_pam_module_edit
              when:
                - result_pam_line_other_control_present.found == 1

            - name: 'Limit Password Reuse: password-auth - Ensure the required PAM module line is included in {{ pam_file_path }}'
              ansible.builtin.lineinfile:
                dest: '{{ pam_file_path }}'
                insertafter: ^password.*requisite.*pam_pwquality\.so
                line: password    {{ pam_module_control }}    pam_pwhistory.so
              register: result_pam_module_add
              when:
                - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found > 1

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present is defined
                - result_authselect_present.stat.exists
                - |-
                  (result_pam_module_add is defined and result_pam_module_add.changed)
                   or (result_pam_module_edit is defined and result_pam_module_edit.changed)
          when:
            - result_pam_line_present.found is defined
            - result_pam_line_present.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - |
          (result_authselect_available_features.stdout is defined and result_authselect_available_features.stdout is not search("with-pwhistory")) or result_authselect_available_features is not defined

    - name: 'Limit Password Reuse: password-auth - Check the presence of /etc/security/pwhistory.conf file'
      ansible.builtin.stat:
        path: /etc/security/pwhistory.conf
      register: result_pwhistory_conf_check
      when: '"pam" in ansible_facts.packages'

    - name: 'Limit Password Reuse: password-auth - pam_pwhistory.so parameters are configured in /etc/security/pwhistory.conf file'
      block:

        - name: 'Limit Password Reuse: password-auth - Ensure the pam_pwhistory.so remember parameter in /etc/security/pwhistory.conf'
          ansible.builtin.lineinfile:
            path: /etc/security/pwhistory.conf
            regexp: ^\s*remember\s*=
            line: remember = {{ var_password_pam_remember }}
            state: present

        - name: 'Limit Password Reuse: password-auth - Ensure the pam_pwhistory.so remember parameter is removed from PAM files'
          block:

            - name: 'Limit Password Reuse: password-auth - Check if /etc/pam.d/password-auth file is present'
              ansible.builtin.stat:
                path: /etc/pam.d/password-auth
              register: result_pam_file_present

            - name: 'Limit Password Reuse: password-auth - Check the proper remediation for the system'
              block:

                - name: 'Limit Password Reuse: password-auth - Define the PAM file to be edited as a local fact'
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/pam.d/password-auth

                - name: 'Limit Password Reuse: password-auth - Check if system relies on authselect tool'
                  ansible.builtin.stat:
                    path: /usr/bin/authselect
                  register: result_authselect_present

                - name: 'Limit Password Reuse: password-auth - Ensure authselect custom profile is used if authselect is present'
                  block:

                    - name: 'Limit Password Reuse: password-auth - Check integrity of authselect current profile'
                      ansible.builtin.command:
                        cmd: authselect check
                      register: result_authselect_check_cmd
                      changed_when: false
                      failed_when: false

                    - name: 'Limit Password Reuse: password-auth - Informative message based on the authselect integrity check result'
                      ansible.builtin.assert:
                        that:
                          - result_authselect_check_cmd.rc == 0
                        fail_msg:
                          - authselect integrity check failed. Remediation aborted!
                          - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                          - It is not recommended to manually edit the PAM files when authselect tool is available.
                          - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                        success_msg:
                          - authselect integrity check passed

                    - name: 'Limit Password Reuse: password-auth - Get authselect current profile'
                      ansible.builtin.shell:
                        cmd: authselect current -r | awk '{ print $1 }'
                      register: result_authselect_profile
                      changed_when: false
                      when:
                        - result_authselect_check_cmd is success

                    - name: 'Limit Password Reuse: password-auth - Define the current authselect profile as a local fact'
                      ansible.builtin.set_fact:
                        authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_profile.stdout is match("custom/")

                    - name: 'Limit Password Reuse: password-auth - Define the new authselect custom profile as a local fact'
                      ansible.builtin.set_fact:
                        authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                        authselect_custom_profile: custom/hardening
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_profile.stdout is not match("custom/")

                    - name: 'Limit Password Reuse: password-auth - Get authselect current features to also enable them in the custom profile'
                      ansible.builtin.shell:
                        cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                      register: result_authselect_features
                      changed_when: false
                      when:
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")

                    - name: 'Limit Password Reuse: password-auth - Check if any custom profile with the same name was already created'
                      ansible.builtin.stat:
                        path: /etc/authselect/{{ authselect_custom_profile }}
                      register: result_authselect_custom_profile_present
                      changed_when: false
                      when:
                        - authselect_current_profile is not match("custom/")

                    - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on the current profile'
                      ansible.builtin.command:
                        cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                      when:
                        - result_authselect_check_cmd is success
                        - authselect_current_profile is not match("^(custom/|local)")
                        - not result_authselect_custom_profile_present.stat.exists

                    - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on sssd profile'
                      ansible.builtin.command:
                        cmd: authselect create-profile hardening -b sssd
                      when:
                        - result_authselect_check_cmd is success
                        - authselect_current_profile is match("local")
                        - not result_authselect_custom_profile_present.stat.exists

                    - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
                      ansible.builtin.command:
                        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")
                        - authselect_custom_profile is not match(authselect_current_profile)

                    - name: 'Limit Password Reuse: password-auth - Ensure the authselect custom profile is selected'
                      ansible.builtin.command:
                        cmd: authselect select {{ authselect_custom_profile }}
                      register: result_pam_authselect_select_profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")
                        - authselect_custom_profile is not match(authselect_current_profile)

                    - name: 'Limit Password Reuse: password-auth - Restore the authselect features in the custom profile'
                      ansible.builtin.command:
                        cmd: authselect enable-feature {{ item }}
                      loop: '{{ result_authselect_features.stdout_lines }}'
                      register: result_pam_authselect_restore_features
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_features is not skipped
                        - result_pam_authselect_select_profile is not skipped

                    - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
                      ansible.builtin.command:
                        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - result_pam_authselect_restore_features is not skipped

                    - name: 'Limit Password Reuse: password-auth - Change the PAM file to be edited according to the custom authselect profile'
                      ansible.builtin.set_fact:
                        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
                  when:
                    - result_authselect_present.stat.exists

                - name: 'Limit Password Reuse: password-auth - Define a fact for control already filtered in case filters are used'
                  ansible.builtin.set_fact:
                    pam_module_control: ''

                - name: 'Limit Password Reuse: password-auth - Ensure the "remember" option from "pam_pwhistory.so" is not present in {{ pam_file_path }}'
                  ansible.builtin.replace:
                    dest: '{{ pam_file_path }}'
                    regexp: (.*password.*pam_pwhistory.so.*)\bremember\b=?[0-9a-zA-Z]*(.*)
                    replace: \1\2
                  register: result_pam_option_removal

                - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b
                  when:
                    - result_authselect_present.stat.exists
                    - result_pam_option_removal is changed
              when:
                - result_pam_file_present.stat.exists
      when:
        - '"pam" in ansible_facts.packages'
        - result_pwhistory_conf_check.stat.exists

    - name: 'Limit Password Reuse: password-auth - pam_pwhistory.so parameters are configured in PAM files'
      block:

        - name: 'Limit Password Reuse: password-auth - Define the PAM file to be edited as a local fact'
          ansible.builtin.set_fact:
            pam_file_path: /etc/pam.d/password-auth

        - name: 'Limit Password Reuse: password-auth - Check if system relies on authselect tool'
          ansible.builtin.stat:
            path: /usr/bin/authselect
          register: result_authselect_present

        - name: 'Limit Password Reuse: password-auth - Ensure authselect custom profile is used if authselect is present'
          block:

            - name: 'Limit Password Reuse: password-auth - Check integrity of authselect current profile'
              ansible.builtin.command:
                cmd: authselect check
              register: result_authselect_check_cmd
              changed_when: false
              failed_when: false

            - name: 'Limit Password Reuse: password-auth - Informative message based on the authselect integrity check result'
              ansible.builtin.assert:
                that:
                  - result_authselect_check_cmd.rc == 0
                fail_msg:
                  - authselect integrity check failed. Remediation aborted!
                  - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                  - It is not recommended to manually edit the PAM files when authselect tool is available.
                  - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                success_msg:
                  - authselect integrity check passed

            - name: 'Limit Password Reuse: password-auth - Get authselect current profile'
              ansible.builtin.shell:
                cmd: authselect current -r | awk '{ print $1 }'
              register: result_authselect_profile
              changed_when: false
              when:
                - result_authselect_check_cmd is success

            - name: 'Limit Password Reuse: password-auth - Define the current authselect profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is match("custom/")

            - name: 'Limit Password Reuse: password-auth - Define the new authselect custom profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: custom/hardening
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Get authselect current features to also enable them in the custom profile'
              ansible.builtin.shell:
                cmd: authselect current | tail -n+3 | awk '{ print $2 }'
              register: result_authselect_features
              changed_when: false
              when:
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Check if any custom profile with the same name was already created'
              ansible.builtin.stat:
                path: /etc/authselect/{{ authselect_custom_profile }}
              register: result_authselect_custom_profile_present
              changed_when: false
              when:
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on the current profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is not match("^(custom/|local)")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: password-auth - Create an authselect custom profile based on sssd profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b sssd
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is match("local")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: password-auth - Ensure the authselect custom profile is selected'
              ansible.builtin.command:
                cmd: authselect select {{ authselect_custom_profile }}
              register: result_pam_authselect_select_profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: password-auth - Restore the authselect features in the custom profile'
              ansible.builtin.command:
                cmd: authselect enable-feature {{ item }}
              loop: '{{ result_authselect_features.stdout_lines }}'
              register: result_pam_authselect_restore_features
              when:
                - result_authselect_profile is not skipped
                - result_authselect_features is not skipped
                - result_pam_authselect_select_profile is not skipped

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - result_pam_authselect_restore_features is not skipped

            - name: 'Limit Password Reuse: password-auth - Change the PAM file to be edited according to the custom authselect profile'
              ansible.builtin.set_fact:
                pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
          when:
            - result_authselect_present.stat.exists

        - name: 'Limit Password Reuse: password-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: requisite

        - name: 'Limit Password Reuse: password-auth - Check if expected PAM module line is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_line_present

        - name: 'Limit Password Reuse: password-auth - Include or update the PAM module line in {{ pam_file_path }}'
          block:

            - name: 'Limit Password Reuse: password-auth - Check if required PAM module line is present in {{ pam_file_path }} with different control'
              ansible.builtin.lineinfile:
                path: '{{ pam_file_path }}'
                regexp: ^\s*password\s+.*\s+pam_pwhistory.so\s*
                state: absent
              check_mode: true
              changed_when: false
              register: result_pam_line_other_control_present

            - name: 'Limit Password Reuse: password-auth - Ensure the correct control for the required PAM module line in {{ pam_file_path }}'
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: ^(\s*password\s+).*(\bpam_pwhistory.so.*)
                replace: \1{{ pam_module_control }} \2
              register: result_pam_module_edit
              when:
                - result_pam_line_other_control_present.found == 1

            - name: 'Limit Password Reuse: password-auth - Ensure the required PAM module line is included in {{ pam_file_path }}'
              ansible.builtin.lineinfile:
                dest: '{{ pam_file_path }}'
                line: password    {{ pam_module_control }}    pam_pwhistory.so
              register: result_pam_module_add
              when:
                - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found > 1

            - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present is defined
                - result_authselect_present.stat.exists
                - |-
                  (result_pam_module_add is defined and result_pam_module_add.changed)
                   or (result_pam_module_edit is defined and result_pam_module_edit.changed)
          when:
            - result_pam_line_present.found is defined
            - result_pam_line_present.found == 0

        - name: 'Limit Password Reuse: password-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: requisite

        - name: 'Limit Password Reuse: password-auth - Check if the required PAM module option is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*\sremember\b
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_module_accounts_password_pam_pwhistory_remember_password_auth_option_present

        - name: 'Limit Password Reuse: password-auth - Ensure the "remember" PAM option for "pam_pwhistory.so" is included in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            backrefs: true
            regexp: ^(\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so.*)
            line: \1 remember={{ var_password_pam_remember }}
            state: present
          register: result_pam_accounts_password_pam_pwhistory_remember_password_auth_add
          when:
            - result_pam_module_accounts_password_pam_pwhistory_remember_password_auth_option_present.found == 0

        - name: 'Limit Password Reuse: password-auth - Ensure the required value for "remember" PAM option from "pam_pwhistory.so" in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            backrefs: true
            regexp: ^(\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s+.*)(remember)=[0-9a-zA-Z]*\s*(.*)
            line: \1\2={{ var_password_pam_remember }} \3
          register: result_pam_accounts_password_pam_pwhistory_remember_password_auth_edit
          when:
            - result_pam_module_accounts_password_pam_pwhistory_remember_password_auth_option_present.found > 0

        - name: 'Limit Password Reuse: password-auth - Ensure authselect changes are applied'
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_present.stat.exists
            - (result_pam_remember_add is defined and result_pam_remember_add.changed) or (result_pam_remember_edit is defined and result_pam_remember_edit.changed)
      when:
        - '"pam" in ansible_facts.packages'
        - not result_pwhistory_conf_check.stat.exists


# Limit Password Reuse: system-auth
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_pam_pwhistory_remember_system_auth,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_almalinux
# reboot = false
# strategy = configure
# complexity = low
# disruption = medium
- name: 'Limit Password Reuse: system-auth'
  hosts: all
  become: true
  vars:
    var_password_pam_remember: '24'
    var_password_pam_remember_control_flag: requisite,required
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      Y3lPRkZCUzBwa1V5OU9aMDE2YWpnMFpXaFZOSEJtY25veWExQUtiWGsxYUZKVE1sSjJka1Z5WnpK
      T1NraHZVa1EzUm05SlQxQjFNeXR5YTBoQ2JUSTVRVWxHWW5SWlZuZ3dLME5hZG1oVmJpOUpNekF3
      TmtSemNtWndNUXBwVnl0VWVVTnljeTlJZUROMVlYVm1ZVmRtY25CU2JFRlpia1JuU1VGTFRWSkZa
      bTR6TVhCQlpVcHRiaTlLV1dKcWJHdGhVMVpOUTFOSU5FSkVjak5sQ201b2NVZE5NMlZsZGpjNWFE
      SjZjbTVxTUhrdlptNWhRV1F5VVZsSWVqUnlXRVJqTkhOVGFHSnZiamxxTWtvMVNIUmlabkp2TURO
      bmFreFpNakkxVlcwS2RGRjVNM0oxZG04eWJtaDJZMnRqZDJ0clIyODNSa1k1ZDJGV1ZUTm5OSGw2
      ZUhCMVRuSkxZVVZXTWtGWVVFeEZVRk5UYVdoSVVYRlVVR2RyZDNKb1VncFhNbFpSTkVSNFZqSkNS
      M0JqTkVRMFNEUjJVSGxRTDNkeVIwSklXazlPWlRjeUswcE1jRlE1T1RoRFFrSjJlRWhwUzJSRFRU
      Y3JMMDVtVWxoeGFrcHdDazA1WkVSYWVIcHJRM2xFWVdWelJreHhRbEpSSzBnMFN6TndlamxzZW1V
      MlNFbFlXa1Z1ZG10Q2REVkNSSFYySzNrdkt5dERja2MyUTAxNFF6SnhkbXdLYkhWUlJtRm9ielpX
      WlhZNVFuVmtPVzlVUVdKS1NtSlBXV0kwZVZaMFZVWlhaREJ4TWxocVNUSjBWVGs0V1dZclZEaG5a
      VW94WkZoNVlVMDFTMmM1U1FwMWQzRk9VSGRUVDJaRFJFNU5aemh6UTA1SWJFRXpZM2MzZDBZMlRE
      QnJaRWxZTldsNlRraHhkbXhDYTBaNE1XRjNRWGxOV1U5Uk0wWkdXWGhUYW1KdENuUkZWVFkxWmxW
      V1N6SkpjaTlTU1dWWlRuaGpjRWxJWmtST2FGVlNSMnQyU1ZvNE5WVnBOa1Z5TnpJMFpYcFNjVXBZ
      TDBReFUzbDJSVEprVmxadVJrNEtOVzVVZDFnemRXcGtWVzg1YWxWb1FWaDJkR05DU1ZkQmVqRk9V
      VTFvZWpnM1ZFTlVNRGcxZWxZM1UwWTBiRVZDY21WNU9GTkJkRUY0ZEhOMmFrdHpkZ296ZEU5RmVG
      QkVMMncwYWxaM2RFYzVkbXRMYkFvOVYwOXJiZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-89176-2
    - CJIS-5.6.2.1.1
    - NIST-800-171-3.5.8
    - NIST-800-53-IA-5(1)(e)
    - NIST-800-53-IA-5(f)
    - PCI-DSS-Req-8.2.5
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.7
    - accounts_password_pam_pwhistory_remember_system_auth
    - configure_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - no_reboot_needed
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: 'Limit Password Reuse: system-auth - Check if system relies on authselect tool'
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"pam" in ansible_facts.packages'

    - name: 'Limit Password Reuse: system-auth - Collect the available authselect features'
      ansible.builtin.command:
        cmd: authselect list-features sssd
      register: result_authselect_available_features
      changed_when: false
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: 'Limit Password Reuse: system-auth - Enable pam_pwhistory.so using authselect feature'
      block:

        - name: 'Limit Password Reuse: system-auth - Check integrity of authselect current profile'
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: 'Limit Password Reuse: system-auth - Informative message based on the authselect integrity check result'
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: 'Limit Password Reuse: system-auth - Get authselect current features'
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: 'Limit Password Reuse: system-auth - Ensure "with-pwhistory" feature is enabled using authselect tool'
          ansible.builtin.command:
            cmd: authselect enable-feature with-pwhistory
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-pwhistory")

        - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists
        - result_authselect_available_features.stdout is search("with-pwhistory")

    - name: 'Limit Password Reuse: system-auth - Enable pam_pwhistory.so in appropriate PAM files'
      block:

        - name: 'Limit Password Reuse: system-auth - Define the PAM file to be edited as a local fact'
          ansible.builtin.set_fact:
            pam_file_path: /etc/pam.d/system-auth

        - name: 'Limit Password Reuse: system-auth - Check if system relies on authselect tool'
          ansible.builtin.stat:
            path: /usr/bin/authselect
          register: result_authselect_present

        - name: 'Limit Password Reuse: system-auth - Ensure authselect custom profile is used if authselect is present'
          block:

            - name: 'Limit Password Reuse: system-auth - Check integrity of authselect current profile'
              ansible.builtin.command:
                cmd: authselect check
              register: result_authselect_check_cmd
              changed_when: false
              failed_when: false

            - name: 'Limit Password Reuse: system-auth - Informative message based on the authselect integrity check result'
              ansible.builtin.assert:
                that:
                  - result_authselect_check_cmd.rc == 0
                fail_msg:
                  - authselect integrity check failed. Remediation aborted!
                  - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                  - It is not recommended to manually edit the PAM files when authselect tool is available.
                  - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                success_msg:
                  - authselect integrity check passed

            - name: 'Limit Password Reuse: system-auth - Get authselect current profile'
              ansible.builtin.shell:
                cmd: authselect current -r | awk '{ print $1 }'
              register: result_authselect_profile
              changed_when: false
              when:
                - result_authselect_check_cmd is success

            - name: 'Limit Password Reuse: system-auth - Define the current authselect profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is match("custom/")

            - name: 'Limit Password Reuse: system-auth - Define the new authselect custom profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: custom/hardening
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Get authselect current features to also enable them in the custom profile'
              ansible.builtin.shell:
                cmd: authselect current | tail -n+3 | awk '{ print $2 }'
              register: result_authselect_features
              changed_when: false
              when:
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Check if any custom profile with the same name was already created'
              ansible.builtin.stat:
                path: /etc/authselect/{{ authselect_custom_profile }}
              register: result_authselect_custom_profile_present
              changed_when: false
              when:
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on the current profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is not match("^(custom/|local)")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on sssd profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b sssd
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is match("local")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: system-auth - Ensure the authselect custom profile is selected'
              ansible.builtin.command:
                cmd: authselect select {{ authselect_custom_profile }}
              register: result_pam_authselect_select_profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: system-auth - Restore the authselect features in the custom profile'
              ansible.builtin.command:
                cmd: authselect enable-feature {{ item }}
              loop: '{{ result_authselect_features.stdout_lines }}'
              register: result_pam_authselect_restore_features
              when:
                - result_authselect_profile is not skipped
                - result_authselect_features is not skipped
                - result_pam_authselect_select_profile is not skipped

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - result_pam_authselect_restore_features is not skipped

            - name: 'Limit Password Reuse: system-auth - Change the PAM file to be edited according to the custom authselect profile'
              ansible.builtin.set_fact:
                pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
          when:
            - result_authselect_present.stat.exists

        - name: 'Limit Password Reuse: system-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: '{{ var_password_pam_remember_control_flag.split(",")[0] }}'

        - name: 'Limit Password Reuse: system-auth - Check if expected PAM module line is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_line_present

        - name: 'Limit Password Reuse: system-auth - Include or update the PAM module line in {{ pam_file_path }}'
          block:

            - name: 'Limit Password Reuse: system-auth - Check if required PAM module line is present in {{ pam_file_path }} with different control'
              ansible.builtin.lineinfile:
                path: '{{ pam_file_path }}'
                regexp: ^\s*password\s+.*\s+pam_pwhistory.so\s*
                state: absent
              check_mode: true
              changed_when: false
              register: result_pam_line_other_control_present

            - name: 'Limit Password Reuse: system-auth - Ensure the correct control for the required PAM module line in {{ pam_file_path }}'
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: ^(\s*password\s+).*(\bpam_pwhistory.so.*)
                replace: \1{{ pam_module_control }} \2
              register: result_pam_module_edit
              when:
                - result_pam_line_other_control_present.found == 1

            - name: 'Limit Password Reuse: system-auth - Ensure the required PAM module line is included in {{ pam_file_path }}'
              ansible.builtin.lineinfile:
                dest: '{{ pam_file_path }}'
                insertafter: ^password.*requisite.*pam_pwquality\.so
                line: password    {{ pam_module_control }}    pam_pwhistory.so
              register: result_pam_module_add
              when:
                - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found > 1

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present is defined
                - result_authselect_present.stat.exists
                - |-
                  (result_pam_module_add is defined and result_pam_module_add.changed)
                   or (result_pam_module_edit is defined and result_pam_module_edit.changed)
          when:
            - result_pam_line_present.found is defined
            - result_pam_line_present.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - |
          (result_authselect_available_features.stdout is defined and result_authselect_available_features.stdout is not search("with-pwhistory")) or result_authselect_available_features is not defined

    - name: 'Limit Password Reuse: system-auth - Check the presence of /etc/security/pwhistory.conf file'
      ansible.builtin.stat:
        path: /etc/security/pwhistory.conf
      register: result_pwhistory_conf_check
      when: '"pam" in ansible_facts.packages'

    - name: 'Limit Password Reuse: system-auth - pam_pwhistory.so parameters are configured in /etc/security/pwhistory.conf file'
      block:

        - name: 'Limit Password Reuse: system-auth - Ensure the pam_pwhistory.so remember parameter in /etc/security/pwhistory.conf'
          ansible.builtin.lineinfile:
            path: /etc/security/pwhistory.conf
            regexp: ^\s*remember\s*=
            line: remember = {{ var_password_pam_remember }}
            state: present

        - name: 'Limit Password Reuse: system-auth - Ensure the pam_pwhistory.so remember parameter is removed from PAM files'
          block:

            - name: 'Limit Password Reuse: system-auth - Check if /etc/pam.d/system-auth file is present'
              ansible.builtin.stat:
                path: /etc/pam.d/system-auth
              register: result_pam_file_present

            - name: 'Limit Password Reuse: system-auth - Check the proper remediation for the system'
              block:

                - name: 'Limit Password Reuse: system-auth - Define the PAM file to be edited as a local fact'
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/pam.d/system-auth

                - name: 'Limit Password Reuse: system-auth - Check if system relies on authselect tool'
                  ansible.builtin.stat:
                    path: /usr/bin/authselect
                  register: result_authselect_present

                - name: 'Limit Password Reuse: system-auth - Ensure authselect custom profile is used if authselect is present'
                  block:

                    - name: 'Limit Password Reuse: system-auth - Check integrity of authselect current profile'
                      ansible.builtin.command:
                        cmd: authselect check
                      register: result_authselect_check_cmd
                      changed_when: false
                      failed_when: false

                    - name: 'Limit Password Reuse: system-auth - Informative message based on the authselect integrity check result'
                      ansible.builtin.assert:
                        that:
                          - result_authselect_check_cmd.rc == 0
                        fail_msg:
                          - authselect integrity check failed. Remediation aborted!
                          - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                          - It is not recommended to manually edit the PAM files when authselect tool is available.
                          - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                        success_msg:
                          - authselect integrity check passed

                    - name: 'Limit Password Reuse: system-auth - Get authselect current profile'
                      ansible.builtin.shell:
                        cmd: authselect current -r | awk '{ print $1 }'
                      register: result_authselect_profile
                      changed_when: false
                      when:
                        - result_authselect_check_cmd is success

                    - name: 'Limit Password Reuse: system-auth - Define the current authselect profile as a local fact'
                      ansible.builtin.set_fact:
                        authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_profile.stdout is match("custom/")

                    - name: 'Limit Password Reuse: system-auth - Define the new authselect custom profile as a local fact'
                      ansible.builtin.set_fact:
                        authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                        authselect_custom_profile: custom/hardening
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_profile.stdout is not match("custom/")

                    - name: 'Limit Password Reuse: system-auth - Get authselect current features to also enable them in the custom profile'
                      ansible.builtin.shell:
                        cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                      register: result_authselect_features
                      changed_when: false
                      when:
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")

                    - name: 'Limit Password Reuse: system-auth - Check if any custom profile with the same name was already created'
                      ansible.builtin.stat:
                        path: /etc/authselect/{{ authselect_custom_profile }}
                      register: result_authselect_custom_profile_present
                      changed_when: false
                      when:
                        - authselect_current_profile is not match("custom/")

                    - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on the current profile'
                      ansible.builtin.command:
                        cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                      when:
                        - result_authselect_check_cmd is success
                        - authselect_current_profile is not match("^(custom/|local)")
                        - not result_authselect_custom_profile_present.stat.exists

                    - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on sssd profile'
                      ansible.builtin.command:
                        cmd: authselect create-profile hardening -b sssd
                      when:
                        - result_authselect_check_cmd is success
                        - authselect_current_profile is match("local")
                        - not result_authselect_custom_profile_present.stat.exists

                    - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
                      ansible.builtin.command:
                        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")
                        - authselect_custom_profile is not match(authselect_current_profile)

                    - name: 'Limit Password Reuse: system-auth - Ensure the authselect custom profile is selected'
                      ansible.builtin.command:
                        cmd: authselect select {{ authselect_custom_profile }}
                      register: result_pam_authselect_select_profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - authselect_current_profile is not match("custom/")
                        - authselect_custom_profile is not match(authselect_current_profile)

                    - name: 'Limit Password Reuse: system-auth - Restore the authselect features in the custom profile'
                      ansible.builtin.command:
                        cmd: authselect enable-feature {{ item }}
                      loop: '{{ result_authselect_features.stdout_lines }}'
                      register: result_pam_authselect_restore_features
                      when:
                        - result_authselect_profile is not skipped
                        - result_authselect_features is not skipped
                        - result_pam_authselect_select_profile is not skipped

                    - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
                      ansible.builtin.command:
                        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                      when:
                        - result_authselect_check_cmd is success
                        - result_authselect_profile is not skipped
                        - result_pam_authselect_restore_features is not skipped

                    - name: 'Limit Password Reuse: system-auth - Change the PAM file to be edited according to the custom authselect profile'
                      ansible.builtin.set_fact:
                        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
                  when:
                    - result_authselect_present.stat.exists

                - name: 'Limit Password Reuse: system-auth - Define a fact for control already filtered in case filters are used'
                  ansible.builtin.set_fact:
                    pam_module_control: ''

                - name: 'Limit Password Reuse: system-auth - Ensure the "remember" option from "pam_pwhistory.so" is not present in {{ pam_file_path }}'
                  ansible.builtin.replace:
                    dest: '{{ pam_file_path }}'
                    regexp: (.*password.*pam_pwhistory.so.*)\bremember\b=?[0-9a-zA-Z]*(.*)
                    replace: \1\2
                  register: result_pam_option_removal

                - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b
                  when:
                    - result_authselect_present.stat.exists
                    - result_pam_option_removal is changed
              when:
                - result_pam_file_present.stat.exists
      when:
        - '"pam" in ansible_facts.packages'
        - result_pwhistory_conf_check.stat.exists

    - name: 'Limit Password Reuse: system-auth - pam_pwhistory.so parameters are configured in PAM files'
      block:

        - name: 'Limit Password Reuse: system-auth - Define the PAM file to be edited as a local fact'
          ansible.builtin.set_fact:
            pam_file_path: /etc/pam.d/system-auth

        - name: 'Limit Password Reuse: system-auth - Check if system relies on authselect tool'
          ansible.builtin.stat:
            path: /usr/bin/authselect
          register: result_authselect_present

        - name: 'Limit Password Reuse: system-auth - Ensure authselect custom profile is used if authselect is present'
          block:

            - name: 'Limit Password Reuse: system-auth - Check integrity of authselect current profile'
              ansible.builtin.command:
                cmd: authselect check
              register: result_authselect_check_cmd
              changed_when: false
              failed_when: false

            - name: 'Limit Password Reuse: system-auth - Informative message based on the authselect integrity check result'
              ansible.builtin.assert:
                that:
                  - result_authselect_check_cmd.rc == 0
                fail_msg:
                  - authselect integrity check failed. Remediation aborted!
                  - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                  - It is not recommended to manually edit the PAM files when authselect tool is available.
                  - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                success_msg:
                  - authselect integrity check passed

            - name: 'Limit Password Reuse: system-auth - Get authselect current profile'
              ansible.builtin.shell:
                cmd: authselect current -r | awk '{ print $1 }'
              register: result_authselect_profile
              changed_when: false
              when:
                - result_authselect_check_cmd is success

            - name: 'Limit Password Reuse: system-auth - Define the current authselect profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is match("custom/")

            - name: 'Limit Password Reuse: system-auth - Define the new authselect custom profile as a local fact'
              ansible.builtin.set_fact:
                authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                authselect_custom_profile: custom/hardening
              when:
                - result_authselect_profile is not skipped
                - result_authselect_profile.stdout is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Get authselect current features to also enable them in the custom profile'
              ansible.builtin.shell:
                cmd: authselect current | tail -n+3 | awk '{ print $2 }'
              register: result_authselect_features
              changed_when: false
              when:
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Check if any custom profile with the same name was already created'
              ansible.builtin.stat:
                path: /etc/authselect/{{ authselect_custom_profile }}
              register: result_authselect_custom_profile_present
              changed_when: false
              when:
                - authselect_current_profile is not match("custom/")

            - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on the current profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is not match("^(custom/|local)")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: system-auth - Create an authselect custom profile based on sssd profile'
              ansible.builtin.command:
                cmd: authselect create-profile hardening -b sssd
              when:
                - result_authselect_check_cmd is success
                - authselect_current_profile is match("local")
                - not result_authselect_custom_profile_present.stat.exists

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: system-auth - Ensure the authselect custom profile is selected'
              ansible.builtin.command:
                cmd: authselect select {{ authselect_custom_profile }}
              register: result_pam_authselect_select_profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - authselect_current_profile is not match("custom/")
                - authselect_custom_profile is not match(authselect_current_profile)

            - name: 'Limit Password Reuse: system-auth - Restore the authselect features in the custom profile'
              ansible.builtin.command:
                cmd: authselect enable-feature {{ item }}
              loop: '{{ result_authselect_features.stdout_lines }}'
              register: result_pam_authselect_restore_features
              when:
                - result_authselect_profile is not skipped
                - result_authselect_features is not skipped
                - result_pam_authselect_select_profile is not skipped

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
              when:
                - result_authselect_check_cmd is success
                - result_authselect_profile is not skipped
                - result_pam_authselect_restore_features is not skipped

            - name: 'Limit Password Reuse: system-auth - Change the PAM file to be edited according to the custom authselect profile'
              ansible.builtin.set_fact:
                pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
          when:
            - result_authselect_present.stat.exists

        - name: 'Limit Password Reuse: system-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: requisite

        - name: 'Limit Password Reuse: system-auth - Check if expected PAM module line is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_line_present

        - name: 'Limit Password Reuse: system-auth - Include or update the PAM module line in {{ pam_file_path }}'
          block:

            - name: 'Limit Password Reuse: system-auth - Check if required PAM module line is present in {{ pam_file_path }} with different control'
              ansible.builtin.lineinfile:
                path: '{{ pam_file_path }}'
                regexp: ^\s*password\s+.*\s+pam_pwhistory.so\s*
                state: absent
              check_mode: true
              changed_when: false
              register: result_pam_line_other_control_present

            - name: 'Limit Password Reuse: system-auth - Ensure the correct control for the required PAM module line in {{ pam_file_path }}'
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: ^(\s*password\s+).*(\bpam_pwhistory.so.*)
                replace: \1{{ pam_module_control }} \2
              register: result_pam_module_edit
              when:
                - result_pam_line_other_control_present.found == 1

            - name: 'Limit Password Reuse: system-auth - Ensure the required PAM module line is included in {{ pam_file_path }}'
              ansible.builtin.lineinfile:
                dest: '{{ pam_file_path }}'
                line: password    {{ pam_module_control }}    pam_pwhistory.so
              register: result_pam_module_add
              when:
                - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found > 1

            - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present is defined
                - result_authselect_present.stat.exists
                - |-
                  (result_pam_module_add is defined and result_pam_module_add.changed)
                   or (result_pam_module_edit is defined and result_pam_module_edit.changed)
          when:
            - result_pam_line_present.found is defined
            - result_pam_line_present.found == 0

        - name: 'Limit Password Reuse: system-auth - Define a fact for control already filtered in case filters are used'
          ansible.builtin.set_fact:
            pam_module_control: requisite

        - name: 'Limit Password Reuse: system-auth - Check if the required PAM module option is present in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            regexp: ^\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s*.*\sremember\b
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_module_accounts_password_pam_pwhistory_remember_system_auth_option_present

        - name: 'Limit Password Reuse: system-auth - Ensure the "remember" PAM option for "pam_pwhistory.so" is included in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            backrefs: true
            regexp: ^(\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so.*)
            line: \1 remember={{ var_password_pam_remember }}
            state: present
          register: result_pam_accounts_password_pam_pwhistory_remember_system_auth_add
          when:
            - result_pam_module_accounts_password_pam_pwhistory_remember_system_auth_option_present.found == 0

        - name: 'Limit Password Reuse: system-auth - Ensure the required value for "remember" PAM option from "pam_pwhistory.so" in {{ pam_file_path }}'
          ansible.builtin.lineinfile:
            path: '{{ pam_file_path }}'
            backrefs: true
            regexp: ^(\s*password\s+{{ pam_module_control | regex_escape() }}\s+pam_pwhistory.so\s+.*)(remember)=[0-9a-zA-Z]*\s*(.*)
            line: \1\2={{ var_password_pam_remember }} \3
          register: result_pam_accounts_password_pam_pwhistory_remember_system_auth_edit
          when:
            - result_pam_module_accounts_password_pam_pwhistory_remember_system_auth_option_present.found > 0

        - name: 'Limit Password Reuse: system-auth - Ensure authselect changes are applied'
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_present.stat.exists
            - (result_pam_remember_add is defined and result_pam_remember_add.changed) or (result_pam_remember_edit is defined and result_pam_remember_edit.changed)
      when:
        - '"pam" in ansible_facts.packages'
        - not result_pwhistory_conf_check.stat.exists


# Set Existing Passwords Maximum Age
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_set_max_life_existing,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_ol,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Existing Passwords Maximum Age
  hosts: all
  become: true
  vars:
    var_accounts_maximum_age_login_defs: '365'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      TldZMUZCUzFKcFowTlZUbUZ6VkRGbmRtdHdOVzVSVjNjelJEWUtObmhWV21GcllXWnNZMmxpVTBw
      SWVFNU9hRW9yTm1GMk1DczBlWGMwUVhWTlJrMHJVMGxJWkRGdVlWUnpWbE5sWm05NlJEUlBhRkl4
      UzFGMVlpdFBTZ3BoYURSa1JYaDRVRk5xVHpRNGJsRXhSMUpOU0ZJMVozWnBhbW94YXpSbFlYZHVl
      bUZ6UVdsQmVGRTJObXRyUVRWR015OU5TRk5wVEdFeFJFRldaemhVQ21OalYyaElRV281YnpsTmVU
      aEpNMk41VVdaWVVGVkllVTltYzJ4Q1VWRnFUbmxrVXpoaWFHZHBWWE50VjNrM01rMXFiWFJ2S3pC
      c1RXNTBZeXM0TW5NS1ZVZG9Temt2SzNwMGN6ZDZLMnBVUmxCQmJHMUtOR1I1UkhaQlJrOTZlalZt
      UzNKdk9UQm1VMHNyT0hCbFpFdzRjbWNyVUhWMFVrcHpXWFptWW5ocVRRcG1hMUZuTURObWVsRTFS
      M05qWTNrM00xZHhVRU5ZVFZkdU0xaHRUVlZ0WkZkQ1JuUlBXbVp5V2xkUmFtTkNlVzVSTTJwSWFF
      cHBkMDFUSzA4MWJHSnRDamxXU21FeVNtcFFRemhuTm1GS1NUWlBNRzlWVjJKS1l6ZE5VMjFKY0cw
      ek1GVnVZV1pWVm5ock1sQmhSREJxVEd0M2IzcE5aVXBFUzI4d2MyTllja3NLYmtOQ1VGWk5UbEIz
      VkdvMmRrcFpVa013T0VaTmVFNWpSeXMyZW5sdlkwVmthVlF4WTFka09HaFFXa1ZuZVhKeVZtTnBS
      a2hhTVVObVNrVlVlUzlUS3dwVFlWTkNTWGg2WWpCVllYUlpXa28zWlRScWRuZEpkVk4xS3poWWRI
      ZElTM2hyTjJaeFpWcDFWbk5yZWtSVWJrRkRlWGR6YkRCSWFGbEpZbmxqTW1SdkNuTktja1ZCWTBk
      aWJISlljMDVUTm1NemJteE5aVU4wUzBJM0t6bEhOMnczVTFFeFRFZ3JiazByV1RCc09XVkJiM001
      T0VOa1ZqZHdZMUpQTXl0RVFrb0tjbGxQVmtOdFdIQTJSbVY2Ymxnd1YxVjRlRzF5THpkWU5rVjRX
      WEZhVVRsNmQzZHBRV3RLUmpSbGRVRndLME5WVWpVeFpUZEZlRFk0YUhscFkxRXdWQXB1WmtoMWRI
      a3JVVXhrVXpFMFZYaHBja3BUU3dvOVRVTjFTUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86031-2
    - DISA-STIG-RHEL-09-411015
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(d)
    - NIST-800-53-IA-5(f)
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.9
    - accounts_password_set_max_life_existing
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Collect users with not correct maximum time period between password changes
      ansible.builtin.command:
        cmd: awk -F':' '(/^[^:]+:[^!*]/ && ($5 > {{ var_accounts_maximum_age_login_defs }} || $5 == "")) {print $1}' /etc/shadow
      register: user_names

    - name: Change the maximum time period between password changes
      ansible.builtin.user:
        user: '{{ item }}'
        password_expire_max: '{{ var_accounts_maximum_age_login_defs }}'
      with_items: '{{ user_names.stdout_lines }}'
      when: user_names.stdout_lines | length > 0


# Set Existing Passwords Minimum Age
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_password_set_min_life_existing,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Existing Passwords Minimum Age
  hosts: all
  become: true
  vars:
    var_accounts_minimum_age_login_defs: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      VllRVkF2YVUxcVREaDZWVEI0TmxndlFrTlJiRmRoUjNSWE5uTUtha1pCVW1Oek9HUllka2hRYjJN
      NFVIbHllRlJUTDJoMlIyRklWVXRPY0VWR1VsRkZVVmxxU0RkVGR6aGtUVTVxUVVKcGIxQlNOa055
      VkRsdFVrMVFTZ3BKVDIxNFJDODFjR1p4UkVOdGJXMXJSWFE1Wm1RMU5raERTbkptZGxvd1luRkha
      V2x1YkVNeFpscE1WMkpYYUdKbVRYUmlXbkpsYTNWaFRuWnFjbXhOQ2pSMlF6SlZaRzB6T0hkMlpX
      VTRTbUpXY1ZobE1ucDNMMmcyT1haNmJIZHZRMWh3YUZwNGNsSTViMjVVYUdOV1J6ZGhWVVZzZDFn
      M1FtMTFha2tyV1ZvS1F5OTFPSEJPYkZBclFtNDFSekJNWVdGNmN6aFJVMlpxVFVwUFdXUlBSblZv
      YzB0Nk5VcFpaSEJKUkZSNE5FcEdObmRLU1VwS1puRXdMemgxU2paSE1BbzJLMVZvYldwQ1ZVcEVj
      RXB2WWtwMllYTXljamRhZWxVclJ6bGpkRkJsVDBWSWNXSlZhelEyYVdjMU4xWkNTSEpUWTA5REwy
      dFVlalZaY2paUGJtNVZDa29yZDJGbGNGQm9jVkZUTlVrelIwSktabTVYTVVWM1dYVlJkbXhoY0dO
      QlJYQjFTbTlZTURkMFRGUklVMHRHTTFwVEsyMU9hV1ZxUlV0MmQwZ3hjeXNLUzJZeE9ERXliMHhH
      VERaaU9XUnhlRGd3T0ZGMWVUSXZNMk12YUVSeVZEZEpWbTVRV0RjMmNFMVFOa04wV1haNmFXWmpT
      V0pKYzBZNVpqSnRRVk5uUWdwUFQwbFlSbkk1ZFdKQlRXNDNWSFZoTmt0elNqYzRhR1IzWkZZeVZV
      cGpNR0pSZUM5WGRWaFFhREF3VmpNd1dteG5UVmxoVEhKSGNWcFNRVUZ6ZFRCQ0NsQmhiV3hKU1hk
      b1IwZ3dObk4zV0dKc1kzZEpVVVkyTjIxMFJVbERPVWRXVURaVlEwZzNURGRyUVVGcFIzbE1SVXBJ
      Y1hoTk1EQjFRalpwTWxCRWVURUtZbmh0TkRVemNsZERZM0E1VXl0bWJrNW5NRzU0VWpkemJqUmxR
      VEZhT1RKRFowOUJjRmxzZWpaTVlsaFlRMFZ4VWs0eGFIUmxUMlZGTTA1S1kxZEJhQXBpZG5ka0sy
      cDBkMVoxTURsWGVFOTBRMVl2TVFvOVUwOTJUQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-89069-9
    - DISA-STIG-RHEL-09-611080
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(d)
    - NIST-800-53-IA-5(f)
    - accounts_password_set_min_life_existing
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Collect users with not correct minimum time period between password changes
      command: |
        awk -F':' '(/^[^:]+:[^!*]/ && ($4 < {{ var_accounts_minimum_age_login_defs }} || $4 == "")) {print $1}' /etc/shadow
      register: user_names

    - name: Change the minimum time period between password changes
      command: |
        chage -m {{ var_accounts_minimum_age_login_defs }} {{ item }}
      with_items: '{{ user_names.stdout_lines }}'
      when: user_names.stdout_lines | length > 0


# Set Deny For Failed Password Attempts
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Lock Accounts After Failed Password Attempts
  hosts: all
  become: true
  vars:
    var_accounts_passwords_pam_faillock_deny: '5'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      MVJORkF2TTA1YWJrVXlhRkZHVHpGT2RFRXZTMDVyU3poVmRtOEtNVkJDUTBwVVRGVnVSRlZrVkVs
      Sk4zVjFjMHhITUVwSVRXTjVNWEJyWTFCUE0xRkZZa3BHVlRaME4wMHhlalp4Y1ZCblIycFdVVkJv
      UjI1aE9VZzFTd281WkV0cldXUmpVSFpOVjJsQlMwaHRWV3hsZFZKb2NXSXpNMWgxVnk5aFdFeFZW
      RzF4WWxWTGMwVTRiRlpaZWxSUE1IYzBObkJaTXpsQ1QxVlRkbUp6Q2psRVNGVnhWbnBWYm05c1Ru
      WXpNQ3RwTW10aFRYZzNjMVkwV1dWR2VFRk9TWEpPYTNkVGVrWTRkelZFT1ZsVVFtcE1NbkpaVW5K
      NGJHWnBVVkE0TmxJS01EUmpZamcwZHprMlZXbDJWMHRvWWxReE1rTTVOVEZsVTJ4ME5FeHBkVVZy
      Wm5aNFIzSTVPRE5rV2t0dE4xUnFMMmRPYWxJMFdFZEljbloxUWxsb2FRcEhha2hpTVZsTFQyaE1k
      M2xtZW5oMk9WTm1ZMGsyVHpCb2NHTTFXakZzU0U0NFYyMTFTVWw1UkdoM2RVcFhXa05yZVZoVlky
      cDFXV2hsYTFZNFpVMDBDbUprU1VkTldEVlFkR054TTA5TWMzbEthbXRhTVhaTWRsTTNjblZoVmtS
      WGVWbFZTSFZNZUd0QmRGQmljR2RyY1VkNmJXWmtUVlkwUW1WcFdWWnJZemdLZG5oVFpuWnZhQ3RR
      T0U5c1YzQjJNelUwYVdVelFUTkdPV1JIUTFGa1RFZEZiVFZpUTNGeFMzWkZlblJFYVM4d2JVZE5L
      MHB4YzJRd1JqTlZNV1p3VkFwd1Z6UnlRVEJMU1ZGM1FYVjFXRzlZT1ZCSVdUbGxPRFo2Wm5aaVlY
      QlNObTFITkVaaVRFMVBiaXRwSzBacFFtOXVibmcyY2pVMVZIQm5SV2RhU0V0U0NreFBaelkyWW1Z
      MVUxaEJUMWMzWmxKVmMzWXpTRVZtTDIwM01uWmhUek5FZG1aM2IxRlRjVXhLVlZwUlVVZ3ZORmRr
      UVZZeFdIVm5ibE5JZDBac1Nqa0tPRm95Um1ocE1qSkRiMFZ0VVVwT1ZHVTVRMHRDTmtWd1pIWmFU
      VE5LZVZCSmFHZE9XRXNyWmsxbVJYUnZUbEpQU2psaWNIbDNMemhxTlVaVU0zZE1lZ295TDNJMk4y
      WnNMMjAwYlVwQ2NWZ3hhRkpDYlFvOVdFaFRUd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83587-6
    - CJIS-5.5.3
    - DISA-STIG-RHEL-09-411075
    - NIST-800-171-3.1.8
    - NIST-800-53-AC-7(a)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-8.1.6
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.4
    - accounts_passwords_pam_faillock_deny
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Lock Accounts After Failed Password Attempts - Check if system relies on authselect tool
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"pam" in ansible_facts.packages'

    - name: Lock Accounts After Failed Password Attempts - Remediation where authselect tool is present
      block:

        - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Lock Accounts After Failed Password Attempts - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Lock Accounts After Failed Password Attempts - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Lock Accounts After Failed Password Attempts - Ensure "with-faillock" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature with-faillock
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-faillock")

        - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: Lock Accounts After Failed Password Attempts - Remediation where authselect tool is not present
      block:

        - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so is already enabled
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail)
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_is_enabled

        - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so preauth editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so preauth
            insertbefore: ^auth.*sufficient.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so authfail editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so authfail
            insertbefore: ^auth.*required.*pam_deny\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so account section editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: account     required      pam_faillock.so
            insertbefore: ^account.*required.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_authselect_present.stat.exists

    - name: Lock Accounts After Failed Password Attempts - Check the presence of /etc/security/faillock.conf file
      ansible.builtin.stat:
        path: /etc/security/faillock.conf
      register: result_faillock_conf_check
      when: '"pam" in ansible_facts.packages'

    - name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so deny parameter in /etc/security/faillock.conf
      ansible.builtin.lineinfile:
        path: /etc/security/faillock.conf
        regexp: ^\s*deny\s*=
        line: deny = {{ var_accounts_passwords_pam_faillock_deny }}
        state: present
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so deny parameter not in PAM files
      block:

        - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/system-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/system-auth
          register: result_pam_file_present

        - name: Lock Accounts After Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Lock Accounts After Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/system-auth

            - name: Lock Accounts After Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Lock Accounts After Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Lock Accounts After Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Lock Accounts After Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Lock Accounts After Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Lock Accounts After Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Lock Accounts After Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Lock Accounts After Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Lock Accounts After Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Lock Accounts After Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Lock Accounts After Failed Password Attempts - Ensure the "deny" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\bdeny\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists

        - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/password-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/password-auth
          register: result_pam_file_present

        - name: Lock Accounts After Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Lock Accounts After Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/password-auth

            - name: Lock Accounts After Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Lock Accounts After Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Lock Accounts After Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Lock Accounts After Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Lock Accounts After Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Lock Accounts After Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Lock Accounts After Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Lock Accounts After Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Lock Accounts After Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Lock Accounts After Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Lock Accounts After Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Lock Accounts After Failed Password Attempts - Ensure the "deny" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\bdeny\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so deny parameter in PAM files
      block:

        - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so deny parameter is already enabled in pam files
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail).*deny
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_deny_parameter_is_present

        - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so preauth deny parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)
            line: \1required\3 deny={{ var_accounts_passwords_pam_faillock_deny }}
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_deny_parameter_is_present.found == 0

        - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so authfail deny parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)
            line: \1required\3 deny={{ var_accounts_passwords_pam_faillock_deny }}
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_deny_parameter_is_present.found == 0

        - name: Lock Accounts After Failed Password Attempts - Ensure the desired value for pam_faillock.so preauth deny parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)(deny)=[0-9]+(.*)
            line: \1required\3\4={{ var_accounts_passwords_pam_faillock_deny }}\5
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_deny_parameter_is_present.found > 0

        - name: Lock Accounts After Failed Password Attempts - Ensure the desired value for pam_faillock.so authfail deny parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)(deny)=[0-9]+(.*)
            line: \1required\3\4={{ var_accounts_passwords_pam_faillock_deny }}\5
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_deny_parameter_is_present.found > 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_faillock_conf_check.stat.exists


# Configure the root Account for Failed Password Attempts
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny_root,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure the root Account for Failed Password Attempts
  hosts: all
  become: true
  tags:
    - CCE-83589-2
    - DISA-STIG-RHEL-09-411080
    - NIST-800-53-AC-7(b)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(c)
    - accounts_passwords_pam_faillock_deny_root
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      bHFaMUF2VW1OQ1IyazRjMk56WlRSc09UZzVVVkpOZUcweFlWVUtMek4wU0hKTlUwMW5XRzFIWjJS
      MVowaFpXa015WkcxUFZUTnZXRFJuZFZCb2JUQndZbHB6U0VKTk1XWlRLM1k0UXpFdk1sSTRWM0ps
      TldOT05ucEdjUXBhV0d3MllUaFNSR1pQTTB4NWRVMW5RV2xvTmtoRk5UWmhSbXRSVDBGeGIwVTRU
      eTkwZDNkVFNHcEhkRlozV0RVNGVuSXlja3h5WjB0emNXRnpiMk52Q214bWVqRlZlV3BtZUVvMVNG
      SnJSVkIyY1ZjM2NGcDNZemhhYWtWNk9UVkdkVk55YkZoV1psZ3piRUZGVWl0dlExa3ZhMll4VEc5
      cFJqQnljWHBWVTNjS1ZUZG1WMnM1Wm10bVRreDRWMmRpVFVSTFpUbE5aV1YzVm0xRWQxZ3ZVMHRI
      YVhKTVNFMDVabXR0V25WUmNFb3JlWGhJYlZGSmVVTXlUVGRNZDIxeFFRb3ZUbXBPUms1alVWSkZl
      R2N2ZGpnd2RUY3hURlJXV0U5b2VVUnlMM0JwVlZsVFFUZFRNVEZyYzJ0M1ZpOXhNRmRGYlhoRVVV
      WXhlRkpZVFRsUVNURnJDbkp6YkZaNVNYa3pjbEpVU2xVMFNWZG5UV0pIYUdkRFdURmtOM28wV0N0
      eU1uTTNaRGxVTWxoUmVGVkVhelp3ZUVwTVExTjJVVE5OWVZkNGR6Rm1hWFlLVVZCUmIzUnZWekJw
      TjBKb1ZUWXdUak55ZGpWUFlubHljVkJ0YUdObVF6RnFkbmxLWkRkYWMyZE5Vak5sVDNKWVMwbGtS
      RXhpWlV3NWJqWkxWbUZSWWdwemJtUldiazlUTTJ3MFpWUXplR1EwZURsc1pWVTFXVWRsUjJ0RlpY
      ZzBhME16ZDAxNWQyMVRRMDkwYzI5MWNIRnliamt6WlVoUGJ6UTBTazlNSzFobUNqUkZWREJ2UTFo
      MGFIRm1NbWRwTmk5NVQzUlNaR0l6VHpCM1ZrTkhibkJhYlhCbVpHUkljV3RXYkZOS1puRTJiME5V
      Vldaa1RHMTVVMnBTWmxsWlUwNEtaRTVyY1RrMk5FUjJTakV6YnpscU1XMVRNRUZXWWpBclJGVkxk
      bll2YTBWWU5GVlVjRWRUSzNRNU1IRmliMG93VDFwbFpIaENWa2RtTDNGbFREVmxOUXAwZWk5MWJG
      TTRNbVZtTnpSVlZWTktWbVU0T0FvOWJVNHpTQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure the root Account for Failed Password Attempts - Check if system relies on authselect tool
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"pam" in ansible_facts.packages'

    - name: Configure the root Account for Failed Password Attempts - Remediation where authselect tool is present
      block:

        - name: Configure the root Account for Failed Password Attempts - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Configure the root Account for Failed Password Attempts - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Configure the root Account for Failed Password Attempts - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Configure the root Account for Failed Password Attempts - Ensure "with-faillock" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature with-faillock
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-faillock")

        - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: Configure the root Account for Failed Password Attempts - Remediation where authselect tool is not present
      block:

        - name: Configure the root Account for Failed Password Attempts - Check if pam_faillock.so is already enabled
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail)
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_is_enabled

        - name: Configure the root Account for Failed Password Attempts - Enable pam_faillock.so preauth editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so preauth
            insertbefore: ^auth.*sufficient.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the root Account for Failed Password Attempts - Enable pam_faillock.so authfail editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so authfail
            insertbefore: ^auth.*required.*pam_deny\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Configure the root Account for Failed Password Attempts - Enable pam_faillock.so account section editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: account     required      pam_faillock.so
            insertbefore: ^account.*required.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_authselect_present.stat.exists

    - name: Configure the root Account for Failed Password Attempts - Check the presence of /etc/security/faillock.conf file
      ansible.builtin.stat:
        path: /etc/security/faillock.conf
      register: result_faillock_conf_check
      when: '"pam" in ansible_facts.packages'

    - name: Configure the root Account for Failed Password Attempts - Ensure the pam_faillock.so even_deny_root parameter in /etc/security/faillock.conf
      ansible.builtin.lineinfile:
        path: /etc/security/faillock.conf
        regexp: ^\s*even_deny_root
        line: even_deny_root
        state: present
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Configure the root Account for Failed Password Attempts - Ensure the pam_faillock.so even_deny_root parameter not in PAM files
      block:

        - name: Configure the root Account for Failed Password Attempts - Check if /etc/pam.d/system-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/system-auth
          register: result_pam_file_present

        - name: Configure the root Account for Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Configure the root Account for Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/system-auth

            - name: Configure the root Account for Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Configure the root Account for Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Configure the root Account for Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Configure the root Account for Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Configure the root Account for Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Configure the root Account for Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Configure the root Account for Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Configure the root Account for Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Configure the root Account for Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Configure the root Account for Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Configure the root Account for Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Configure the root Account for Failed Password Attempts - Ensure the "even_deny_root" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\beven_deny_root\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists

        - name: Configure the root Account for Failed Password Attempts - Check if /etc/pam.d/password-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/password-auth
          register: result_pam_file_present

        - name: Configure the root Account for Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Configure the root Account for Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/password-auth

            - name: Configure the root Account for Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Configure the root Account for Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Configure the root Account for Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Configure the root Account for Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Configure the root Account for Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Configure the root Account for Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Configure the root Account for Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Configure the root Account for Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Configure the root Account for Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Configure the root Account for Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Configure the root Account for Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Configure the root Account for Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Configure the root Account for Failed Password Attempts - Ensure the "even_deny_root" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\beven_deny_root\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Configure the root Account for Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Configure the root Account for Failed Password Attempts - Ensure the pam_faillock.so even_deny_root parameter in PAM files
      block:

        - name: Configure the root Account for Failed Password Attempts - Check if pam_faillock.so even_deny_root parameter is already enabled in pam files
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail).*even_deny_root
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_even_deny_root_parameter_is_present

        - name: Configure the root Account for Failed Password Attempts - Ensure the inclusion of pam_faillock.so preauth even_deny_root parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)
            line: \1required\3 even_deny_root
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_even_deny_root_parameter_is_present.found == 0

        - name: Configure the root Account for Failed Password Attempts - Ensure the inclusion of pam_faillock.so authfail even_deny_root parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)
            line: \1required\3 even_deny_root
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_even_deny_root_parameter_is_present.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_faillock_conf_check.stat.exists


# Set Lockout Time For Failed Password Attempts
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Lockout Time for Failed Password Attempts
  hosts: all
  become: true
  vars:
    var_accounts_passwords_pam_faillock_unlock_time: '900'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SmtiMUF2YVdoeFRUaFFUbGwxVkRsc1N6UmlkMUpwTWxrcmFsWUtWWEppVWpsTFYwazRUM3BMZGk5
      eVUzSnpabFpDU0hCbFkxbHJORVkzYVdvMUt6UkxjbXQyVWpVcllVRjFTRFZ4T0VWbGRYcHhNMnBO
      ZFZjNFRsSXlOQXBtWmpSQlFYaHJUMEpyWVRCQ2JWTjJWRGh1ZGs0ek56ZENaVGg2ZDIxamJIRk5O
      Rll4TkdjcmRtUlRjRFppUWxOTWNrNTFVblIwV25CU01sSkpjVVJzQ2s1alQyeExiRTU2V0c1Nk1U
      UjVTMk5wYVhOa2N6WnFSR0ZsYjJNM05FbG5WakYyTldkWmRrTkJla05HYm1kbEwzSklORGhtTVdW
      UGVFcHdRWGxtWlhRS1YxZG1XVWRWT0V0cWNFTlhkamhoUlZwWk5sRkRVRFpyVVRKVWRtSnVWM2xU
      WTNsVWRGaFNRbEF3WW1NMmVWQm9WM2czT0VGTGNFZE5SMk52VjJvcmRBcDRTRU5NWjNWaGFFdE1j
      VlpTZVVWcksxaEVWVVJwVG01SFUwMWlZMDR5VG1KMk5scDJVMDVFWmxkSmFWaFNURnBTTDBjMmNq
      RTNRbEpvWVd4RkwwbGxDbmRPVUVOb1dWcE5Zbms1YldWb2FsbHZjRzR3TjNSU1dFVkNPWFZsVFU1
      NE0xZEZSM0l4Y0VZMGVFNWliVkJFZUM5MGIyaG5ha0YzTW1oWU5ESnNaRXdLVHk5a2FXY3hXbkpK
      TWpWdFVpdHJhbGhCVDFOaVdtYzVSVGd3VkVKM2FGQXlhRk15YzNCMlREUkVSV05pYlhoMFpXWTRR
      VUpsWnpoSlZuQTBZeXN2YkFvMFZXZFFSMUE1VEZKTGRHdHVVV2t6V0hsU2VVZEZZVUYxU25aeFJW
      WjJhVWgwUjFCNFVGTTVjWEJTVXpkb2VWaFZRekF5YUdKdmJuVkxObmh3YzJVM0NpdFhhRkZwTTBw
      TlN6QTNRVEZ5UzBOQ05IUlBSa0VyVUZsWlYzRXJZVkpCY21WWGRFVjNiRXBHWTJGTk1tSkJOMng0
      VUdOWFRYTlVaVU5DVldSUlRHVUtSVFJEZUVOT01GUllUa3BOUlhoS1UxcFBVVWRpTVZkbVpFRjBX
      RTg0WjIxcVdHWjNLemh1V21sSWJ6UjFlalJEV2tWbE5rUk9PVnBZWTFkUk1DdDJVQXBDZWtOd01V
      SnNNa3RaY0VrMVNtOVdPVWxtUmdvOUwweEJNd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83588-4
    - CJIS-5.5.3
    - DISA-STIG-RHEL-09-411090
    - NIST-800-171-3.1.8
    - NIST-800-53-AC-7(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-8.1.7
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.4
    - accounts_passwords_pam_faillock_unlock_time
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Lockout Time for Failed Password Attempts - Check if system relies on authselect tool
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"pam" in ansible_facts.packages'

    - name: Set Lockout Time for Failed Password Attempts - Remediation where authselect tool is present
      block:

        - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Set Lockout Time for Failed Password Attempts - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Set Lockout Time for Failed Password Attempts - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Set Lockout Time for Failed Password Attempts - Ensure "with-faillock" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature with-faillock
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("with-faillock")

        - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"pam" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: Set Lockout Time for Failed Password Attempts - Remediation where authselect tool is not present
      block:

        - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so is already enabled
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail)
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_is_enabled

        - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so preauth editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so preauth
            insertbefore: ^auth.*sufficient.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so authfail editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: auth        required      pam_faillock.so authfail
            insertbefore: ^auth.*required.*pam_deny\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0

        - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so account section editing PAM files
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            line: account     required      pam_faillock.so
            insertbefore: ^account.*required.*pam_unix\.so.*
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_is_enabled.found == 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_authselect_present.stat.exists

    - name: Set Lockout Time for Failed Password Attempts - Check the presence of /etc/security/faillock.conf file
      ansible.builtin.stat:
        path: /etc/security/faillock.conf
      register: result_faillock_conf_check
      when: '"pam" in ansible_facts.packages'

    - name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so unlock_time parameter in /etc/security/faillock.conf
      ansible.builtin.lineinfile:
        path: /etc/security/faillock.conf
        regexp: ^\s*unlock_time\s*=
        line: unlock_time = {{ var_accounts_passwords_pam_faillock_unlock_time }}
        state: present
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so unlock_time parameter not in PAM files
      block:

        - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/system-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/system-auth
          register: result_pam_file_present

        - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/system-auth

            - name: Set Lockout Time for Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Set Lockout Time for Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Set Lockout Time for Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Set Lockout Time for Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Set Lockout Time for Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Set Lockout Time for Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Set Lockout Time for Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Set Lockout Time for Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Set Lockout Time for Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Set Lockout Time for Failed Password Attempts - Ensure the "unlock_time" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\bunlock_time\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists

        - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/password-auth file is present
          ansible.builtin.stat:
            path: /etc/pam.d/password-auth
          register: result_pam_file_present

        - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation for the system
          block:

            - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to be edited as a local fact
              ansible.builtin.set_fact:
                pam_file_path: /etc/pam.d/password-auth

            - name: Set Lockout Time for Failed Password Attempts - Check if system relies on authselect tool
              ansible.builtin.stat:
                path: /usr/bin/authselect
              register: result_authselect_present

            - name: Set Lockout Time for Failed Password Attempts - Ensure authselect custom profile is used if authselect is present
              block:

                - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect current profile
                  ansible.builtin.command:
                    cmd: authselect check
                  register: result_authselect_check_cmd
                  changed_when: false
                  failed_when: false

                - name: Set Lockout Time for Failed Password Attempts - Informative message based on the authselect integrity check result
                  ansible.builtin.assert:
                    that:
                      - result_authselect_check_cmd.rc == 0
                    fail_msg:
                      - authselect integrity check failed. Remediation aborted!
                      - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
                      - It is not recommended to manually edit the PAM files when authselect tool is available.
                      - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
                    success_msg:
                      - authselect integrity check passed

                - name: Set Lockout Time for Failed Password Attempts - Get authselect current profile
                  ansible.builtin.shell:
                    cmd: authselect current -r | awk '{ print $1 }'
                  register: result_authselect_profile
                  changed_when: false
                  when:
                    - result_authselect_check_cmd is success

                - name: Set Lockout Time for Failed Password Attempts - Define the current authselect profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: '{{ result_authselect_profile.stdout }}'
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Define the new authselect custom profile as a local fact
                  ansible.builtin.set_fact:
                    authselect_current_profile: '{{ result_authselect_profile.stdout }}'
                    authselect_custom_profile: custom/hardening
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_profile.stdout is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Get authselect current features to also enable them in the custom profile
                  ansible.builtin.shell:
                    cmd: authselect current | tail -n+3 | awk '{ print $2 }'
                  register: result_authselect_features
                  changed_when: false
                  when:
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Check if any custom profile with the same name was already created
                  ansible.builtin.stat:
                    path: /etc/authselect/{{ authselect_custom_profile }}
                  register: result_authselect_custom_profile_present
                  changed_when: false
                  when:
                    - authselect_current_profile is not match("custom/")

                - name: Set Lockout Time for Failed Password Attempts - Create an authselect custom profile based on the current profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b {{ authselect_current_profile }}
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is not match("^(custom/|local)")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Set Lockout Time for Failed Password Attempts - Create an authselect custom profile based on sssd profile
                  ansible.builtin.command:
                    cmd: authselect create-profile hardening -b sssd
                  when:
                    - result_authselect_check_cmd is success
                    - authselect_current_profile is match("local")
                    - not result_authselect_custom_profile_present.stat.exists

                - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=before-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect custom profile is selected
                  ansible.builtin.command:
                    cmd: authselect select {{ authselect_custom_profile }}
                  register: result_pam_authselect_select_profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - authselect_current_profile is not match("custom/")
                    - authselect_custom_profile is not match(authselect_current_profile)

                - name: Set Lockout Time for Failed Password Attempts - Restore the authselect features in the custom profile
                  ansible.builtin.command:
                    cmd: authselect enable-feature {{ item }}
                  loop: '{{ result_authselect_features.stdout_lines }}'
                  register: result_pam_authselect_restore_features
                  when:
                    - result_authselect_profile is not skipped
                    - result_authselect_features is not skipped
                    - result_pam_authselect_select_profile is not skipped

                - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
                  ansible.builtin.command:
                    cmd: authselect apply-changes -b --backup=after-hardening-custom-profile
                  when:
                    - result_authselect_check_cmd is success
                    - result_authselect_profile is not skipped
                    - result_pam_authselect_restore_features is not skipped

                - name: Set Lockout Time for Failed Password Attempts - Change the PAM file to be edited according to the custom authselect profile
                  ansible.builtin.set_fact:
                    pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path | basename }}
              when:
                - result_authselect_present.stat.exists

            - name: Set Lockout Time for Failed Password Attempts - Define a fact for control already filtered in case filters are used
              ansible.builtin.set_fact:
                pam_module_control: ''

            - name: Set Lockout Time for Failed Password Attempts - Ensure the "unlock_time" option from "pam_faillock.so" is not present in {{ pam_file_path }}
              ansible.builtin.replace:
                dest: '{{ pam_file_path }}'
                regexp: (.*auth.*pam_faillock.so.*)\bunlock_time\b=?[0-9a-zA-Z]*(.*)
                replace: \1\2
              register: result_pam_option_removal

            - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes are applied
              ansible.builtin.command:
                cmd: authselect apply-changes -b
              when:
                - result_authselect_present.stat.exists
                - result_pam_option_removal is changed
          when:
            - result_pam_file_present.stat.exists
      when:
        - '"pam" in ansible_facts.packages'
        - result_faillock_conf_check.stat.exists

    - name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so unlock_time parameter in PAM files
      block:

        - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so unlock_time parameter is already enabled in pam files
          ansible.builtin.lineinfile:
            path: /etc/pam.d/system-auth
            regexp: .*auth.*pam_faillock\.so (preauth|authfail).*unlock_time
            state: absent
          check_mode: true
          changed_when: false
          register: result_pam_faillock_unlock_time_parameter_is_present

        - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of pam_faillock.so preauth unlock_time parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)
            line: \1required\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_unlock_time_parameter_is_present.found == 0

        - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of pam_faillock.so authfail unlock_time parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)
            line: \1required\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_unlock_time_parameter_is_present.found == 0

        - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value for pam_faillock.so preauth unlock_time parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so preauth.*)(unlock_time)=[0-9]+(.*)
            line: \1required\3\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\5
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_unlock_time_parameter_is_present.found > 0

        - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value for pam_faillock.so authfail unlock_time parameter in auth section
          ansible.builtin.lineinfile:
            path: '{{ item }}'
            backrefs: true
            regexp: (^\s*auth\s+)([\w\[].*\b)(\s+pam_faillock.so authfail.*)(unlock_time)=[0-9]+(.*)
            line: \1required\3\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\5
            state: present
          loop:
            - /etc/pam.d/system-auth
            - /etc/pam.d/password-auth
          when:
            - result_pam_faillock_unlock_time_parameter_is_present.found > 0
      when:
        - '"pam" in ansible_facts.packages'
        - not result_faillock_conf_check.stat.exists


# Set Interactive Session Timeout
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_tmout,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Interactive Session Timeout
  hosts: all
  become: true
  vars:
    var_accounts_tmout: '900'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      QTVUVkFyZDJOeVoxUmpSblIwY1RkM2FWaGhORUZ1WkVwSmJtMEtMelZhV1N0RVFYbFBVRXBPUVdw
      bVFrUTBZVlZsUVRBM2IzWXJiVUpHVHpWSGVFSkdkM0ZoWkN0S2IwdGFlazQ1VjBOT2VIRXdXRTFF
      Wms0dlVtOXRRUW9yTVZCU1RrdHpNREZwUWs5ak5VeExPRzlwUWxweGNUQnBXRlYxVWtwcllsUktX
      VUV6Y0RkVVJXUmFhbWt2T1hCU1lVSjBhRmQ1V1hWalVFczRZVXB0Q2tvMk1tZEJTRWh2WkVsMVMz
      RlJWV1JDSzBST1VrZHNTRmxLWmxaa1FrTk1UM1pQTlZka2JuVlZRVFJpZGpOaFVYUjNUblp4Tm5O
      TlZEVm1WalV4T0RZS2RFRm1aVGh4VFRaeFYxaEJVMGxYYVdwaGNYZE5aMlpIVlVSTU9WWkdjbXQx
      TVUxUU5FTXdNamxVZUdvclpYZHhPVXRCYnpWcGFUZHNXVlZ6T0Zaa1l3bzRja3BxV1dJeGVUZDFN
      MHM0WlhSUFNUTklUR3RFTTFKemRqTlNVVTVLWm1sNE5uQkNLMHhhTldncloxVlROWGhqUW01elRW
      a3ZOVXcyV25vNGRFWTVDbEYyWTFwNkszaGpiMDF2TjBVM1VIZDNRVmRFVXpaNmQwUnphVFZxZDBO
      U1pDdE1NVGhyVFhZeEszZHFkMVkyTjB4M1FVSm1lV295ZVdWS2JtMHdVMFFLU0dORVZXSTNlVWRz
      T1VVd2RGbHlNMVp4ZG5oRlQxbEdZMEZyU0dwMWJHZFNkbU5IUm1aeVNDc3pWM2xMUlV4a1RtZGxL
      MlY1TmxVM2NFWlZjbGRyV2dwNWFqTTRkMFZCVkd4MFFscGtjME5FTUZkdVYwdzVhbGt5Y2tRcldI
      Um5WSHBHVkVabUswWlpSSE5uZUVFcllWWjBWek5vZGpObFQwUm9iVXgzY2xGRENqQjJiWHBhUVUx
      RU5IVkRSRlpHTVV4emFuRnpjbVJvUzJwSlZHWmxhSEJRVWxONVRIQnRRa3BQVlU5dGIzWnFXVkpy
      UVU4M1oxcG9TM00wUkdScVkwUUtUVFpsYkU5cFNHTk9TMVV3VlhWeU5EUm9UamRPUW5SMGVHa3pj
      R1JYYW1KNFYyaFpSVXQyUWtwRFVYcHBiR2hIY1ZkRWJEZEZZV1U0VXk5c2VFSkllUXBIWm1sT2J6
      bEVVVlY2UzFaWFpTOXVhM1pqWmdvOWEyTkdhQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83633-8
    - DISA-STIG-RHEL-09-412035
    - NIST-800-171-3.1.11
    - NIST-800-53-AC-12
    - NIST-800-53-AC-2(5)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-10
    - PCI-DSSv4-8.6
    - PCI-DSSv4-8.6.1
    - accounts_tmout
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Correct any occurrence of TMOUT in /etc/profile
      replace:
        path: /etc/profile
        regexp: ^[^#].*TMOUT=.*
        replace: typeset -xr TMOUT={{ var_accounts_tmout }}
      register: profile_replaced
      when: '"kernel" in ansible_facts.packages'

    - name: Set Interactive Session Timeout
      lineinfile:
        path: /etc/profile.d/tmout.sh
        create: true
        regexp: TMOUT=
        line: typeset -xr TMOUT={{ var_accounts_tmout }}
        state: present
      when: '"kernel" in ansible_facts.packages'


# Ensure the Default Bash Umask is Set Correctly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_umask_etc_bashrc,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure the Default Bash Umask is Set Correctly
  hosts: all
  become: true
  vars:
    var_accounts_user_umask: '027'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      czVXVkF2YVRjemFHMVdRa2RYVmxFd1UxRmxReXRWUTFscVIya0tkVmQxYjAxVWJVWlRVRWw1Ymxk
      U1kxWlhTMjR2YjNKdWNFRnJUWGRZTmtnMGJGSldZM1ZyWjA5WE5URlBNWFJTVDBaWGVtMVBkSE1y
      VEZsWWRrRnpOd3BhSzJWbmRtdEtUemt5VkZkbVZISmpSSGxqVTJOeGVrRXJXbEJOVEhaamRtTjNO
      SEF5WjJWNWFWQjBSVVJ2WTFsRmExZERUazFtWWtSUFkwMHlLMWxZQ2pWQ1NtczFXWGxUV21neWNF
      aGpURE56UkU5emNEaDRSbVUzUmprMWQzZGFPVXBGYm1SeksyNDRZbWtyYzFwU2N6RmlVbnB1TUdZ
      dmVVUmtabTFYVUdRS1Z6VnVTa1ZhVkVWblNXaDZXbEl6ZFRGQldEUk5TM1pFVG1neE1taDJTMVo2
      Tmt0WGQwNUJjSHBhWjFoQ1dEQmpORFJCY0ZOUWNHOVBSbFpCVkRJdk1ncDBOMll5YzBJek9GbFBU
      VVJPWTJGdVRGZDViMHRIWlVFeUt6WXhTMEpWUWxGd1ZrazRjMDgyWkc5UWRGVXhMelU1UTBWNU9D
      OU5OWFpFUXpSSmVsTTJDbmRaZWtsRFNVWnFVV0puVlU5UGVHSllRMmQ0VVd3NFdYTXlLM3BvUW1J
      d1NqWkphbGsxZFhac2JGaElTbmRQYzJKRVZUazBlR3R6WXpOUE1GWkpRV1lLTDA5WFoyWXZPVzFP
      YUhKU1pqZDBTVlpxWTBsT2FWY3hRamRUTjAwdmNUSmxTbVkxTDJaTkszTlNMMDUxU1V0UGVXSlNj
      alI0Wm5Bdk0wazJVVkI1Y2dvd1JURlhjRGhxYkdSSVV6ZzBUVE5GTmpCeFMxVm5VbWR2VmxoU1ZF
      bzNaSGw2VFhSMmVWbDZWRFJFYzFWbk9YbFpOMjlrWlcxclRVUTRPR2xVTjJWTENtSjBVRmMyZHpO
      Qk9HZFBjelp1VjA1RWVtbDRaV3hpWlU5d015OWpWVGRXTjB4MGVHcDFOa1JFWm5OUlFXaG1NbTFs
      Y2xnMVVXZEhlV00wTVd0MGVEY0tVVEkyWkZvdlpHSkhSVFpUYkhOWFdHVnBNMDFSUjBKb1dFRmtO
      VlpUTUdRdmRqbGhXVTlOVjNKUmVUZFBTR1VyTDNsSlkyUTRkVlJ3VDJwMEszbHlkd3BQYUhoQ00x
      QjRhSGh1VTNoMVYyMXlPWFJzZEFvOVUwcEZUd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83644-5
    - DISA-STIG-RHEL-09-412055
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - accounts_umask_etc_bashrc
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Check if umask in /etc/bashrc is already set
      ansible.builtin.lineinfile:
        path: /etc/bashrc
        regexp: ^[^#]*\bumask\s+\d+$
        state: absent
      check_mode: true
      changed_when: false
      register: umask_replace
      when: '"bash" in ansible_facts.packages'

    - name: Replace user umask in /etc/bashrc
      ansible.builtin.replace:
        path: /etc/bashrc
        regexp: ^([^#]*\b)umask\s+\d+$
        replace: \g<1>umask {{ var_accounts_user_umask }}
      when:
        - '"bash" in ansible_facts.packages'
        - umask_replace.found > 0

    - name: Ensure the Default umask is Appended Correctly
      ansible.builtin.lineinfile:
        create: true
        path: /etc/bashrc
        line: umask {{ var_accounts_user_umask }}
      when:
        - '"bash" in ansible_facts.packages'
        - umask_replace.found == 0


# Ensure the Default Umask is Set Correctly in login.defs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure the Default Umask is Set Correctly in login.defs
  hosts: all
  become: true
  vars:
    var_accounts_user_umask: '027'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVTVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      VlJjMUZCUzBwelpHZHpaVGc1WnpSMlZXczBOMlZ3TlVGYWFuVUtXbFo1VDNKTEsyNHphRlZhZDBo
      WlpGTndiakIxVEdWU05rTnFSMnhHWm14VlMwNUdWM1ZaS3pWRmMyTlNPREEwVm1GWmF5OW5SMjVL
      YmtJNGIyOUZVd3BoZFhkdlpHdDNMMHhyZFd4VGNXSTBialkyTTFkdE9UVkNUalpOZEhveksxQkhT
      VlUzZFZaclVUWkJjWFp3VEdoNmRXOUVlSE4wTjJGalFYRjVWVnAxQ2t0TlVHeG1jbFo2Y1VwSVRG
      ZDJibFJuY1hOUFowc3pVSEJZY0dreVNtaFlaR3h1ZWl0bWRXUmhVa1kwWmtWQmVXcFZURWs0Y0dO
      QmVGVkhTMk42VVRRS01YaDZlazVXYlVzM01GRm9ZVGxKZFdad1RtNXZVMVk0UkZWTFR6QlFWa2My
      Tm1nNU1VaDRUMVkyY2pWU1dUZFRaVGRZTWxoUWJ6bGFUMVZ5UjJkTWRBcFZRV3A0SzBoSU1XbG9O
      ME5qU1ZwSlJscGlZa28xVVVKU2VHTnJMM1J6VTJacWJqaHVUSHBhVVZSYUsySTFMMkU0ZHpaSGIy
      RnRTRTFQTjJORVZ6ZzVDbHBRY0RSM1pEUkJUM3B2VnpOclVUQlFaVU5IY3pkd1JFWnFlV2xUZUhC
      c1NXWklibFkzYTJKQ2F6VlNkMmROVEVKWk9FWkpiMGhvVlU5bFIzSnJWUzhLY1RSaVF6aEVhM1JI
      TlhSVmVIRnlkMVZVTjA0M0t6VXJhRlZYVEZkTGRqUnJZbmhFYTFjelpHVXJkMnh5YVcxWlVpdE9O
      SFJSVGtSNmJHcFZZVTVuVEFwd1prdDNOamMwWm5reldpOUlabEoxSzA1VFRHbEJSM1JoUnpkVmJI
      TnBMMFYzYVRaQmNFVkVSVmRFWkVseFZHNURjVWNyZGpFMFdqVlNabkl6VUdSTkNrczBlbEZ1UXps
      SFYyeDBPSGcxWkRJck9VTTNXVlphSzJkSFNsbGhhbGRPYjNBeGQwZHliRFEyVFhaaVJsUTNTV1ZN
      TUc1bk1GRXhZa2hpU1ZkUFRXb0tibE4xWmpkek1VdGFiVFpITWk5a2RFczRTMXBaVGtoNVJEY3JM
      MFV3Vmk5RlRWY3phRTB6TkRCa1FWa3JVazE0VTJSTVQyOVdPR2xzYUdGV2FqVkllQW8wY0U1QmFr
      RnVUVzUzV0ZCMlZGbHFkMlppU1FvOWVuSnZZZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83647-8
    - DISA-STIG-RHEL-09-412065
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - accounts_umask_etc_login_defs
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Check if UMASK is already set
      ansible.builtin.lineinfile:
        path: /etc/login.defs
        regexp: ^(\s*)UMASK\s+.*
        state: absent
      check_mode: true
      changed_when: false
      register: result_umask_is_set
      when: '"shadow-utils" in ansible_facts.packages'

    - name: Replace user UMASK in /etc/login.defs
      ansible.builtin.replace:
        path: /etc/login.defs
        regexp: ^(\s*)UMASK(\s+).*
        replace: \g<1>UMASK\g<2>{{ var_accounts_user_umask }}
      when:
        - '"shadow-utils" in ansible_facts.packages'
        - result_umask_is_set.found > 0

    - name: Ensure the Default UMASK is Appended Correctly
      ansible.builtin.lineinfile:
        create: true
        path: /etc/login.defs
        line: UMASK {{ var_accounts_user_umask }}
      when:
        - '"shadow-utils" in ansible_facts.packages'
        - result_umask_is_set.found == 0


# Ensure the Default Umask is Set Correctly in /etc/profile
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_umask_etc_profile,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure the Default Umask is Set Correctly in /etc/profile
  hosts: all
  become: true
  vars:
    var_accounts_user_umask: '027'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      TlZVVkF2TTNvMFpqTklhM0U1Wm5remJFSkdkMmc1Y2t0UFYyRUthemRLVURSUk4yZDRVR3BVZGxF
      NWJXcFBaVFpHY2tndlZteEpRVU4yY0ZaeVVXczROV3RaVXpac1JGWmpTRlJaY0ZaMllVbEZORVZw
      WWk5dGRtUlhWUW92TlZwTFVsZEtkV3M0Wm05dFlqUlhUWGRaTW1OaGVVeGxSMnhGV2paV1NYQktM
      MWR1VGsxV2FVWjNRM1JKUzBoUlQwTTRiakJNY0RaU01qbEhiMGsxQ21ObGVrdG5PWEkzZVd3eE9X
      TmtObEZFTUhwVVNFMVdLMHBIYTA0ckswbGtSbXBhVFhwelNUTllaSGxwYzFOaFprZDNWVVZ3UW5G
      dVdrMXRjVE5GV2xvS1JreExWR2xoYlhkSFpHZGhObGhaUWpCb1UxUXJXRWMxZW1JNVNHNDBNMlYx
      WlRoR2MzQlVWMHhHUW5jeGVrRm5lRTgwVTFnMWRtMVRaRVk1VHpsVVVBcFRWMFZOU0hOT05HVlJO
      VFJ0WTNKb1ZsQjNabEpCVERBeFFVOWpaa2h6YUcxU2NFbGxhbFZNWms5VlQwcDZOMjVIU0daTmEz
      ZHFiVWR0UjJ3NGQyMWxDa2xETTJkVVMzVkVjM2RTZWxreE1uZExaRk00ZEVsNU16UlRTbEp4WTI1
      eE1XcDNUalphUVdRNGVtMUdURGRLVm5sWk1GVmlRa3RZUW1GeFp6Vm5NVkVLWlZoMlZUWnBRMGMw
      ZW10MFZXaElRVmhHUm05MU1qQktSWEZWUlVWSFdtMXZiakp4WkZkWFExazVNR1l3Tm1Kc1pYZzRk
      RlZYTVZGa04xVmpPVWcyVFFwNFJtUlBaVWxxYmpWQ2VqSnRibUZETlRKT1lTOXZZM05ITjNoRFR6
      VlNOSGRHZUdoUWFVdHlUMDFIYmtsRE5XcFFhV0pXYzNCSWJHZE1ZMmQzVmpoeUNuZFpSRlZ4YlRW
      M05UVTFSWE55TlZaaFkxaHVjbXhEU210amJrNDVOM0F3T1dKdVNIWlVTbmxNZVVoaWVFaExRekJs
      TVRGV2RHTldka1UwTTBzNVNIa0tSRkZKVUVGaUt6bGFMemhtU1RablYwZzNObHBVU0VnMFNXOWpN
      MUp5Y1daeFVISTJiVFkzVVV4MlZYWTBiMmcxZEVjM2RHNXhWRzFKY0VselIzbG1OUXB3VjBKbVpV
      NXJWbmgxUVhwM2FXRndkMDlLTUFvOWJYWllTQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-90828-5
    - DISA-STIG-RHEL-09-412070
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - accounts_umask_etc_profile
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Ensure the Default Umask is Set Correctly in /etc/profile - Locate Profile Configuration Files Where umask Is Defined
      ansible.builtin.find:
        paths:
          - /etc/profile.d
        patterns:
          - sh.local
          - '*.sh'
        contains: ^[\s]*umask\s+\d+
      register: result_profile_d_files

    - name: Ensure the Default Umask is Set Correctly in /etc/profile - Replace Existing umask Value in Files From /etc/profile.d
      ansible.builtin.replace:
        path: '{{ item.path }}'
        regexp: ^(\s*)umask\s+\d+
        replace: \1umask {{ var_accounts_user_umask }}
      loop: '{{ result_profile_d_files.files }}'
      register: result_umask_replaced_profile_d
      when: result_profile_d_files.matched

    - name: Ensure the Default Umask is Set Correctly in /etc/profile - Ensure umask Is Set in /etc/profile if Not Already Set Elsewhere
      ansible.builtin.lineinfile:
        create: true
        mode: 420
        path: /etc/profile
        line: umask {{ var_accounts_user_umask }}
      when: not result_profile_d_files.matched

    - name: Ensure the Default Umask is Set Correctly in /etc/profile - Ensure umask Value For All Existing umask Definition in /etc/profile
      ansible.builtin.replace:
        path: /etc/profile
        regexp: ^(\s*)umask\s+\d+
        replace: \1umask {{ var_accounts_user_umask }}
      register: result_umask_replaced_profile


# User Initialization Files Must Be Group-Owned By The Primary Group
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_accounts_user_dot_group_ownership,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: User Initialization Files Must Be Group-Owned By The Primary Group
  hosts: all
  become: true
  tags:
    - CCE-87037-8
    - accounts_user_dot_group_ownership
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      VlRhMUZCU1VKUmNrbFlTV0pESzFsV2NrdzFUVU51VEd0ck5WQUtOV1ZDVFhWWk4yZFdVSEpXUWpo
      dlJqaHBaREZ5YkdkNVUyOUhVR2hzTjBsMVV6SktlR0pLTTJ0Q1JFcHlTWEJNTmk4MldXZ3ZhaTlY
      ZFU4MU1VMVBXQXBhUWtaQ1JGcEVSSGhIY1Raek1ESkljV3RZWldwVGNERjJNWFZuZFRodlF6ZEdU
      akJMUWpKMVZsQnZPRFJ0VWtwWmRHd3lTaTl1VjBOdGQxTktSbU5DQ25wRmNVSllUVEZKUm5kTlQy
      Tm1UR1ZCWVdadVNISm5Oa3hpY1cxMFkwWlZaMUJwZUhGWE9VbEpSREZDUVdaaVkwb3hWRVpSYWxo
      TFJWTXZkM1ZCUmxBS1YyaFhZVzFJUVdNNWFubGFRbEJVVEdaS05qVm5VRFJVTUdaaU0xTTNiSEJG
      UkVZd05HUkJiMnhPYm1KWFUzZHRNWGd5YldkR0swRkVZazlEZHpWWFlncENOV0U0TURKQ2JFRjJU
      ek5KU0hWUFZsSmlSa2xKUm5GVk0zbG1kMmxMWlRsc1YyZG1jRGhvVkVscFlVbHJZblJFWTBKcVQy
      cEJhVXR2YTBSdlNVSmFDbWRRZDFWVVF6Wk1aRzg0ZUZwV1dubGhXR05ITW1sWWVYQnhiR28wTDBo
      NFRGRkVlbk41WjBwRmQwTnJiMlZUYjBOYWRHZDFSRWhwWkcxV2MxWTBSa29LYjI5UVpHRkhPVlpW
      TnpGeFQwdHdWSFpCUzJWTEsyRlJWek1yVlU1c1RuTldlR3R6VjBOU1kxbzRiV0YxTm14NE4xQm1j
      MHQyWmpVNVZDczRlVVJhVUFwWlRXMDBjR2RsWVN0SU1FeDRSRE00ZUhaS2JVSkNUVGt4SzJ4RFpI
      TjFlVXBNYlRWelRGSlRkbWRaZWpSalVYcHhRbTVKTjIxRE1VSTNja0l4YVVodkNtdGxjbGRzSzFs
      VVVtZExaakE1WjJGQ2JFeEhWakUwVW0xTGVrNTVORFpIWkZCc1VUWnBPR2Q0TVhjM1UwNWlOV1JJ
      THpneVRub3JaWGw0VGpCT2F6VUtjazgzVkhObVZuTkhSVGQ1TDJoaU5GcFRTRmQ1VWxRelRIcFJP
      WEpHWWpkSVFXMXFiSGxEWm5GT1Z6VnBUamhxTlcxNGNYRjFOVGszWW04NFpXTmpWd3ByWlU5UFVY
      cFlOaTlqWmpKR1JXMXpSRU5hUkFvOVNsYzFjd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Ensure interactive local users are the group-owners of their respective initialization files
      ansible.builtin.shell:
        cmd: 'awk -F: ''{if ($4 >= 1000 && $4 != 65534) print $4":"$6}'' /etc/passwd | while IFS=: read -r gid home; do find -P "$home" -maxdepth 1 -type f -name "\.[^.]*" -exec chgrp -f --no-dereference
          -- $gid "{}" \;; done'


# Build and Test AIDE Database
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_aide_build_database,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Build and Test AIDE Database
  hosts: all
  become: true
  tags:
    - CCE-83438-2
    - CJIS-5.10.1.3
    - DISA-STIG-RHEL-09-651010
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-11.5
    - PCI-DSSv4-11.5.2
    - aide_build_database
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      QXhSVkF2VW1KQ1NuUnVTbTV3VlVkNWVHbFlNRmNyVTNOeVIyUUtkRkV2T0dSTE9IbG1aMlJrZEVS
      U1R6aE9hMHB3TkRGblMwVlhZV05HTUhCRU5raDBNWEZJVVROdGVFcGFRMDFHUldwS1oyRkdXRTlZ
      WlVsek5EQXJSZ28wTmpjclQwWTBibFpZZWs0clRVdFNVa280UVRsRGJUUnVWRU5WVFhBMEwyOUJN
      VWRCYmk5VlJEUlFkV1JtU0ZCalZHNUpTbkpaZGpKNk1FaG5VbGxaQ25JMk1XbENXWHA0ZFZObVRG
      Um5kbUZRTUZGT05HOHdhWEYwYVRGbWNUQXdjVFZ5TkVsNFdrMVdRVzFrWTNKS2MwTndTVmxuYVZv
      eVkwSk9aRlZTZVdFS04waFVhak5RVVVkWWEyRktTV1JKT1UwemF6Tm9VV2xKYjBOdWFWTk5XRzVu
      WnpabVFYUk1OR1E0YVZKbldqVnNRVFJUSzBweGIwNDNhWHBwYlRBME9BbzVjekYxTURJeE5rTkZU
      WEkxUVdaNFdYZDBjV2hzVDI4MGRWWXpLMW96ZHl0c1ZVOTNOR05TVW5oeWN6TjVXV1p6Y201cmRF
      WkxRelkyV0RWbFdUVllDaXRIY1RkV1RGRXlVemN5UlRCQ2NqTmxaRTF2U1hVdlpVWlZLME5TWWt4
      RWJYWTNTREkzTTBGNFIwTXJURU5XVVdwdk5XNWFRMGxVY0VGTlEwUTJhSG9LS3pKT01XUm1ZMlUy
      VEVaQmRrcEphWEJsV0RodlJHbzJkemhwY0hwU1FVOWtVMXBrZEVKVll6ZFNjM0UxYUhod09GSXZi
      WE5EZG5KbmNuUnVSbWRUVkFvMFJVbENXVEpYUkRGUlozTlhOSFpCVERFMmJHRkpWR3R5YjIxV2JF
      dGplQ3N4VHpoSVNXSm1UbmhoY2pOS1R6Qm9MMnByUzFwV1pEUTNNRk5GYUcxUUNrZDBlWEpIY0ZK
      bGJUbEViVEp6Y2xnNE0yeHFkM1pQTjFWcVZXcE1ZamhYZUN0MVIzazBUamRZZWpKVFYxcEtiRU5Q
      WjBSYVRDOUNiRVpsTURKdlZWZ0tTakEzY3pNNVkxaEtZM04yWTB0UVVHd3lZWFpQYkVKSWFrdEph
      RFJRVTJjNWFHZEJiWHB1S3paUWFGUlhTVmcwVVdkb1lXdDBUV0lyWW5ZMlMzQmhTQXAzU2pGRE1r
      ZGtXWE5WZDJscWVITjNkMXBIY2dvOVpYWnNSZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Build and Test AIDE Database - Ensure AIDE Is Installed
      ansible.builtin.package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: '"kernel" in ansible_facts.packages'

    - name: Build and Test AIDE Database - Build and Test AIDE Database
      ansible.builtin.command: /usr/sbin/aide --init
      changed_when: true
      when: '"kernel" in ansible_facts.packages'

    - name: Build and Test AIDE Database - Check Whether the Stock AIDE Database Exists
      ansible.builtin.stat:
        path: /var/lib/aide/aide.db.new.gz
      register: aide_database_stat
      when: '"kernel" in ansible_facts.packages'

    - name: Build and Test AIDE Database - Stage AIDE Database
      ansible.builtin.copy:
        src: /var/lib/aide/aide.db.new.gz
        dest: /var/lib/aide/aide.db.gz
        backup: true
        remote_src: true
      when:
        - '"kernel" in ansible_facts.packages'
        - (aide_database_stat.stat.exists is defined and aide_database_stat.stat.exists)


# Configure AIDE to Verify the Audit Tools
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_aide_check_audit_tools,fix)
# Version: undefined
# platform = multi_platform_ol,multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure AIDE to Verify the Audit Tools
  hosts: all
  become: true
  tags:
    - CCE-87757-1
    - DISA-STIG-RHEL-09-651025
    - NIST-800-53-AU-9(3)
    - NIST-800-53-AU-9(3).1
    - aide_check_audit_tools
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEVXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      NUtTVkF2VW05elRGWlJWRTltVTJOM2VFMVlXV0p1YTJOU01TOEtVMHhtV210amFuTTRhamxLVW1W
      VFFVYzBkSGhEVnpGdVNHeHpaVXR2UkhkSFluUjJXRkpOTW1WME5FUjBSM0JCVEVwSVVGWkVVM0JE
      WmpOVlZsRkxid281UlVSTVFVdFBkRlF3Vm1KRFNEWkVkbEZPVW10V1NVeFFjSEJRZFc1UFozUlRl
      bTlFYUVSTmNUUjJUazVYZVVWa1JFWjVVVTB5T0ZWbmFtZGtTVFZaQ213eFVFRmlWVU14WWpCM1Yy
      ZElTVVIwTlVkQmIxUlZkWEV5VkhKT05FTnhjVmszTUdvM1VGZHdlWE01U2pabFEwSnNNMVV3TWtn
      dlJFbFZiRGhLUnpVS1l6QmhOV2xRZWxWWlUyTmlSbGhyVWxsQ2NTdHRNMEpzTkRCeVZGcHViRWhX
      YlRjMlpHeEhZa1ZxWTNoRmQxazFNR3R3U1VsYWJUbEtPVVp1VERsaWJnb3hTalp0VEdKeVVuSnBh
      VFJGYVZGVFN6aFFjbTQwWkdkaVkwd3JaWGcxWWtvd01reDRXbmhKYUUxbWJsTnhVRE52T1dKUVNs
      UnBaR2gyU1docVpFODNDa3N2VmpNck0yTlZZM1pxYWsxREwyRklWMlJoVFV0blFVMHJWblp3U2xC
      c05FOUJPSGxYUmxWVE5VVnJWRUUzU210R1RUbDRRMnM1Tld4NWFtUXlhM0VLTXpCWVlVTjZWbGQ1
      YWk5RVZqUnNaeXRxTHpOU1UxWkZjbnBDUkhoclZXUmxRMEZhYlZaSVIzbHdhMFpJVDJoTlpVZG9X
      REIwVlVoM2NHMDVhV2hsYkFweFJrMVFaVXBCVW1GeGJrUlJRbGhtWWpObU1XNXhhV3hzV1ZCUFpt
      aFhNakJpTms1RE9ITkhTbHBLSzJrelJXVmtia3hKZDFNdlEwUm9ORFV2WkRZekNqRlRSalV6YmxS
      cmNHUm1OemxUVUROa2FrcDZXVGhhZVROS0x6bFhTRGxCZURGMVkySkpLekYwYmpsM1RYb3JSQzky
      VjJKelQxaHhSWEU1VEcwM1Zua0tOblp4V0hGSFNqQllla1UzVFZoWFVWbG5LMVZvZDI1U2FXVkhh
      a3R0YjFNMFMwRTJkMUpaVkZsVmQxTnJlbGxDT0hST2MwVjJOVkJGWVRSd2VVcG5Sd3BPV1d0R2My
      UkRNSFZYZWtaQ1VrRkRURzFDUmdvOWJraDFOUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure AIDE to Verify the Audit Tools - Gather List of Packages
      ansible.builtin.package_facts:
        manager: auto
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure aide is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: '"kernel" in ansible_facts.packages'

    - name: Set audit_tools fact
      set_fact:
        audit_tools:
          - /usr/sbin/auditctl
          - /usr/sbin/auditd
          - /usr/sbin/augenrules
          - /usr/sbin/aureport
          - /usr/sbin/ausearch
          - /usr/sbin/autrace
          - /usr/sbin/rsyslogd
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure existing AIDE configuration for audit tools are correct
      lineinfile:
        path: /etc/aide.conf
        regexp: ^{{ item }}\s
        line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'
      with_items: '{{ audit_tools }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Configure AIDE to properly protect audit tools
      lineinfile:
        path: /etc/aide.conf
        line: '{{ item }} p+i+n+u+g+s+b+acl+xattrs+sha512'
      with_items: '{{ audit_tools }}'
      when: '"kernel" in ansible_facts.packages'


# Configure Periodic Execution of AIDE
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure Periodic Execution of AIDE
  hosts: all
  become: true
  tags:
    - CCE-83437-4
    - CJIS-5.10.1.3
    - DISA-STIG-RHEL-09-651015
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SI-7
    - NIST-800-53-SI-7(1)
    - PCI-DSS-Req-11.5
    - PCI-DSSv4-11.5.2
    - aide_periodic_cron_checking
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      cG1ZMUZCU2xwYU1qRjNORkp4VWt4RVEyZ3dPWHBsUjI5S1Mwb0tWbVp5S3pRMk5VZE9iMEpzUm01
      MFZrUmlRWEppTnpOM2RHZHhSbXROUlRWeFJISTJlRE5FVG1kNFZYVmlTUzh3U1hGT1owdGxiVkZs
      U2xsNEt6RjFXZ3BCUkZJeFp6ZzRaMVpvWWt3eFNtZFdWWGwzWjJ4VVdHVllOVWRrY2xJeFRXMDBT
      VlprUTA5aU1uZFRZVUpKVFhsWFZISTJhRlZ4ZG5GVk5WQm1WWGxFQ25KTVJWSmlOMDFRZVhGWU5I
      bG9RekpWWW5wVll6Vk1WVWxFVkRGdFRXOXBPVzFOVUU1bFdHMURha0ZJWm0xc2F6SlZVVlpyZVds
      RlMwNVhTMkpvYm1JS1FUbFhhR2t4VnpJclVsZFZWWGxWWTNSMlVUTnBlRGxEV1M5MmNXMXhlRFpt
      ZFhWWU9IUkxNRlZsVFROWVEwZzJUM1pVVUV0Q1ZrNTJjbGh6YUUxNVFncHdXV050TVVab2QxUkNN
      RmQxVUhZMFJuVXlXR1YyWVZOeVNFRlhaVGd3VEV4dlFsWXpiSHBRTVZadlVFSkRlR2hIUTJRMmF6
      ZHRRMVJGUnpWSlFrMDRDalJxWm1aS1VISkZhemRyVDNadk9VVkZZVk5EVG5GdWVsUlNNMWcyV1dK
      a1NFUkRWazVZZUZaaVVqZFZhRFp6Y2taU2NVa3ZSVE5IU1VKT1VuSllXbllLVDJ0SVlXRmtlVlpU
      U21wdlpITTJVeTl0TXpKa1pUbFBla3BNVWtsSE4zbHJhbHAyTTJaR1pqUktjblZZYXpKbGFuQkpj
      VGxoVUVaWVdHZEhUblF2T1FwT01IUXdiWGhyYkVkbUt6VlFWR3d3WlZOcFJtUlhibUoxZGs1TE5G
      bFZWVFpyUlM5NVZreHVORFJpTlhad2QwZzRTWGMzVEdkNVNtUjJWVEY2VVU1NUNrTk5ORFp2VlVG
      d09HdENURzk0VWpsR01IQXZibkJIV0ZKc2RrTlBha1JqVERaVU4ySTBORVJuUjJGUkwwMTBiV3BO
      UlRKVVVXTXhWM054TUVaSE0zZ0tSR2QzV2prME9IRnlabkV2YW1aRE5TOTFXRzE2YWxGUUwweExL
      MDl4WVdSeGJFWkxXSGd5TkZrdlIwUldhQ3RwVVc1alUxaE9jRlpsY21sdFFWSnBhZ28wYXpOeFQx
      QlNRV1ZPUWtsSE5uTm5abnBFZGdvOVVYWjBjQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure AIDE is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: '"kernel" in ansible_facts.packages'

    - name: Set cron package name - RedHat
      set_fact:
        cron_pkg_name: cronie
      when:
        - '"kernel" in ansible_facts.packages'
        - ansible_os_family == "RedHat" or ansible_os_family == "Suse"

    - name: Set cron package name - Debian
      set_fact:
        cron_pkg_name: cron
      when:
        - '"kernel" in ansible_facts.packages'
        - ansible_os_family == "Debian"

    - name: Install cron
      package:
        name: '{{ cron_pkg_name }}'
        state: present
      when: '"kernel" in ansible_facts.packages'

    - name: Configure Periodic Execution of AIDE
      cron:
        name: run AIDE check
        minute: 5
        hour: 4
        weekday: 0
        user: root
        job: /usr/sbin/aide --check
      when: '"kernel" in ansible_facts.packages'


# Configure auditd Disk Error Action on Disk Error
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_auditd_data_disk_error_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd Disk Error Action on Disk Error
  hosts: all
  become: true
  vars:
    var_auditd_disk_error_action: syslog|single|halt
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWllRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      bFZWVkZCU1VsaVF6bDZWVWxCY1hWNmVGUllXbVJtYlRWU1Iyd0taVmxSZVhsWGN6Um5NVVZZVHps
      RVVGWjFiRmN4UXl0VE1pOTFTelZwY1U5aWJtYzJkQzlITUU5TFZWZG1XWEpKVjNod1NITlRZbmQ1
      Y0hScVMxa3diQXBuVW1GaGRIVjVObEY0T1d0QlZFTXpWbTFJYldGSVpIcG9XSFl4YldWdGFITmFO
      emxEUmxoMlVsWlRlSEF6YUVaTGQwNXFZVk5ET1dWWmQzaFRNRzVSQ2s1T2MxUjBjVEpTTjBaVWJs
      cDNXUzh3VUc1T1RtcENkMmhUU2pOWk9GTnFXbkppU0hwR0swYzFaMmxRZWxJM0wwZG5ZUzloVURk
      dVRVRkdaMGRTVkZRS2RYUnNSbVJOY1djNVNHZHNZWFZHTmxwWFp6RlVWbk4xUTI5cFRua3ZRakJa
      TmxSd0t6UmFhMVIzY1ZOa2RFZzVLMUk1T0ZGcWFqWm9aMnMxZUhoVE1ncHFaM0pZTUZoSGNGRkRk
      WFp4TkUxcFVWa3lWazB6Y0V4S1IySkxPQzlGVTFkT1IyeFdNRlkxVUdOTGRVNXVWRUpCYW0wMVRs
      SlRkVFJHVGpSMldtZFFDakZHYzBkd2RXVjRTamRzT0V4c1lrbHRSbHBTY20xa1dsUnRZekpwVm5S
      a01HTktUR3A1YW5NeFEyZzBLMU5zUTBkUGEwNXhLemxwU0dadU5ITnVURm9LVEV4M2JubElUR050
      ZVhKdlR6QjFabmRxWXpVMVlWaHllV1VyWVVWUVVuRjRTVmcyWWxoSlowbDNhRFpQTDNVNVVIY3dU
      MnBETURGQ1pXUlZTRU4zU0FwNVlsSXdkekJ6ZWpsNk1uWnFURFp6U1VGMVRYZG9NMGQyWWtRd2Iz
      QTVTelpoTW1kM2NqTkRkR3BQYWxObk5VeE1OM0ExVm1GaGVFUlNSMDlDWjNweUNuTjViQ3Q1ZWpk
      QllrZHljVVYyYkdONGVWSlROM0prYkhGc1NqWkpSMDB6WVVsSGVHOU5SR1pYVm1GUVIwRk5kRkpZ
      ZGxoNWNYZFhXRU15UkVSclJrVUtUME5QTWxGRlJqUTVURVZIU0RGRU0zTkNNVEZqTjFVNFVDdEhO
      bWx6WkZweGF6WnZNWEZVVkdrMU1XTmFWR2hPWkcxb1JIWldVMGRTYm1rMlZrOUVRd296U0hwWVlX
      VmtVV0pUWVVGU05uY3dOMUZaTHdvOVZsQmxLd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83690-8
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - auditd_data_disk_error_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure auditd Disk Error Action on Disk Error
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: disk_error_action = {{ var_auditd_disk_error_action.split('|')[0] }}
        regexp: ^\s*disk_error_action\s*=\s*.*$
        state: present
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Configure auditd Disk Full Action when Disk Space Is Full
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd Disk Full Action when Disk Space Is Full
  hosts: all
  become: true
  vars:
    var_auditd_disk_full_action: halt|single
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      RkZiMUF2VWpScFYxRkdVQ3MwZGxnelV6VTNPSE52VXpOS1NXMEtPVXBvVmxVd1V5czVSbFJDVTNG
      clJGTndUMkpNVGpSbFkyOU5lR1pXWjFOb01FTTJieTlSYldGVkwydEpaMmh1TUU1Q1RUSXJkVzgz
      U2pGMlIwRjRiQXB1Ym5Sb05UaEtZWHBxVTBOblRUSk5abGR6UWtGb05tRnNRakozVEdONmR6TnRX
      akIwYjJkMEwwMHhia2h0WTJsbVExazRTM1lyYnpGVE4waFZSbmx2Q21SdUswbEVSVlIzWjNGR01u
      WkRabE5hTDNZME1pOWxVSGRJTTJWRVZreEZLelIyU2xOTU1qZFZMM2hWUW14U1dpOWtaelZuYlZs
      b1RIaEZkRmhaUTNZS2NsSnlNMFpwTWtZMVJFZEpNWFJCVVdrcldUaEdORE5PYVV0bWRGUm1aWFly
      Tm1ocmRsQXpVMlJWYlVRM2FuZDFNRW93U1RCNVJIWkJjWGhUUzFWTldRcFFNM1ZIZWxvMWJHTlRW
      SGhGWVdnNGFFSnNSWFpwZEdkalYxRnJkR2RKVFVWcVZreEtTM2hWWXpoNmFpdHpXSEJqYW5Jd1Jt
      Rm9ZWGRIUWxsbVRHWnNDalV3YXlzdllYSk5TMU56V2t0WVJUbHlabk5oWlRJeE5EbHVkazB3TTJs
      c1NWazFWbFZIYUZCdGNXaDNORGR4Y0M5VmQzTk1ka1ZhTUhad1lWVTRTRE1LTmtoWlNrWlBTa3ha
      UVc5aU5rMTZRV2hKVEZsT1pubHZVMUpsWTNRNGVIUkVUbk5xYUVKU1oyVkhTVWhwWms5RGNHeHVS
      RGN6UzJWdmRsSlBWRXMzTHdwMFlVaEpaVVZrYUZsV1FtaDRPR05RYzFJNUwxUkVVMlZsZVhwQmJE
      UnNMMGROTUUxb1MxbHBXbFkwUTNKNUwwOXhZazltTW5RM2VqTlJhV0ZFV2k4d0NtNXpkMGhOYjI1
      MVpqVkVaRkZFWW1Vd1NXVlZUekkxT1hGQmVrOHdjSE5aSzNKelppdGljbmxFU1cxUVMySjZiVFEy
      VkhwVU1tMU5keTkwU1VSclZqWUthRkJuU0cxdFZsaHZaaXRJWjJwTVpHRXZjRzFpYVVWbVNXUTRL
      M0pqYTFBNFRTdFBRbEZQZURreWEyNTViWFozTnpGWVFUVnNXRzFDZEV4U1JHdEpSUXBaTW1velRt
      ZERjakpQV0dzemJVRXpZa05XZUFvOWFpOHdlZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83684-1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - auditd_data_disk_full_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure auditd Disk Full Action when Disk Space Is Full
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: disk_full_action = {{ var_auditd_disk_full_action.split('|')[0] }}
        regexp: ^\s*disk_full_action\s*=\s*.*$
        state: present
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Configure auditd admin_space_left Action on Low Disk Space
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd admin_space_left Action on Low Disk Space
  hosts: all
  become: true
  vars:
    var_auditd_admin_space_left_action: single|halt
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      OXNXVkF2TTJWTFoxVjViRFpKTlZkWmVHZGFNVkZRTTJOR1FuZ0tSbGhMY3pZM1NHbE1RMmxyTTA1
      SldWVXZRMGMwV1ZsMlYxbFZSekZ3Y25BMGVXNDJabWxaVDJjMk1WUnRLMFU1ZDJONWFqUklWMGxs
      T0ZCTmJUbHhhd3B0Wnl0V1dVSnJPVmhuYUhadFYxY3JWWGhOVkd0VFJuZENLM1JaVGxCdk1GVldL
      ekF2V1ZCV2VHUTNkUzlQY1RGQlNYcGpjVWRVVGxwNVNGbFlRelp1Q25kWGRFcFdaR2R6YUVoQlJ6
      SkVja2xGTVZkamNHZDNlamRQTVc1UlR6QlFSVzFKWkdkbU5tSmtlRzkzYTBseFMwaDBRMFprTmxs
      cFRXa3hZVXAxU0dJS1pEQnBNa1JsTjJONFRqSnJPRlZvY1U1SWJYaE1Nbll4SzI1QlNHZHBRVkZ6
      ZHpoUFdqTkZaRk5hVFZWT1prVmhibWhXVDIxV1dqWmtNRGcwTjBSSlJRcDJOMGgwT1ZoTGVXczRV
      emxUWW1WQlZUWnRVV3ROTXpWeWJWSkJhaXRwVDI4MlJtVlFNMk5tZUZSV2NtZ3lNME5rTVVkd2FH
      dE1SMWRDWWpKYWVFdERDalJ1ZFdWTVFVdDRVbWhOVG0wMVIyc3JiRXBFYlZKRVJtOXdRVUpYUmtV
      clNHNXBWVE5IZFdNeWRHcDZkbTluTkdwRUwydE9ia0pxUkdsQ2RVaG1NRXdLV1V4NGRUWlFSVlpI
      UXpkWGFrSnliV2hDWlUxWVRVWk1kbUZyYkU4cldqRklPVGhpWkZFMWFURXZjbVJDYjJsaE1DOUpN
      MnB6T1ROSFZEVkVUVU5RVmdwcllVeGhNelEwTDNOcGFUVmFOSGhwUzNkNVVYZDBabWRHVFV0RlFt
      Y3JSV1ZMTDFCSWNEUXhSbkJoVDJ0WloyZHJjMjVXUmpWcWNXSm9SemN3Y2sxWENqbHllbmd5Wkdo
      aE0zSkZORFZ4VkVsWmRGUmFjSHBpWmt0TFNHMDNNMFpoVkhadVNqUlVRVWwyVlc5Rkx6RmFhMkkx
      Um1zNGJXVkRlR3BIYWxBd09UQUtaalJLUkZSV2Ntc3hNSFI2VTFaT1NIbHBXR1Z0VkRNeEwwVkRl
      RlIxZFVGNlVHaEhUVWxqU0VKUU5ISm9RVGhITURWWFdHd3hlbE5JWlhaeGRqSndWd3BaTjI5WFox
      RkhWalUyYVdRdlRGbFRNWGwwWVFvOU5scEViZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83700-5
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-653050
    - NIST-800-171-3.3.1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - PCI-DSSv4-10.5
    - PCI-DSSv4-10.5.1
    - auditd_data_retention_admin_space_left_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure auditd admin_space_left Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: admin_space_left_action = {{ var_auditd_admin_space_left_action .split('|')[0] }}
        regexp: ^\s*admin_space_left_action\s*=\s*.*$
        state: present
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Configure auditd max_log_file_action Upon Reaching Maximum Log Size
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_auditd_data_retention_max_log_file_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd max_log_file_action Upon Reaching Maximum Log Size
  hosts: all
  become: true
  vars:
    var_auditd_max_log_file_action: keep_logs
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      bFNPRkZCU1dnME5GWk1WWFZHUVRSRWIxRjNNMlJUTWxWSVpUQUtWVlJaY1RCQlZrbFNaMU13ZGxj
      MVJrazRWV3BFUlVkcllqZ3lkWFJhY0Zjdk1XRlJRVU54YWpobVZrUnRaamRwYzFCSFRXeHZibEo1
      WXpOelpEbElRUXBWVjNGeEsyVm5ia2RwVWtScGFuQlVMME0xZUZvMWNIQkVkMjFMTHl0aFpuTkNP
      V3BZZERsUWFGQmFVVUZLY201RGFrWnJNSFZ5YVcxemIwWkhSWGxpQ25NeGQwSjZVRlJUZUdsRE5E
      TnhSMlJNTDJGNGIySTBkM28zVERoR2VuZHlZMXAwY25oTWVVbG1aR1Z5YUVaQ05saDZjWFZZTjFJ
      eFNsZFdha1phZDJVS1R6aHFWVEl4VjJ0bU5XZDRjM2Q0Ums5WWQzQmxVazlSVTFOWVdsSjRVRGQz
      V0cxSGRFZEdWSGQxU21RclkyZGFWMU5GUTFWbWJEaHpPWEZ6YTFsaVV3cHlXazFXZGxKc1QzcHpW
      RFZ4ZFdOd2JXVmpOR0Z6WTJReVpqSkNkelZyTDFkdlNFZDZXalk1VDJkTE4yRklhVEZwY2s5RlNX
      d3dTRkptWmpWSmEwUXZDbnBpYjBWaUsyb3hjblUwZVd3clpFSnFlV3hNYm5wTE1EWmlhVWRXYTJk
      WVQxZG1WMVZ1TTBsTlF6a3Zha0kxVVdkUUwyTlNVMjUzTm10QmVIVnZjVFlLTHpWVldVaFJhM2R5
      Y3k5eFFUVnNXV2wxZWxWcFpETlBjRTgzYjI5c1VqUXJRVFpPVUhWUVpUZEJOVGRLZVdscE5qWXhU
      ekZLTDJveGFFOHpZVlZTV2dwYVNXOUtlR05KVVRkQ1p6WjJXbFJNU2taQ2JqQTBUV3h2T1RGMVJt
      bGFOMXBuVHpCMVJ6WkVUMElyU3pSc1pHaFNaREZzT0ZaSWFrUnhXazg0VFcxc0NtRmpVMUZuTjNR
      clkwSjJUa041ZFVsUU9VNURabVE1U0c5VVNtTkVTRXBLVmpsR1FtaHhPRFE1U1Zad0swNUVTRTgy
      TTNaV1RWZDZVMmRLZUZJMk9GWUtTbTU2VlhoNlUxZFRNVTkxTWs5VllVSXdOVW8yYVd0MmFFaDJN
      MXAzYm1VMlRUSjNha2wwUkhkV2REQXdUemRMU3l0aVowRm1Ta3BQTW1aRlEyTnpTQW94VDNVNFMy
      VmlOa0pvUlUxWlJsVTVTMlJZYlFvOU5FMUxXZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83701-3
    - CJIS-5.4.1.1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - auditd_data_retention_max_log_file_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure auditd max_log_file_action Upon Reaching Maximum Log Size
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: max_log_file_action = {{ var_auditd_max_log_file_action }}
        regexp: ^\s*max_log_file_action\s*=\s*.*$
        state: present
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Configure auditd space_left Action on Low Disk Space
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd space_left Action on Low Disk Space
  hosts: all
  become: true
  vars:
    var_auditd_space_left_action: email|exec|single|halt
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      TkdXVkZCU21sTVVsZDBWRGx5T1c1blQxWnhObkl5UkVnd09ISUtTRTFxYUhwWlFXVTFOVkF3U2pW
      VFltVjRXSHAyV21GeU9WVXhUMFZsWTJ0TVFUUlZWMGhCVUVsRVdEZFBZazVOU1dNeWEyNTNlRzlP
      TTFOdllVdHJZUW8zY2s1UVEzRjVPSFIyVVdwcFVURjBka3BQVTBOU2JtWm9kbTlMYW5WMFFtOVVO
      V296V1U5clMwdzRWMWhDVlhaS1dIZFphSEpFTnpkNlozQTFhbUpqQ201UVlYZFdTVU5zVjNRMFRr
      bDNhUzlFUW1sTFExSkVUakVyTjBoMFVtVnJkWHBzWVZWSU1sQkNNbTVZZHl0cFJqWmhZbmRtVkdK
      alNYTjVLekZSSzNVS1NWSTFNakZNYUVkMU56SjBjMjFOU1hnNGNrMVBXR1JXWTJGelprODJWRTVy
      WWtwaFpYZGljRklyYTBJeGVYaG1hamxVYlVSdFNHZG9jbmhEZVRWdE5RcGlXbkV5UVZSR1NFZHlX
      UzlYVlVvemVXWndSM2hPTUROYWIwRnhhRWMzWXpaS2MyVkRabFpDV2tVd2NrVjBOalJUUkhac2Vt
      YzBabWRGTVdOb1VVMXJDbE5TWm1KVGRqTmlaVzlQUnk5T2NXTTJOQzh3UVc5NWEzTnpORFJ4TTFw
      c2JGVnpWbmhHYVU1NlVUZFROVFpXUlRkSFkyRnNLekZ2ZGxZck0weHZPSEFLVDIxV2QzUkxRbmh6
      TTJSM2EwUmxNa3BqZEV0MmJFMUhNekYyYVdKM1RsZEdOMUl2U1VsT1EwNUdNR1pOUkhZeWVIVkJO
      azA1ZGtoTFJYRnNUbTF1VkFwb2JGRjZVVGMxUVU1c2VVbGtTMHRWVWtKNmFURldNa0pCV0ZOMWRt
      SnRTVFl2U1c5RWVXNXVZVTF5YVVWbU5XdHhNMWhHVUhaVlVrVnJPVko0UkhoT0NucHVkWEJWUXpk
      aGNtbE9OakJ3YW5GSFRsQnJVRlYyVlZCbE5FZEpaWGRNYUU1aVNHUmtUbEJETTNKV1JGQlBhV1Y2
      WTNCT2VDOHJla3MwWVV3MlozY0tlRE5UTWxReFkxTnJURVJ0T1ZVeFdGSXZTSEZPYm5wNkswc3Jj
      MWhNYkd4Nk1UTndWMVpNVkU1NWNGSTNXVlpFV2xWUlpDdHdUMHhYVEU0M2JVWk5lUXAwZEZkV1Ew
      NU5aeXRMYms1Mkx6RjNjVEY0UmdvOVpYSklXUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83703-9
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-653040
    - NIST-800-171-3.3.1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - PCI-DSSv4-10.5
    - PCI-DSSv4-10.5.1
    - auditd_data_retention_space_left_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure auditd space_left Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: space_left_action = {{ var_auditd_space_left_action.split('|')[0] }}
        regexp: ^\s*space_left_action\s*=\s*.*$
        state: present
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Record Events that Modify the System's Discretionary Access Controls - chmod
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - chmod
  hosts: all
  become: true
  tags:
    - CCE-83830-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654015
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_chmod
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      a3piMUZCU1RWR1MxUjRkWEJvVG5oeU5qWkxhWEoxV1RnMVlXNEtNRFp2U0RaeFNXeGhZVGRYY0dR
      emNtVkJNVUZ1YjNOSVZVWk1ialpLWkVFM2RqbFVOVWxsYXpSSU9FMUphR3BUYjNJM1JTczNSRzVa
      YUVWMVdrRTBaQXBEVDNRMEwza3JVR0ZYZWpsM2N5OHJZa3RFUW5rNVkwbHJWR2hJVGxaVlYycHhP
      Rk5aUVhNelEyRkZNR1ZxVldRMmFrbHlXRnBoYVRkdFdXOTRRak5IQ2pGWE0wUXdka3htT1Zod2RW
      ZzBUSE5CZGtac1YwMHJVMVI0YVRsT2NETkdNWFJ6V21SeVUzUnBNa2t5WkZBMk5GRm1ielpaTVRr
      MlUzWjNRMFY1UlhRS2FrczRVREJqWVVabVJVeE5TMlEyWWpSbFpXNW9ObWRxTkc0elNHZGhVVmwy
      UkdwVk1tZ3ZiSGxJUVdaUWNqVlVTR05sYVU1Mk9GWldTME5yWkVOaEt3cEtlWFZVVWtsQmVYRXhT
      Mm8yTDB4T1ZYQXJUbEJ0TVRGNVprdGtMMVZpVGs1TmJGRnRjVzVUYURKNlEyUnpVazlhV0dSWVYy
      SnllVnB5ZFVvd1drOVdDa3d5UkZGWVkwY3JSRGwyTkd0VldHTkVVa1pvV0Zvd2N6Vm5TMHRPVmxk
      U01XbzNlV2xhVlROTWJYbHZiVkl4TWxOR2VHOUVja0Z0V1Zkdk5HSk1UV1FLUlVSVWExZDJjVTAz
      YUVKME1uSk1LMjlJWW1sQmRuSm5Za2hUUW5weU1tbFBkRFpHZHk5eWMzTnNNVlE1YVZKMVpXeE9S
      bTV3VEhkbGVrNVlUVkZYVkFwMVdtdE5MMFZHSzFSeFFuRXZWMDVLVUV0NlF6VXpaRVZGV0Zwa1ZX
      WnlWR2xSYVdRdlZsTm9Ta3N5ZURsd1FXUmpSVGxHUW5KM1JqSlhjV0pXV0cxWENsWk9NMVZVVEdS
      c2J5OHZXSEJ0WjFKT2ExRklOM2xtTmpFdlEycDRZMWhoZGxnM1YyWjJUemhzVDNveGVtUlNWVmRE
      ZG5SVlVFMXBXR1JhTTI5RVpFOEtVMkZEUVhrck9HOVNXRTlaYkhBeGR5dEZjWFY1YkZWUE1tZEZS
      a3BOYzB0aE4ySTBlR0k1WkV4WFZuRnZWV3h6VGxkM1RHOVlVek5HSzFwRk9GUmtZUXAyWlZoM2Iy
      aHBMM0l3UW1wS1pEaGtUVkprUndvOVdFMHpVZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit chmod tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for chmod for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for chmod for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - chown
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - chown
  hosts: all
  become: true
  tags:
    - CCE-83812-8
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654020
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_chown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      WnhjMUF2TVc1TVFtZGFOVzAyZW5jd2EyczNUMk1yVTJacWFtd0tjbEpMYjNKRWVGY3ZOSGxzZVVw
      UE0wVkdaMHRHWlhaSGQzVTNjelIyTDNWWmFIY3pTMVl2TkVScmVIbDVVRXBsTm5JclpubFBZekJJ
      V1cxeFYyUlFTQXB3VHpoak0zZExWV1JXWWl0cVpYb3ZWRGxuWWtocldsRTBlbWxyV2xSQ05XMHdP
      WGhSU1djNVEwVldaVFJHZURZclFYUm1abnBrWWtkbU1pdGpVM1pDQ2xkSVZubENTbU5rV1VzcldG
      WmhWekEyUlc0NGQyTTVlbkJOTTBObVVqSkZXamhrZFdOVGFVazNRVzFFWlcxbk1ETTJObU5sYTFG
      MlFXWTVVblZvUjBnS2FERnpWWFJGVDNCV1lXVldVMEU0U25OQ1NHdDJlVGcxZUhGdlZVZE9MMUZt
      TmxkbU1YSnFSbXB2WkRSRllXWm5TMEpZVm5WeU1VUk1XVWg0V0ZSdmJBcHZOM2xZV0V4TlUxYzBX
      a2RYUjFBNWNsSk9ja0ZxUm5Sa1owcE1Rbk13VW14eldrWkJZWGxqVnpob1ZYWlJRVkJXVG1SQ05r
      RTNNMXBSVjNWR2VGWlVDbnBqTms5WlR6VjBVbU12WkdGcUwwbFhlWFowUldKaU4zQkhTbEptVVc0
      d01WRnpVSFpCZDJoRFFtTnhaMUY2WXpOTGVtNUhhbkkwU2pnd2Rrb3lPR3dLUWtnd0wyRjZUMWxZ
      Y0VGalJsTkhPVFpNUldjcmNtVkhUVVl4TWxGMWVtaDBaV28xT0M4eVJFOWtValFyY25FMFpXUlFV
      VUUzV1RkR1JEQkhRV1JSWlFvM1ZUbHJTRll5U2pkWVYyZzNiR0ZGYmxSTWJIUkNTbEp2TW1GVk5s
      cE1Na1ZGWkROc1MwTm9jSHBQVVV3dldVVTVWWFZtTDJKMU5ESTJaRkV2Y1haS0NpdDRjVTR5Yldj
      dk1rTndlbnBVU0dSMWRrUkhla1ZFVlZNemRWQXZkMEV4Ym5RclpGRkRPVEpuZW5GTE1GaG5SR3hN
      T0hrMmIwOXVaVTlzZUZsTk4wWUtjbTExY0ZGRFp6UXpObmx3UVdsclRXazNlVVpoUzA0eGFEQmla
      RXAzVm1WbWJ6bHBZWEkxTkVaa2R5OU9XVGRRV1d4d1VWVnZOaXRYTHpack5XWlRWUXBJVEcxMmRF
      VkJVRFUzVjFWWmIxb3lVMlU0WkFvOWVHcHFOQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit chown tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for chown for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for chown for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fchmod
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchmod
  hosts: all
  become: true
  tags:
    - CCE-83832-6
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654015
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fchmod
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      RkRXVkF2TTBwR1JVUTJkMU5vYUVzeldrZzJjVkJSZG5CQlNsSUtiMWwzUlhGVlpVbG5VM1JJUm5V
      NWJXTk9VVzV6ZVdVelVXZEJXRzQ1UTNkU1UxQlhZbmRaV0ZJeFEwWkRlaTk1VjAxTE1TOVFjRzF4
      UkRGM01uWkZTd3B6YWtaRVp6TlViVVZ5V2pSR1ptcG9lVVZRZVhGTlpGVldiVE5GYVc5UVkwaHRa
      VXRyWkRCbFdFVnBha1kzUTI5WFZWcE1WekpaUVN0WFdHeHBNbFZsQ2tKUmExWnBVekpuT1VaMVpV
      eFFlVVJFU21wTE1tbDJWWFozUzFCc01sQjZabmxMZDBWa1VGZHFUekZrWW5VMGRqazBOWFl3SzA0
      eU9FZDZOMmRzWTJRS2RtUjBhM2R0VERkWWIxWlRkV2hrYm1ob2JYUTJkbE16U0RBeGFHdDFiRUkz
      YlZScmNXbFliSFJUVkdZMVZGSlhhSGR1Ym1WeldEaFFOQ3RYWjFST2J3cExlSG8xVjJ4VFpUQkRh
      V2t2YzBFeWVsaEpVV1pVWm5KdE1uRm5ja2xRY1RCSFJXZGhSMFpCYlV4VFdrRXdlbXMxTWpCcGQz
      aERaVVV4WjJnM1pEQXZDalJzTmxseVZtWm9VM0VyVldVek1URjJXRVJaTldKR2NERlpLMVY0Vm5K
      VE5pdHNRWFJLYTAxc09EUklSVU5PVVVoQ1ZGQmtTQ3N6Y0hNMWRrOUVPRklLVUhkYVZUQk1jVFl3
      VlRWdGJVNVhSVEo2VmtWRlp5dDNkWGx4VlROSlNUZHJPWEZqUm5nMGVUWnBVekUxU1daSU1sSk5W
      V3BUZDJnd1NVSm1jMmxxTUFwQ2FVNU1URzEwY0ZwelRVRjJVRWwwYlRsMFZWSkRVa2RXZFdGV1ZW
      QXdMemhGU1RSQk1EQm1NVkJRWVRWSGIzbzRMME5vVjBKYWJXRTNOM05tYTJOTkNtaElkaTkyUkho
      dmF6TnpOMkZYYUM5MWVHcHNjMVo0TkZkTFIwWjJUV3BZU0ZCMGFEUnFlazlEU25jMlJXNDJkV3RY
      WjBFdk1raEhZVlJQY0U1NE9Xd0tSRUp1Y1VGMFJGWmFjemx0Um1abGN6SndVbFJqV1dKek5URjVT
      RGh2SzJ4aVFVTlpiMk53VlUxWFdsVm9TbmR5TDBwMmNFVkdPVEpXZDBKRmNuQTRaZ3BqVWk5SlJt
      ZDBaMkV5UlZSek5ubEJjVkZ3UVFvOU5IRjBiZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fchmod tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fchmod for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fchmod for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fchmodat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchmodat
  hosts: all
  become: true
  tags:
    - CCE-83822-7
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654015
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fchmodat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      SlBiMUZCU1ZKU1lUZHhOV2xXY3pKVVJXWjFPWFI1U1ZWdVRFUUtOVmh6YjFSUFpFTjZSalJyV21o
      SlYxVjRZMU5TV0ZwTFR6RTNRMkp0VUZWSlYxazBRa2xxT1hGcFpVSnZaa2czVUcxcFl6VlBkalkw
      UlRKSlYyUTFVZ3BaZUhsUllsQk1jRUZMU0RGdVNIUm1SSFUzYUZnelpFSkpVRlF6VjBZd1RFSmtO
      R2MwTmpBM2JFTkhlbU5DTUUxSFRuRnBZM2hOYW01emVUVjNUamd3Q21RMGRVeEVURVZWSzFaamIy
      MXVjRnBaVlU4ek5YRkRPVEl2ZFdSNU1GbFVVSGs0UlhFNVlqaHpOR2N4UW1wT1FWTkVXVmRNYmxk
      RGNrWm9Ra1ZYVkZRS04xQlllVXBJUjBwR1JFbHhiMGRvU25OS01qSkNla1pGZVhOWVJYbG5WRXhw
      WTJ0Q1R5dHhaRUppTmxKVmNXNWhOREkwYUdWYVRHTmtUMlV2V0hKbFpRcGpjbE5QWlRGNk5XSnli
      VGRET0ZaMFJrMXdhMFoyU2xreVowbHBPV3Q2ZWxoTmMydG5aV2hoVFUxU1FVaFNURkZTVG5weGNI
      ZHBMMWw2U21aYU1XUlpDbGRJYlZkVVJEazJiRkV3UVRSSmMySlBPSE5FYkdGc1dIWnVaamwxVVVo
      TGNWTlJTekpWVW10SFNqUldVMjl3VjI1d2VrWmFjRlpIUTFrMFVEUTRTV1FLUmxJelRqTkdhRk5L
      VWpWcWRYcHZXVGQxWlZOVmVHaERRelZuWTBndlExQmxhRXRKWVRacVJFeHljbWMyVFhSdldVeExN
      M2MxYkRnM1NWWTNRVlZWYWdwSVZVaFZMMnRhWm1zMVUxcExURU5sWkVZNVptSjFXV0pSTlZGYWNY
      TXlaV0ZuZWt0WVFXdGtTMkZxT0VSaVFreFlXalJSV1hkck16RTJVMVpIWTJkUENsRTBaMkpxUWxK
      clptUlBXVk5MTUVodlduZENSakJUYkdsbGFXdGpjVGRZYVdsUk5XUjJObkZNVkVoWmFtVTNibU54
      YzFOcVpqaDZTbmhDT1ZkUUwxa0tTalIyV25wUllsRjVkalZVT0dGQ01GcEZkblZxYzBrME16aHVZ
      VFpLV1VacFRWbHlNV2RNVDIwNFpWcEpSazVPT1drMGRraDBkbVoyYm1aeGFraFNOUXA2YUdFNVkz
      bHNhRXdyY1hrM1pFSktUWEE1Y2dvOU9GbEZlUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fchmodat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fchmodat for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fchmodat for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fchown
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchown
  hosts: all
  become: true
  tags:
    - CCE-83829-2
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654020
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fchown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WjBkMUF2TW5aR01DOUVTMlJoY2pabFduZGhlRGhCVDAwNGFtSUtlazVSVVZGUVZuaHpSalJpTms1
      cVFqVmhhemh0Vml0YVUzZHNSeXRsV21aTVNXaHNSa0ZoYTI5dWVHMVZiMjlNYWpFMmJHTlRNaXN3
      YjFSYWRVSTFTZ3B1VUhNM01WVlVTMFEyZGxSaldHMVBUSFpOUTB4bmRGUmFTalZNZUdkTVNDdDJj
      MVk0ZG5SdVJVSnBOVmRrZFM4MFZuZDVTM0ZYTWxkeVlqTmlTRVZIQ2tWVU9FcGlRMGhtVG5wU2Fr
      MW1kREJ6TWxKTVVEVlRUMVJ1TVROVFYxSk5lWEZrZWtKNVMyUnhjMHhTV1M5TFkybHdjUzgxUTJr
      eFJtVjBWMFZQYmpjS1VFbHpiWEJyWkdFNFdWTm9aa1IyTkhaSGVWTlhiVmgwZW0xdWFYSlRVMlIz
      VTJwR1NVTlZSemwyZFUxa1prSjJhMm8xV25WR1dITmxReXRTVWpaRVZncG9LM3B1WW1Gd1VuWlZa
      VEU0Vm1abFJWaEJMMHBUV2t4cU5HUnlTeTlSWWxsR04ySXphSE5yV0V4T1EzVnZOV05LZG1kaU0w
      UnlhRXhIVUdaUVlucFhDbUVyV0hoMU1UYzFRVVZKVGpsNVpqTlBZbkpzZUhZM04xTjVXbmR6Y0Rk
      MVF6ZEVVR0ZwY2pkME5XZFFPVE41WVVsV2NEUjZURUUxTkVSeWNrZzBZMllLU2xkUU1VMUJPRzls
      TVZVNFduZHJhRzVpTVhZM1dWaHpWRlo0YW1ST05uRm9PREkxUmpKc05uVkRWekpMVGtwNFVIQkJP
      VmxVTUZwd1VrZHhWaXRFYlFwa1dFaGhPVUpIVEZwWlFYSmFNREJqU0hCSE5rWXhlVlEwZG1FeWMw
      VlJlR2xpUVhkMlQzSjNRbTFJUkhKT2FYZExiRkppTDJwU2RrbHZZWGcwVEc4NENraG1iM1ZrU1ZG
      SGFGTk5UakowTkVOc2ExbEllRzFqTWxObVYxRlRReXRvZGxKd1VtOWhMM2RyUzNWNVoyRmxNMlV6
      VG5JeU9EVXhVQzlZZGpJNEwyUUtNVmhWVHpadmFsRnZkaXRSTDBSU1IzTnlUbGxVU1Rnd2RYTXpk
      VFpFVUdjMFoyRm5kMlZTZDNOM1p6WnVRbEl6WXpKSGFqWjBlRXBXVHpaUGRGZHJlUW8wY1ZnNGJq
      ZDFhWEZzZHpkRmRHZGxUWGgxUlFvOVYxQmhMd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fchown tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fchown for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fchown for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fchownat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchownat
  hosts: all
  become: true
  tags:
    - CCE-83831-8
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654020
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fchownat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      STBRVkF2TXpRMFJWTjFXbUlyVUU1WGEyaEJlbVZ5YURWQ1NISUtWekIzZURka09YZFhjVU5pYUdv
      NWRtMTRRM0ptUWxrdmQzTXJhREF3VTNKTlVqa3ZlbHBaUlhOVE9HZG9UbkZqUkZOUGEyaHBSbk0y
      TDFCT2VrdHdWZ3BDWTBac1ZYRkpWV2Q0TkZCVlVUbG9aRVJaVVZCVGJIQndhM2xaY2pkVldtb3Za
      V1V2S3pWcFlVdFNkWGhPYlZkeVZWTldObEpCVldzM1psSjJjbHBUQ2tkakwzaDBiWFZ2YUhwWGNX
      OVBhbTFHVVRkRWVIVm5XRkpEVEZoNk1ISlRRblZDTkdreEsycDVObXhSZFdNM1oyMUNaMlpLVTJK
      bk5VeGhOVGx1TVRFS2FWcGlaVTh2TW5kdmNuZHVNWFpEWWswd2JHSmFaRTVWTUZGVlNWZEdZa2sw
      TkhaU1YwMWlVa3MwTkRsb2QwOTRLMjFVVlZCR1pqYzFOR0pMTUdwMGJBcDJlRFZ0VVhaclozQkVW
      MjgyUWt4NVpHSXJaSGhOVms1ME5EZGpUa0U1TlV0VFJreEpaelJHUkRkRVF6TjJkRlJMUzNoR2VV
      aGxjMlpFWTJjNFkyUjRDaTlTS3k5dmRYYzRTbWxsWkV0blpXSnZLMUo0VUhCdFJsQlZNV1ZMTkhS
      T2VWRm5ZbkZXY0dkUVJubDZlbEJXTUd4RGNIWmlha04xT0c5bU4xVlVNRXdLUm5Ca2VVbG5Wamgw
      U21SVGFVWmpOelpaZGpOUVUycEJSbFl5VUZvd2IwSk5TMjlMVFVaaE5EUjVVbUZqV1daeVdFeENi
      eTluU1dKcGFrTkdXRGROYXdvdmJsUk1SMGt3Wm1GV05tODFaekpwTkRsa1JtdFVhVmN5YlcwMlZY
      cFBTbGhvWW5sbE9GRkJURWxvTmpGNFVIaHhUMGQwVEROR1dIQk5aSGh3VFZGVENtVk5NM1UyVUdo
      a2JreFVhMUZLUWtWeE5rcHFTbk5hUm1neU1XTmpObTVNYWpCdmFtMXlTWEpSYlVsYVFtVm1NMGhG
      YTI1NFNEUlhNbkJaY25kTVVXa0tRMUZ2U2xaeVlqQXZaVkUxT1habUwzaExWamRUTVdRdkszWTJh
      VTlsUlZWeFJEQnFOM0kxZDFBdkszUlRka2hwYkdVd1lXOWxhbWhXV1habE1tVnZkZ296U2lzemVX
      SlFNMlI1TVU1T0syZDZTVTAyVlFvOUt6SjFOZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fchownat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fchownat for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fchownat for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fremovexattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fremovexattr
  hosts: all
  become: true
  tags:
    - CCE-83821-9
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fremovexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MXhTVkZCU1dKMVNWcGtkMnd2TTNwclMyRlVZbGQ1VFZoeU5rTUtka05YYTNOekt6aENhWE5yT0Zs
      RU5WRTNaWGR6ZUU1VGMzb3lWRE16YTFKRWNXRkRjbmN5Ym1abldtWmtLMGs1UmtobldIUlZTV293
      WTJ4bldrZHVLd28zVlZsQ1NsbFNWREJ5VjBaNGF5dElRMWQzUkhFcmF6QlpkV3hhUzNadVRIcHBi
      M0YyTHpKQ01ERkplSGxNYUV4Nk4zTlBObXRPZEVScmFHY3pUVkZWQ2pVME9VWTVjbXRhTVcxaWNE
      UllTWGQyUm1KUVFTdHpTbWxOT1RCbGFVdEdTM1pEYmtwaGFrdENUM0poTUdWWk5qbHhlak50TUU5
      WVowc3pTV3hvVWxNS1ptSXhSRFppYUZCakwxcFRaV05UY0ZoNVRqZE9ORlUzVDBGdVdrbEtPRUpa
      VWtWT2QyWmFUVGx0VmpGbWJqTk9Wamt3Y21OVUszaEJUMGd4YWpOVWVRcGpPVzVqVm0welVVa3hh
      RU5oYlRKMldHbERjMklyZUhwSlFrOVdWSFJPVDAwelExSnlTREV4ZGpZMmRGSTBOSE5GY25WVUsy
      YzNhRTl0UWtaeFlWcGtDbXBHVDNGVEwyNUVOemRqVVRCWlVHc3pOMFIzUld0TllVSnNLMjVSZW5K
      TGVWRTFNVVpHWXpaSmNuRkhhbEkzWkVGb1ozZ3ZhMjl3YmtkalFtbFpVVUlLZWxoQk1rRlhPV3Ra
      ZUhrMWNYaEhOR0Z2WkN0TmVubExZa04zVjBOT0wwOTFlSGQyUkU0MVNUaFVjVFpNTmt0VFlYVXpN
      aklyU1VSNVVsaHNWakZFUndwcmIzRXZjemRxZDI5b1MzWkxkMXBzYzJkM2FEZDVUMVZsZVZaUU1H
      ZFJiWGR2UjJwTGFXRlpNa2hISzJ4MU5scFlOVE55Wm05MFZGZEtWMGxQZEVJNUNtNVROVk0yVUd0
      SWVEbEVOMmxCYmk5V1VWUTBiVEZIWlhZNVMwWnpibEZEWjNCNWNUSXpVVFZSYTJOc1NHSXhUM281
      YjFsUlFuSmlSMFpSUWxkdU5rOEtLekZDTW5aWWExaDJRa3hZYldjNFoxRXhWMFJWU2xWbWVHTlBk
      WFp1TXl0NGVtUTJTekpKZVU1MWJVWlBjRkJ2Tm10UkwwMHpMMng0UjNKdGF5dFliZ3BoTVROblFt
      TnhlVEZuVkZGamJFbGhhRkZtZGdvOWRsZ3hXZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fremovexattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fremovexattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fremovexattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - fsetxattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fsetxattr
  hosts: all
  become: true
  tags:
    - CCE-83817-7
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_fsetxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      bE5iMUF2TTFkNFIyRnRXVmhGZGxZd1VreEdNbE5rTUU1SVpsRUtVbmhsS3pRek9ESTRSMUUzY0VW
      Q2VrbGhVVTF4WlVSRmF6ZDFXRUZNV1U5T1ZHbG1hRGxxVmtnMlkxaHdjMWNyTVRKVFUzVnJla1Y2
      VjBGeEwwSlVRd3B3TTNkc1FYbEphMHBXUzI0MFFrb3ZOQzlrVVcwdlZWVTVOMWhxWVRVeWNsbHlk
      akpXYVdSVVN6aDBjMlF3VGxkaFVVTXZRamhOUkZReU5FZ3ZlRmhhQ2paNGVqbERUMmRQVmpoMFJY
      WXhTMjVOYUdKdWRraHdkM1ZyY1U1NWRtVk5SVVZDUVVKMlVqaE1LMnBPZHpSSVFrSlVkblZWSzNr
      NE5rTkNSVFJHWVhJS09UQlZhbUZHYnpoaVEweE1kMEZ6TWk5MWFESk5SSEJ5Wmt0UWRIcHhVall6
      V1dwa2VrdGFVM3B1UXpaRVNuSjZlQzlNYjJWR1FXczFUMHhVTVc1VFl3cHlXVTlyYURob2VqQkRO
      SEkzVlM4eGJqQnVlWGxET1ZWRGJWVjFkMGg1WTFsRlRuRmhTWFpKTUVobVFucG1NMmx5YldGc1VG
      SXlUWFFyVlRoUk1FNVhDbmhWYkZCVVJrdFpNamxZY21jM1RrNW9LMkpsV1RWRmRISlhTbkV6VTJO
      clJVeEpXQ3RVU21SQmRtdDFPRFl3VEdWS1lWbFpObVJCVkZKUWIxQlZaMFFLVGl0aGFYTkVRV2N4
      ZGk5TU9XSlJlRkpMVlRGTlNISjJlRFF4TUdjd01ITXhaM2R2Y2tSc05HWklORnBQU0VSTE5sQkdV
      akYzVUhSeE1EQjJjVTVWU0Fwc1dHUTRlRVp3VUZWdE5ucHdaRFpRVFhaSU4yc3hkakJ5YTJOWFVV
      ZElXV2xpVkRSNlUwcFpWbkl4U3lzMlNFSllaVVpQY0RBNVVXbEtSblk1ZURaaUNrRjRWVVJESzBW
      bFdGRlBZMW8yZWsxWlRrbE9TakU0YUhFNGRWTnpVemw2V0RKcFJHUkxabkZSUmxCVlJVd3pNRFZo
      VjBzNFNXa3lla3BpYjFkMFJXUUtaekl5V21abWFEYzFRbEUwWjBwNU9WTkZiVkJVVFd4UVZqUTFh
      bXd2UWt3dlZtcDVla2h2Ykc5SFIxTnNZWEl5TVZRd2RIWktNbkYwYW0xWVNrSk9hZ292WlRObFYy
      MW5WWGMzUVV4MUsxcEVOa2d4WXdvOVRFUktNQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit fsetxattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for fsetxattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for fsetxattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - lchown
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lchown
  hosts: all
  become: true
  tags:
    - CCE-83833-4
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654020
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_lchown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      aDVRVkF2TTFVeWJXTnpMek5CWTJOUGVuTnBWelZDVlVoak9Vc0tUa3hKWmsxMFFtdHJiakp0ZVda
      aU9GRkxkbXhLTmswcldsUllPV1pxUjFVd09YTklOREZUU1hwRE1VRmpNUzlTVkZCbE5HdFhNVVo1
      Y0hsT1lXNXVZUXBGUjBOR0wwOTZOR3BTVG5SelZFaEVSMnh4TkZkNmVUVkRjRlF2VjFaR09IQmFO
      VVY1VEdoa01VVTNaRFJQY0hrNE1sY3dPVTQyZERkSVNGbHdZeTh6Q2taR05YRllSbVozWkVSblVr
      UXhWVXRMU3pReWNGZEdSVWhtY0RabVNFVkpVVEZKY0hwSVJrNVNhakpCTWpKa1JUVkxkMEp3VFM5
      SGVIZzROMVZuUTFBS1RubHNRbU5pU0RCbFNqVmhiWFZvVGt0c1VHSTFZWFZaV0hOWVFtaENjVGt2
      YTJoMmMwdFVVMlpwVUZadVUweExhVzlFYlRONFdqazBkbTFSUjJOSmJRcHdOMFp1YjI1TEx6VllX
      R296Y2toQ1REbGtPSE0yVDFOR1pqRjJPVFpNUzBWMlV6TlVlSGRYVW1oS1ZGaFRZemxCYkZwT2NV
      czRVa2RXZUZSTGRUTlFDamxaVm1oMlUwTlBORXRCV1ZKTFVWbDZUWHA1Tm5WdlVscDFZVVEyTUhK
      VFJrcGpVRTlIV2twR1VUZHJibU5ZUVhoMFF6UXhZMmhxYmk5YVZqQnZhWFVLVUdSTWJrSjNURTh6
      TkZZdlEzcE5UWGN5TjBsSWIxRlNaVXAwTVd0bWVIcFRRME5DTlV0U04ybHFUR0l2UmxsTVMwdDFh
      VWhFWjNaSFpXbFFlRXB2Y2dveVJYTkpiREI0YWxJMmFXaDFhMGhZTmtWeVNqTllSMWN3TDNsNmJr
      dGxkMEV2UVRndk0wdFdjbk5RV1M5YU4zRlliVVkxTTJSbFlVZFpibmwyZFd0dkNrbHliRFo0U1Va
      SmNFdENSSEJXTW5SMFRUZFdXbUpsYTJ3d1JFSk1ZbnAxVlhsaGIydEtjbE0yZEUxdGVucGtiVkI1
      U1dOeVEyRlhNVTAxVW1kTGQzRUtaV3BWTTI5dE5FZDBjRzFaY0dwdmMxaGhZWGMyZUROaVp6RlBa
      REJ0Y0dGd01EbHJjMDlzZHpaM2FGWTVTRkZIVEhsdGFHdzJVSFZsWkc1aGEwd3lSUXBrVlU5blNr
      Tm5jbVJQUVRGU1owZzRMMU5xYlFvOVlXdEZXUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit lchown tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for lchown for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for lchown for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - lremovexattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lremovexattr
  hosts: all
  become: true
  tags:
    - CCE-83814-4
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_lremovexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      SlhhMUF2TUdaSk5sWjNXVU13YWtoQ01VcGhkU3MyZFdwNE5FSUtRVzlYZVM5dFJ6aEZLMVpMV1Zs
      dU0xVkxUVVY0VEdkT1YwVTBOMHh0Y0RadGVWRjJlRWRLTkdGUE1WbGlhV3B4VDFocGJrOXZkV1kx
      YVVWd1VGcEtaUXA1ZUc5cU5XaFBURmRJTjI5SVpUZEVUVFJvVjJ0VE5tWnVOVXR4U21wRWJVRlVT
      MGczUm1SV1FUWkRVbWhLVTNrMmRsSlpPVWhZUlRVNFJrVmxNV2hDQ2pOdWIwd3pXV1JYVGxOc1pt
      UnpRMUJ4ZFZCek15ODFUWEpZY1hwTU5tWmxkMlU1UVRsT1lsRk1ZVW94TTI1a1VsZG9NMFJ5TmtJ
      MVZETndVWHBpZERNS05Ha3ZlVEJrWW5wMGNuaDNReTg1TUhKSlRYVXZWamxsZWk5d1UzVjNRVU5t
      WkVwa2MzbzJlRVIxU1V0cFZHNVlWV3gzZEZkSE5GZDRjSFJZVGxwWmJRb3pkMDVEVGxwd0wzTktM
      M1IzV0hoME5TdG1SblJ0Y25wTFJDdEdiakZLV1hodk1HUjNjMmhJZWtnM1VXMWFTbWhFUjNaWE16
      WklObTV5WlVGbmVrNXFDbWRhVld4WU5HTkZPWFJDVmt0bUwybHhjVGQ1VTFwS2JuRnNhMjlCV0RW
      WWNrcFhkRXhZTmt0T2EyVktLekI2WmpOUllVaGtNMlp2V0RGbU5tTjZRVk1LTm1oNFdWZEZiMkpE
      VlhaYVYyWk1WMU5sY0dzeVlXbHpiRGhWUkZCV05GQXhNVUpCY0ZFemVGbERaVEJIVFV0QlFVRnZS
      WEZIZFZKTVFXUXplRkIyWVFwTWFEZHZZMHh1Unk4d1VrWjBjbEpwUjJGbFlXZE1VREZXV25ZeVNt
      RlpURzlNWkRVemMwOUVlRWRuUzJ0MGFYWkhVM1l3TkhGR0swOXphR0UxT1RsekNsWkhhSGxPU0VW
      UE1YSkJSMFpJTDNWdFJsSnpOMDVqYldSNE1XRlhVbHBpVW1SMk9FOVhVSEJUU0dSNU5sVlhiMUI2
      VkRKbVduUTFkRkpVUlhVelNrZ0tiekJWV1dWelRqSTRkV0kzTVdJeFNqaG5OSEE0TkhvMVRFMXpk
      VVZtT1hOeFNrSklLMWR1TTFCbGVqRkhLeXRvYTNKaWFEbHlSSGRYUml0clUyNWthUXBIYXpGVlFq
      Rm5ibmhwWVM5MVJubExlbU5wWndvOWQyRjFiQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit lremovexattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for lremovexattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for lremovexattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - lsetxattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lsetxattr
  hosts: all
  become: true
  tags:
    - CCE-83808-6
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_lsetxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkdRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      UkliMUF2YW5WcE1rUm5NbWxuUVd0bkt6QkhNbTUxU2s5VmVtY0tNWEZXWm1KRk0wUmhhRVExY2k5
      bGIwUTVRMWhhWmxZNGNpOUZUMGRTYTFsVWFtZFZORFY2ZWtkaksySjBXWEZPVDFOS2RFdHVkaXRI
      U0VKM1J6SjZWUXBKY0RsUE5GQXhlVzB5UlVvck1tSnBjRmxIVHpSTmJGZDFiRTU0TlcxRGExWndU
      MDh4TW5KcVdGUnJRbU01VEdGYWFqRkROamRrZWxVNE9VOTBiWEExQ2tORFFUVkhaWGczVEhVM1Ew
      RXJkVTlqZVdwVGJGQmtkVFpwVmsxWE9EbFZkMWt4V0ZaQ0sxcHRSM2RxVVUwelNUVm9NVXBYYUM4
      NGEwSnBVMmhOVm1zS2MycG1VMlpsTWxBeFIyb3lSV2Q2Y2sxRk1VZHhXVmhOYkUxQk5FSmtiM2t3
      UzJsQ09HNVFWbmxGV0daVk0zbHBXbXRJZW01dWMzQlJNRWhWUjJzME9BcFRjbEpIUzBKSlJqUnVN
      R2RHU25kSk9VSkhUVzFuWWtwT2VYSkhiVTgzYjFwbk0ybHRaVkowVjNaV1EzUnlURk5pUzJzeFVU
      RjFjRTFXVGt4S1N6VXdDbXhHZWt0c1VtTXhTRlpQTjFvNU5tdHZMMFk0YTJsdk5GUkxRM0l5TkZZ
      MVlrMXJSM1ZIU2sxcUwwRnJTbGN4VTB0a05VaGxaRFI1UjI5dVVHaEtZME1LTm5jck55OUZkMWRx
      VWs5UGEya3hTbkl4WkRWWVNVaFJkbXhDTm1neGFXSmliSE5yTW1aUk1YVndWVGhhTVZsWGMyaHlP
      VlpzZGl0dWVXNURiREZ5YmdvME5saElObU54VkZGSlFrVTJhamhYTm1WVGJsRkhZMkpPU25KbVFt
      MVBVRU0yYzFGeVNubzNTbXB6UzFCWFkxZElSMjlpTTAxaVFYVXpNRGMyVEUxWENtTlRNbXh1TTFV
      eldIZDZabEZ1WXk5SVZtbHJOSGRDUmxnMVFsVkJVMjl1VVVGMGFGRkNibVZ1YWs5NGVqRnZNSEZS
      T1hOdWNsRk1aVkJIVFdWemRDc0tWSEZ3V1hONWVrMXZXVkZ6ZVVvdlEwdFZhMjVhVm5nNE9GSllT
      bGR4TTJ0MWIxTmxaM2hyUkdVNGJGaFpVVlF2UlZVd2QwWjJNRFV4VDJsRWRTOWFWZ3B0TTBWRVpI
      ZFpNSEZCUnpabk5HRlBZMk5wVHdvOVlWUk1lUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit lsetxattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for lsetxattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for lsetxattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - removexattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - removexattr
  hosts: all
  become: true
  tags:
    - CCE-83807-8
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_removexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      WmtORkF2YW1VMlFWTnRhRlZTZFV4eFZETmpabVJCZVhSbWJXY0tXR2RPU0ZGR1ZrdzNja0oxTWsw
      cmMzQlVjMnhRU1VORVNIQkNkeXRMVkVkaFMyVk5kSGRHY3pkS1IycEljSFIwY3pOR09TOUlkMHA1
      TmxObVZIVkRRd3BKYUdwSVRGSm5MeTlaWkdSTE4wZFFPRFIxU1hsRVkwZGxUVGxxUzJSaFNuTk9T
      M05JVEdKTFkwTkpkVGRPTjI5a1RHMHdOV2R4Y1dKMVJFSk9TekJ0Q2k5UmFGSXpabHBhWm5kNmRt
      bEVSRkI1TUZKYVdtZ3lkbE14VWsxNFluVldOelF6WTAxQ2VYWjVjRmRFVWt4NVNIVnRUakZoVDNC
      S1drb3ZOM2REVEVvS2RFUlljSEEzY1RJdk0wMVhNR2Q1YmxjMVdHeGxkRU5DTm1OT1pWUXdURkZY
      TUdSb1FrTmxPVmxEYkRWVVpGSk5ZbUp1VERscmFEVm1Xa3QyUjFnMFdRcHhRV3RwZDFob2NtbDFi
      VzUyTkZVdlozTktSbXBuZUZwbFUxTm1TVnB2YVdKb1dXOURiblpQWm5adU1VUjJWWGRYVEV4blJV
      SnZkRzlpVDNKNk1qWlFDbkpNUkd0RWRIQk5aMjkxVFZWVFNGcERZV3hxZGxGVlNUTXlSbnBRTmtv
      MmFFMXdhMDFsWVRNNVpUUmhUVE5XYnpNeVFVZHpkelp0UWtWNlRFNXVZbVlLWjAxWGVsSlRRamhU
      VmpsTFJsSlRhMjlYV0U0dlJVTmlZUzlQWVZkYVQwMHhNa3RpZFVscE9FOUhRV0l3TWxObWFVOWtZ
      eXRLZUVaNVJWVnJNSEJDVEFvdlEzcFhZakYwYTFWTldXeHZNRGxNYTBKT2FtdE1TbXBEU1ZvM1lX
      ZHRVVGsxUVVwME5tVnJNRzFwYm00M1MxbElaMUpUYUdNMVVYaHBTMm96VjA5NkNtc3lOR2xWWVcx
      M2RISjNRbTlxVldjM05VNUlWRFJxT1dFNWVWYzRZM1JOUzBaWVJqQmxablZxWkVaSVkwaDFORTl2
      TWtSUk9ETkhORkZUTmxCVGJXZ0thMDVrV25KWlpVUkNiVmd6Ym10SmJUUkdNVXRNT0dJdmVtWkJV
      MVpwVVZsYWFtSkNablZhVDJ3NVFqVndPRkJoWW0xbVltSXdOR3hFZFRCM1RHcG9OUXBwWVVKMlkx
      bEVabVYyT0dwT2NHSmxPRmx3VVFvOVExQnJhUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit removexattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for removexattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for removexattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Discretionary Access Controls - setxattr
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - setxattr
  hosts: all
  become: true
  tags:
    - CCE-83811-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654025
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_dac_modification_setxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rp
      dFVjMUZCU1RWTmQzWjJOMVZEYURVME5WZzNiU3RxYTJkV1Vtc0tPRkJMTVhkQlJ6UkdjSGxzWVZN
      NVJHUjNRbVpSZUZWb1UzaFhWa2xPU1U5MlExVjVhV05XTXpaMVFqUmpOMlozZGtobVEzQndTVTE1
      YW1oa09GQmtPQXBKWkhKSWQxRnRXVEZ0ZGpRM2JIZEVSMlpWWVRabFJVaG9jM3BLYUVZeWFXaEZW
      MUJIVWtRclIyaHdZVFp6ZUV0NE5XbzVhbWhEVURocmJrcDBMMlJHQ2xKb1p6TjZURTkwVW5neE0x
      UXpXa1JzVkhoWVVYTklXRVZYYTFKdGNtNDJkMEUxWmpkTE5pOXBUMHd5Y1RocFpFMUZZbTh3V0hK
      UWJXTkhXV1IyYmk4S1VrcEhWVU5vYkU5MWR6RmlOVTFRUTNRdlZERnNjRzFDU0RndlNUbFRWbmhM
      U2pOU00wRklNVGhSYlRSTVpqUmlVbnAyTW5Gck9YQlBTV1YzU1M5VmVRbzJkRFJrVkVaVWMxRnVj
      RmxFU0hOUWMxbFhaREppT0VneGRscGhlRmxCTlRoMlMyTTBURzlWVG5WWFprNXpXRkJ0YlZWWGFU
      SkJUV1JOUldGelUwdDVDbFJZV0hacFZ5OWxLMDF2Y1hadlRFUkNWVFIyWWpORFJHTnJXV2xzZUdo
      MU9EWnVkbTVRVGk5eGVDOUZOMlp4TkdoSWR5OVJSVmRLUjB0aVMzbG9VRWdLYkVnemNqaFNNbEV3
      UjNKdVVITTVSazUyUjJJMVdUVlNaemsyU0RWNE5YTmlPVkUwTjNWelYySTJZbVpLTXpWMVNFaEpl
      RFJQYmxSMVZtVnJWMlpaWXdwQ1VHSkZZVTVrUW1sR1VtZEhOR3RaTjBkeGRtNW5lV3h5Y3paRFUy
      bGtSeTg1VDB3MmQzbzJPSGhwWWpKclFYSXZaWGhVTVZJMFFuUnNSazh4Y1Rac0NsaHBUVWcwWm1W
      SVZtVkpOSGhRTWxkdmR6bDBSMnd4ZWxGdlowWnZhSGhxUkVoQ1p6RnZVR3RUUVZkalpUazVkVXhW
      UzFsQ1NVdFNlREIyZVZOQ2NEQUtkWGMwVlhKMldVeE9SR1pQVTBSM1ZrVTVkMVpqU0dwa1FVNXNU
      RzlGTW1WVU9XRmlkM1FyYUZSbk5YcDNUMlp0ZFdOWVlrYzVOMHRGVlhCV09HUkhWZ3AwUVRoUGJp
      OTZTakJZTWxCUlptOXJVVU5QWkFvOWFHWTNNZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit setxattr tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for setxattr for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for setxattr for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Any Attempts to Run chacl
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Any Attempts to Run chacl
  hosts: all
  become: true
  tags:
    - CCE-87685-4
    - DISA-STIG-RHEL-09-654035
    - audit_rules_execution_chacl
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWklRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      QmpPRkF2TVVwQldtUnhUVzg0VEhwV1VrZFRMMmRNT1U0M01UVUtOV3hQVW5waFZVUkRaMmRPUlVw
      TVFXOU5RakZKUm1sMGExbHJjMWhxT1hwamRVdHRNbTFDT1RRMWFFdFdNbE52UTNaQ1RXZ3dabEo1
      VTJGcmNGRnBNd3BMYVRKQlNIRk1XQzlxZVc1T1VtcHdZblJ3UWpsUFJFOVNVMDFwU0ZkUFExUjBW
      R1ZrVFRNelJHdHJjRzFhUkZCWU1EUmpSa0p1U213NFdITkpjMHc0Q21kelppOHliVkIwWkVGMmJV
      dDNjRlpIU1dNNGVWaG1iR0Y2YUdGM1MzVnpiSFVyZFVoVFdIWlhlalZHVUhkWWJ6ZEpZbEkyV0hO
      Wk1UQkxaMXBDVjFjS1QzbE5hVmRSTlVOQlRYTkVPRUZHVW1aYUwweFFSRkoyVWl0eksyMW1SRTh4
      V0V0WmRtMXVNVXczT0hCdGFuVmxjWE5MWlVWRWNtSTRla2RHWm5Sak9RcHlOR2Q0TUhoUmVUUm9i
      VXA0TVhsMmExcHdWMU5pVWtjM09XNXZWMVJ6TlVkeWJrRlRUWEJsTkhwbWRVUmlNbTFYVkc5b1RW
      UTFWbU5ZUkRkWWJYaEdDbXR6ZEdscGMwMTRWM0EyU2xveVJreGhaVzk0YjFCSmJpdFljVkpMY1RB
      eWJYSTViblU0UVdGV1pUUmpkSHBRUm1ONkwwOWphVGhFZFVVMldtVndWeThLTkdwSlEycG1ZbVF2
      UTJ4NGJ6QmlNRE54UzFWRFFYTkhTV1JRUkZZeFpsa3ZlREJLVTFSME1YTlpTMFIyYlhFd1JGZDBV
      VnBSU1ZOWlZHRjNMMmhCVlFwa2EzWndaV1J3ZGxNdk5FdHhTR1V6VEhCWk1tSXdRVk5DU0VKb01r
      OVpVbmd2UnpVMFZHdENNaTloV0RWblVqQTJWQ3Q0UWs5dE9VTldWaTlHWTFGRENsTTJLekZ6ZUN0
      cmNYY3dPRmxKYWxvNGExUjNaSFpMWWtSUFJuSTVNemhKZG1sMVR5OVhRWGw1ZDNGU1FuTk5OMGhI
      Y0VreE9HODVSSEZQTVZjcllVRUthRGswVkZORWJ6bEdibXQwWmxoNmRGcEhjVTV2WkZWV09GQXdX
      a0ZSUzBOVWEzcE1NMEZYWkZaeFRtNTVZVGN3VGpOVGJuRXZVRzFsVlVoTlUwbEtXUXB4Vmt4dWVX
      SnFha3N6VDBVeWRVVnNNSGxEY1FvOVRuSmhhd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Any Attempts to Run chacl - Perform remediation of Audit rules for /usr/bin/chacl
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F
              key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Record Any Attempts to Run chcon
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Any Attempts to Run chcon
  hosts: all
  become: true
  tags:
    - CCE-83748-4
    - DISA-STIG-RHEL-09-654045
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - audit_rules_execution_chcon
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWklRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      bFVPRkF2YVhSaVlTOXhTRGRUUTBsQ1oxTkpNRkZyZW5CSFZHd0thU3M0U2t4SlpIaDVhblZFY2pa
      R1NXTlBOVkJQUzBFdlNXeEVOMGhDT0hOQ2MyaFhVMUpzVVdSRFF6aEtSVWR4TW1oYVVsRnFWemcw
      UTJ0eE5GbHRVd3BJU0VaVFYwazBWbFpzZEhsT1oyNDVXa2xJVmtjMFMxZHhSMjVNYml0UlppdERU
      VlZXZURaNGEwZGFSRnBxZUdObWRuVmpSV295YTNweGNXWlFWMGMzQ2s4MFZVOHdPVzlRTXlzdk4y
      cExiREZuVW1KTWNpOVFUbWMwVnpObFUwcG5abGhGV1U5TlRHWkdjblo2V2tOamVrVTNlRTVLUTNo
      MmRpOVZNWGhMZDJNS1JHaFViVzl0UTFoblV6SmpRa3hxVWxCUGVFcFRPV0ZsUVdaVldsWnBZMGc1
      WjJkVVpFUndURlV2TVVwbmMwdHlOa3hoT0hsallWUjVLMU0zTVdOdU5BbzViV2RCVFU4clJGUnNU
      alZWV0hsU01reEJLMWxZWkZsQlMyVklhRlJPZG5kQ2NGTk1ZbXN6YTJWWlVUUlNNbTFYVTFocWIx
      bHROVXNyTUVWMFFTdHFDamc1ZUV0RksyTnFNbVpFWlc5a01HdFlNVGxuYkdJMFpERk5RVThyYUcx
      TmFVNTZTRXByVUhaMlpuVnNXRmx0Tms5cWNsRjNUaTloTTJnMk0yRnJUbUlLVUd0aVNVcDFabk54
      YUdoU1VtSTBWMFE0WW1KTFluRnJTbTlhTkZRMk5uUmtRak40VHpGSFRDdDNTV05yUmxwSmFHbHFk
      bUZHUlUxWlMyMVpOWEI2U0FwQlpHNXJPVmhVUTA5VE1UY3pNMW92TWxCMU5EaG5SWEJ3VmtkaVdF
      eEtVV1Z6V1hOeFNFRjVhRFpvYzJ0MVVXRnJUbWxVVG5wbFVucGFLMEpFZW5oT0NraEphR0pTUWsx
      M01UTkVaRmhqU0c5RVJtWXhNRlprUjBoMlRHZE9UM0JtTDJoYVRYSk1jMDlHTm1zMlozRlJhamho
      UW01U04zTXhRa1pZWWs1NGVERUtNQzgwTUZCRFVqWk5NRWx2YkdaRmJqTktRVkp5ZDJKVU1VSnFW
      VWhQV2tsUWRHcFNkVEIwZUZoRlRIYzFla1J2ZG1neGNWTlpTWFJKUzIxSFlWQnhRZ3BPTXpCVUwx
      SkxiR3RUVFcxU2ExYzBWWFZ5VlFvOVRHdFljQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Any Attempts to Run chcon - Perform remediation of Audit rules for /usr/bin/chcon
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F
              key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Record Any Attempts to Run setfacl
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Any Attempts to Run setfacl
  hosts: all
  become: true
  tags:
    - CCE-90482-1
    - DISA-STIG-RHEL-09-654040
    - audit_rules_execution_setfacl
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWklRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SjJXVkF2VW1KYVprNUZXRFpCT0RSRE5FMWxNWEZGU0hweWFVUUtiVXhHSzNjelNEUnhiV3dySzBa
      VWREaEZUMWxJVlZGNWFYVmFkMGxuUlVOTmNGWjFRa3RNSzBReVRucGhNa2hEZFVSUFJtUXlURUUx
      VURsV1NrbFdiUW8wYUVGeVMybGhUVmhhY21Ka0szVkhlRmxzVDFKTGVUZ3hNSE5VV1hoRWFGRlhN
      VE5tUjJkYU5XOVRkemMyVm5CMWRuVnNkbWRSYkdnNFNFUnlaRzB4Q2pndk4wcExVRnB5VjBwWmVV
      eEtRMEZpUjBwS1VrODBUVWRVUzFoaFZTdElUSFkxT0ZCTmVWZEZOVTFhWkVoc2R6TllUMXB3VkdF
      Mk9HTnliVlowUkZZS1JYQkZTalpWTlhKUloyeE1TMUZFYkdOeFpWaEZZa1prWVc5M1JqSm9XVkV5
      TkhGRFZITnRNMFZWTTNwNmMyVktRMjl1VVhvMk1VdFNZbEZXZWtWc2RncGlWVTF1YmtaWFltZGlS
      SFpOVVVWVWFXdFhjMHRPWkhGbmVESXhPWGRDYjJSWE5XWjVZbXh1ZUdobFZqUnVjMjFPVTJJMksy
      TnVlVWxHZWtFMFFqYzFDaTlCYW5ZMVpuSmhRWFp2UjIxRWFXUTJOelphYlUxNFYyaE1aVzFzUlZs
      bWR6SkVNVmd2YldnelYxRXlVbEpWVDJOTGFtWktTMmR6TVRaeE5ucE5LelFLU0ZsU1NHMU5TV1ZO
      WkZvdk5YTldhMmhUUzJSSmNWRmFTa0ZzZGpGb2VEWklaamxqWVhKTVRrTlBjblJ4ZEdGbFlWZ3lT
      WGhIVjFka1JYSkliV1pJUVFwMlJqRlBTMmxrWWtack5FaG5kalF3U2pSMk1XZHFibXRFVm5Vdkt6
      SmxOamxVUzNKaWNtOU9jME0xZDAxUllrSlBUVzlEVW1SUE9IWm9ha1pKZFd0U0NtMHlVRFk0TDBS
      SlRrWkdjVGxxTVhZemVHdDFPR2RFZDBwWk1sbFBSalV6UTFFeFV5dHVObEE1VW1GT01IVndVM0Ex
      SzFwV2RXcDRRbkZ3ZUdkUWNuTUtSSEpEV0ZaNWQyaE5XWHBaTVdsd01uTkdaa2hUUWxrMVprcFNS
      RzVtZUVRemJFTlllRGx4YlU5UmQwMHpkRk01TURBdk1WWkxXV1pKVDBneVNXSmFTd280ZEV0SVF6
      aG5TV3RtYTBwNlFuUlNPVlZ5VVFvOVFrd3dWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Any Attempts to Run setfacl - Perform remediation of Audit rules for /usr/bin/setfacl
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F
              key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Ensure auditd Collects File Deletion Events by User - rename
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - rename
  hosts: all
  become: true
  tags:
    - CCE-83754-2
    - DISA-STIG-RHEL-09-654065
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.7
    - audit_rules_file_deletion_events_rename
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      ZERTVkF2TTI5Q1pscEtURkp3TTFWcldWcERRekpSTW5KSlQyMEtjVTFFTkcxSFdTOHdhSHBKWWxO
      NmRtdGFSVEU0VTBkQlowSnFjMEZyUTJwdmMyZG9OWFpoTDNOVFZESmxaalYxYVVObVVUaGFVbTgz
      Y3podFZWcHBkUW92UlRoQ1VpdElNRzlaV1RCVE1FdDZPVE1yTUV4WFpGUmxPRWxoTmpCQ2VITnRV
      M0JTZEZoWkwxYzJTUzlSTkhwRlUwYzFSMnMxZG1reFVXaHpZMFpIQ21WRFZqZGpaMXBqYUhsWFdt
      TmlRM2N5YURoalYzUkxWbGRQVm1oMVYxSldRM0JzTUhsUlVqQTJLM0o1VDJsU01XZFhXblZJVWtK
      SFlWZ3JNSFZEUjFnS2Rsa3dTSHBHV0ZFd09XTXlPVlJuV1M5TGIxWXlkVkZHVGs5WU5ubEhXSEZS
      VURaWVJXcG1NSGRQV2pVMFluQXlaM2MyVVRKS05UVmxlRUl3TUVGRU5ncGpSbVJKU21Od01ubDJi
      SE5OWTJOcFVVTllWVXBOUzAxeU5FTXlVVlZ4YVhwaFVYSlZNblZRT1RNd00weG1OSFozVjA5dVpE
      Sk9RWEpRT1ROVFdsVlBDa1pLUVdVMFFXSlFOMDVxWjBsTFJVSjZaV05qVUZKbk5GcENVWEJ4WVZw
      UFlYQlplVm96VDJRMllXSjZSRU5SYkRZdlZUSjFSVUZUVFRVMVltZ3lTMHNLVVVkQ2FuSlBSSEIz
      YkdsMlJFMTFNbVV3VFRJME1WSTJZMmRPUjIwck4xZE9lWEJvVVVWcGJ6UjNURmx4U1ZSVmFFMWxW
      bFV4UTNOTFYxaG5UR2w2WWdwU1Uwb3paVFJuZEc4d1pWZHlTVTg1YlRGR1MySnNUMnBzT1hSQk4w
      SkJhRUo0UkZCaWFrVmhTVUZ5WjJ0VUswTkhUMVZhV0VwNVVsSkNWVXhyZERGUENtbE1VRlZtTjFC
      RU1HeExjbkZ3Vm5wWEwwZzRiV1ZtUkhkTWR6ZFRVVlJxYWs1aU56aDBTVUZKZHk5V01IaDNkR04x
      YmxOa05HUk9XV0p6VUdkRFFTOEtiRmt4U0cxNVJVWmhUVmRTTm1WVkwydHhkWFIwVWs5TVRXWmFT
      MlI0Y0U1elQwbFVTWGxYTUcxWFlXWk9OVTFvWTNka1lYRkViR1JVTVVrM1owa3pVZ3BYYmtGNlFr
      NDVVRWxrTkVWS05FSlpZMGh0TkFvOWIzQjBiQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit rename tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for rename for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for rename for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - renameat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - renameat
  hosts: all
  become: true
  tags:
    - CCE-83756-7
    - DISA-STIG-RHEL-09-654065
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.7
    - audit_rules_file_deletion_events_renameat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      UnZXVkF2YVdsVFkyWjZiRmRXTUhaeVUyMUlORGhXY0N0WWJEVUtaamM0VlRoMWRtVk9XVzFFYWxO
      NWNrOVdSMkZpYnpSYVNsSnRZa1Z1Ym05S1lWQXhUR3BQY25aRE9YbDRRbUUwY2s4d1RpOUpTelZG
      YTB0dFJWZHlRZ293WVd4M2EzVlNiREZwVjJKc1ZETlZZVXRNZUd0ak5rbFNkVWhvYkVGUFFqVlhi
      MnRVVDFGWU0wNUtlWEoxTjI5WGFqbDVSRmRaVVU5Vll5ODVRMWxuQ25WQmJYSk1hbmxwUTBvcldW
      UmlUemhaWnpCTE0wSjNXR3BKVUZNeUwyRXlhSFJwVlRGTWFrZHdWRE5YZEZKMVUwRktiV05XUjNo
      WlZqVXhlVWc1YnlzS1NuSldabGRLVm5WSmJGcHhOVVY2U21RcmIwc3hjRU5xYzJsTlpXTjBWWEZx
      ZGtweVIxWnFPRzFETW10MFRFTkpXRWM1ZEZkamVIaFJWbUpaU0hRMFZ3cEZSMUJRVTFWU1pFdEJZ
      emRIYTJaVmFtMU1WRWxOZFN0V1ZVNWxZMmR0UVdaNGJIVnNaREJNYWxGc2NETmhWMFJ0UVVWS1dF
      SkRjamhGZG5kdFluVjBDblJ6YVhsWmRWUm1Vazk2ZGs5V1oydEVNWFpSVVZKMlYwVkpUVkl4Vmtw
      VmJWSlhlSFp4WVhNemRpdHJRbFZMVTFCUVYyRTROR3R5YjFoQ1FtcHJNVVFLYVZsaGJsbFdSVkpV
      WVVsNlQzaDNRbkZCTWtFMGFGSnVRbEJKZEhaWVlYbE5aR05RV0dZdmFVTjJLelpWTVhCUmNuRllj
      RTlGZDFkelVtVmhaRkZtWkFwQ1pqVkplRmcyVjFGTVdXZDVlblpvTDAxU01ITjVlVlV3Wkc1WGRF
      aDNSRGsyTmtnMWNtSmlPRTVKU2xoTVFVdDJjemRYY0hkSk5XbHZXR0pvUkhkSENtTmhjazVaY1hC
      cGVWaHZiVlZIU25OUlZ6RkxiMlpIWXpkVU0ySmtWUzh4TWxaWFVEWlViVEZuTjFsemRsWnZNa3A0
      Y25kbFowNVlkelp4V0ZBelNTOEtWekpWWTBNM1JrbEtOMkpzTmpkRGVFWnFOamg0TDNCbVZFbHBS
      bFJxWkU4d2FtczFUMXBDYTAxYVYxRkpObkpIVjJNMlRrZzVaalF2T1ZSMWVFaENhd3BCU0doRFlt
      RlJhMEV3YTFsR1pISTBhR1J2ZWdvOVltTTVaQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit renameat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for renameat for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for renameat for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - unlink
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - unlink
  hosts: all
  become: true
  tags:
    - CCE-83757-5
    - DISA-STIG-RHEL-09-654065
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.7
    - audit_rules_file_deletion_events_unlink
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWktRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MXJVVkF2YWtoUk4yeEhaa2g1YTJwVk1FNDBTWEF2VDNSYVJURUtiMWx2UzFSUE1WTTRiemhMZVVV
      ck5UUjNSRlJvZFRVdlNHVTBiWGx3TVVObUwzVkJNRlEyWTBkRmRIaHdRMDV6YkZoWlFuWlBTbFph
      V0RWeFlrZHJhZ3BIVW1adWNVZGpTRzFXWVUxV1NXWnVWRWhLUmtvMGQxRmhRbUZCVGt4MGNEaE1i
      bXRaTTNCUmJHZFBkVmh6U21SamJ6bE5iVkpWYkVwdE4wRnlLMFZaQ20wMVJXZEZSVVZaYmtaSFEy
      b3lMMkpXTHpGNFdYTndNVkk0UTNrNWIxZzROSGRYWjFkVWJHTldjblYyWVZKSGVrNTBaMUJKWVda
      R1ZFcDJTVXBYU2pjS2JuQXhZVlpTUmxCVVVVOXZjbWRxVnpsS2Mwc3JUa1pMUmpWdVdrZEhiSHBs
      YUdsaFdIQnBTMjV3Vm1GVFMxaDJNbU12U1hOeWJFOUtSMjFXVXpSWlZRb3lOMFkxVTBoTVRFRklS
      SFIxWWxOclozcG9SVmRGWlhZeVVXVTJlV2tyWlZsSE5YaE9hSE41VlhaSFJtRllUbmRPVnpkNFkw
      bDJVRVF5TDFkaU1GUTJDbGQwUm5VNFEyZ3dRbE01ZUROSFJFcDZlV0pxUVV4UWVWSnRURVZqVVZa
      WVRsSkpjVUY0TDFGamVtNUVTVWxtTXk4MVNtbHlRek5OYVdwc1lVeHBXRzBLTkV4QlRVeHhNRzl2
      YUV4eE1FcDNSSGhTTlhFMVFWUnlWRVpRU0V4aVQxQnhjbW94U3pOMlZHZE9UVE1yUlRVcmQxQnpa
      MDQ0VVRKRmVUQjVORTFSU2dwd1RrOUViMDFNYkU5NE4xcEdTM0J1U1ZWdmVFeGpXbWcxWnpSallU
      UTFNQ3RTU3pkaFpWTlZlV2NyYVdwQlZ5dElibTltYkM5bE9EbENSMkZwVUM4MUNrcHdNMGh5UTNs
      NmNFUXJkSGxtVFhWcFQwcEdZeTl6UzB0b2FFdDVaWE5ETUVGVGJGZFFZMEpVZDJreVRUVXJXbWc0
      U0dsS09YZHZVRFYxYVU1RWFFMEtRbU5rZW5GVmVrRnhlRzg1Y0ZSeE1EVkVTbGd4VXk5TGNHMVRR
      UzhyVGtKUlVVbFpOWFlyY21VNU15dEJjVmxIVlZCWlkwVkhRbHB0UWtWNWR6VlpSZ3BKV1RkNVFr
      UmhLeTgxZG01WVV6UTVTalZEY2dvOWR6TkhiQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit unlink tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for unlink for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for unlink for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - unlinkat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - unlinkat
  hosts: all
  become: true
  tags:
    - CCE-83755-9
    - DISA-STIG-RHEL-09-654065
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.7
    - audit_rules_file_deletion_events_unlinkat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWktRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SkdVVkF2YWk5VmIzVmhhamREV2tGVWVqQXJOREJCVkdwVlpUUUtNMGRZWXl0cUx6bDNPVVJKZVc1
      R1pGRm9ka05TTlN0S09HSXllR05NVGtOTVpXOTBjRk0zYzNnNVUyODBNVFo1Um1rNFNtaFNTMHh0
      ZDI5QlExQlFNUW8zVW1kdlEwUm1WbUpEWjAxM2JsbHFlR3h1VEd0QlYzUm1URVZzU2s1R04xcENS
      bWxJVjBNd2RUZG5Ta3AyZUhGMk1FVjBRMjFDYURObFJHaDJTemhhQ2xGbkszRXlXRlF5U1dWalNI
      ZHdZV1pZVTAwNVJVUkxLMjR5YUU4M2VVVXJLMUp6VmxoUk5tbGtibTV1TDB0d2VWUXdiVlJwUjJa
      UVdXVXpUV1F4UzFvS1QxTkNkbWhEVWxSek1ISXJVR2wyUVN0SGNEVlhWVGxKVkhVdlJGVlJjMng0
      Um5BMGRGcGhNRTF2VjFOVFZuVk9PRGRMZFZoMllrRnRZeTlZWVhGbVRRbzNhRzFLTHpaR056VjNh
      bEpqYkVST1ExUjFWa0pXVFV0NlNUZDFibXMzUlZKU04zTkVXa3czTnpFNE5rZ3pWekZ6VlhwME16
      VmphVEkyYmtReGRqaEJDa2h1UkV4NFkwUXljamN5WmtKR2NrZEVhWHBhVDNwSWNGTXlTVXgzVEVR
      eU0yRmhZMUl5ZERaUWJteFNlalJuTTNCV1ZtcGFNMFZ0WTNaUldESnljbU1LUmpKbVMxVlNNM2RG
      V1ZNd1NFTkJURzlyTlc5dlJHcHZTVWhvVFVSamNtVXJWRTlqWTBOalltNVNPR0Z4S3l0eFVWWTVl
      QzgxWjNRMk9VaHZSSE5TTndwSGRYUjJNVUZZVEdkcmFXbHJhekpZY1VGMk9UQjJORTl0Vmt0Qkwy
      UjFLelJGWWtGT1ZrRkVTM1UwVm14WGNVTnhOamg1UW5kVGNHYzRaRFV3VFZCaENqZ3JSMjFJU2tK
      SFR5OVJaak40YVRGb1FUZDNhV0ZYUm10UWJXTTFMMU56Wm5SVFJscHlTWEZxT0dWYWFqaHpNWGhC
      TUZKTVFuTTFOR051VldoRVRUSUtjak5CSzA1Mk9YWmpVRmMwZG5Wb2FIVjBTamQ1YVZwcWQyVmtj
      MGh1YW5KV1FteDNSbkJ4WldaWVJFZFBTRkZZWkRObkwyMDNXQzlzV21wUWVGWTRNd3BEWW1SeGQx
      TkNhMWRPVmsxV1VuUnZTRU4wZHdvOVVXaERNUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit unlinkat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for unlinkat for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for unlinkat for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - renameat2
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Make the auditd Configuration Immutable
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_immutable,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Make the auditd Configuration Immutable
  hosts: all
  become: true
  tags:
    - CCE-83716-1
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654275
    - NIST-800-171-3.3.1
    - NIST-800-171-3.4.3
    - NIST-800-53-AC-6(9)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.2
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.2
    - audit_rules_immutable
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      YzJjMUF2VWtGSFVpdDBaazVrTUZsQ1dsQkVlbkZhUVVveVdTOEtUbEJyYWtRMFFXSk5WbkpXVG5B
      eVlrRXhWSGN3UTBKUVZXVmxlRTkyU0VaaVJraFJOamgzYm5vck9VNWhaazlYWTI5UGJreFhTVkJP
      VkVFeFltdFRMd3B5TkRGVVRVOVhTazFSZFdkaU5sZFRkVEJaVWs1SFpuQk5ZbGRxTUhkS2JGZEVa
      VEZoUlhoRFF6VkVNRFJRWldrNGVVSnZVMk5MTmsxelUxSkViRGw2Q2s1UmJ6RjJlRk5zVkhkM1ow
      Sk1hM2hWUjFrM1NVMUhUVFZFU1RacWJ6bFpiR2RqYUZnMk5ubFRhMlJ6VUVjNGNrdHBReXRvTmtw
      NVN6RlpVRVZVWTBVS1FsUTVXamxOT1d4YVIyTnpRelF6T1d4dFIwTjBOVTVwY0ZaVFdWbHhTbk5Y
      U0VaaWJrNWxXblpuWkd0V2NUSXpiR2RrVERGVllXMXdhR3hrU1N0ellnb3ljbEppWlU5bVYyUXhW
      V3RGY25wWlVUWm1RVkJ6TkRKYWMySnNkWHBwYXpCUmNYcFZZMUp3VURSUGQxUlNZa1pGTHpJMU5V
      TlpNR1F4TkRNck1tbDVDbFJFYlc1dWVYRnBNMk12Tlc5WmNHeG9WR0U0VGt4UlYwUk9ZVFpQVms1
      MFprdGxTa3haZFdaTlRuVk9kMWhOUm1KV1JYTllWVGdyU1dWaFEyWXlNbXNLUW01cVJ6bEdjM294
      UkRjd1prMVNURE5NZWpOMmVWRXJiRUpKSzNWWVpGRjBSSEJVYjJrdmJYUXJWbXhTU0ZkelExa3dj
      V1I2ZFU1NGRVOVZRa2RtV2dwTE9WaENkRXRzSzNCWWJVUjRhaTlGVVdKdFJrazNhbkp5ZGtaSWR6
      VklaRXBSTm01d1YzbEJjM0o0UjBNMU56bFhjMFExVGs0eU1tZDVlVXBIUmtobENsQXhVRzlZY0ha
      M2FVcE5VRXRoVjFZMlUweEhkRFZCUWtSamFDOVFObGxPYTJ4dk1YSjJLMEZVTmtsRFEwbEZlbXQ2
      UTBWRmJVRTNRelJHWWpSeGVYZ0tlWGxwV2xSM01GTmFUalZWVG1kUlJDdElhekJyTUZCS1R6QjZS
      MDV0YjNoVVIxZFVaa2hYWlhoMFJWVm5XR2g2ZFZKdk5qY3JjbkU1TjAxM1RtUm5hUXBoUlc1bU4z
      b3pUMWt5VWxaeWVYaE9kM0kxZFFvOWQyeG5Nd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Collect all files from /etc/audit/rules.d with .rules extension
      find:
        paths: /etc/audit/rules.d/
        patterns: '*.rules'
      register: find_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Remove the -e option from all Audit config files
      lineinfile:
        path: '{{ item }}'
        regexp: ^\s*(?:-e)\s+.*$
        state: absent
      loop: '{{ find_rules_d.files | map(attribute=''path'') | list + [''/etc/audit/audit.rules''] }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Add Audit -e option into /etc/audit/rules.d/immutable.rules and /etc/audit/audit.rules
      lineinfile:
        path: '{{ item }}'
        create: true
        line: -e 2
        mode: g-rwx,o-rwx
      loop:
        - /etc/audit/audit.rules
        - /etc/audit/rules.d/immutable.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Ensure auditd Collects Information on Kernel Module Unloading - create_module
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_create,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Unloading - create_module
  hosts: all
  become: true
  tags:
    - CCE-88436-1
    - audit_rules_kernel_module_loading_create
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MUlXVkZCU21OSlJsZEVTM2xvWTBZNFZYSkpVV2hYT1hSb1Zta0tUVlZhVTJsdFZXRlVNbkJKVUho
      elUxTmtjV2x1Ykd4dlZrbDZTVk40TlhCNFkwVnhVamcxT1N0a09TdGtaemx3U0ZWTmJuQXJNREo2
      TUVSVVdqZzBZZ3A2Wm5OR1QwRTNjamhzYVhkc1QxaFFjMnBoVjA5SWFYVXhUVXBNTmtGNlRVNDJN
      MjB4VDFCamQzRnVUblpRVW5WdU0zZENUVkJSTWpkNk4xUnZjVEIzQ2pKMWNWRkNhM0EzVDJ4M1Iz
      WnVTblZhVmxabWJpdDVTR0ZUZFhSamEyZDFUVVp0Unl0UVNqaHNVMUE1UkVKaWVsWlpWeXRuVWpk
      SFducHhZVEoxTUhnS2JHMVVXRVlyUlVwdldVVmxabFpJZFdZd1pWcHNNMmRVYzFOalZtUndPRXBh
      U1d4WlluTjJiMWRPVm1wUlNUbE5UbUZPV0dsaVdFSTJWM1pIVmt4QlN3b3piamd6U2k5aEt6QXpX
      aloyYzA5NmQwcE5URXBOVTJwSVkzUjJTVWREYWpOeWJFUjJabWMwVGtoNVRrdDZSVkJKTjBwT1VH
      TXlWbWxYUkU4eU1VcHFDa2w0VkVaUVdVSm5ZVXAwV1VoNFYwdzFXa3hGT0ZJMmJHb3pSMnQ0U1Vs
      VGJpc3JhR0Z4VGpSeGIyOTBWazExVlhFMmNIWXJTbUpoYkM5M1kxcGpUWFFLUVhsekx6WTVaM1ZK
      YmpRMVZFbHRNV0pKZVdsVE9USk5WMHBOU1VaUFduWnlTblZtY0d0VlMzcE1Na2hPT1ZoallrcDJU
      amhGUldkM2VHWjRhbXRoYkFwSGMzSmlPRGt2TmtWYVIzTkRSMDl3VEVaVE4zTlFabkZoVkVOU1Zs
      WTRNWGRhWVRrMGFIUjZMMmQyVjBOTFRrMXFkVWczV2s5Q1ZqTlNTMFF3YkVaeENrWlFXVmRvUm5r
      clZXUk9lRGxOUXpGNlJVNXlNalJ4V0M5U01rMVdRMjVtYWpadmMwTTJPRzlYZUVFMlVFMVdlR3BR
      YmpabWNFSlBXR0Z1UldsbFoyZ0tNREJ1ZDFsVGVrcGtNRmxhTW5kbU0yaGxkVmgxYmpSc05scG1S
      VWR2UTJRNWVrNTZjRVJzV21kMmNtd3haV1JJUTJZclF6SmtabWxHTmpVM01VSXpWZ3BrSzJkWmIw
      MDBSVEZhYVZGVGNpc3dXVUpuU0FvOVQxbHpLd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit finit_module tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for finit_module for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - create_module
            syscall_grouping: []

        - name: Check existence of create_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - create_module
            syscall_grouping: []

        - name: Check existence of create_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for finit_module for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - create_module
            syscall_grouping: []

        - name: Check existence of create_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - create_module
            syscall_grouping: []

        - name: Check existence of create_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Unloading - delete_module
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ol,multi_platform_ubuntu,multi_platform_debian,multi_platform_almalinux
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Unloading - delete_module
  hosts: all
  become: true
  tags:
    - CCE-83802-9
    - DISA-STIG-RHEL-09-654075
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_delete
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWkxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WktORkF2YVhCYVEwUklOVTR2Tm5Jd1pXRnpPREZoZW0wMk1tUUtibmRLVlRKSVUzbHNUMFZHUTJo
      clRYQjJSbVl4T1c5SVZXOUpMMmhzTkhwMk1GQlVWMEZJU25SWWFUUlpNbVZGYjBsd2EyWlNiMlZU
      UjFORlNUWTNSUXBLZGpjeVZEQkhLMUI2ZG13M1psZGpPRGhaY21SQ2VVVnNlVnBIUW5GTlIzUTVT
      MFJ4YTJsc1YweElORE14UVdweVVFRkdhVlkyYWxkdVpUVnhNSEJaQ2pkYWNVeEJXSFJxTWpseVJV
      bGFVbWhVU2xKM2NUVjFXVUpDZGxaU1ZtY3lSMDEzUTA5MFFqVk9jMGMzYjJOR09XaHRUelZFZG1n
      d2FHRktUekZEY2pJS2MwVm9VSE55Y1U1MWFUVlVOWGhxUTJkMU9FdG1hRU5LWm1FclJ6ZExabGRF
      YVZCT1RXVkdNbHBaWVZaR2MybHlZak0yTDBWT1MxVnZUWFZHT0hOdFdncFhZazkzUW1sbmVGcFZZ
      M1kzYlZSeVVWTldkbVZzTkdWVWFpOTFNMWxCWlU5MFRsVlVhak5sVTFaV00wbGhla0pUYVVsdVVq
      STBNbFpvZURWS1pFSkJDamg0Y1RGclJHMTNiWGh0VWxnNWFrbFNSbkZOVkhaWVduVlZkQ3QyV1ZS
      MlN6QldlblozZVZwaUszZGpTSGgzYzFGcFpsYzFlVWhRUm5ONVFYZFlVVzBLU0dObFRYQTNVblpL
      WlVkRVprWkJNelZVUjJac2RYUkRhMGxUV1RkMk9UY3hXakE1Y2t0WU5WZG1NV295YmtWMWQwWkRZ
      VXBMTlhRNFVITlFjbmt2THdwcVptSm9XV3RPUjI5eFIzcHpiakpaVkZoUFowVjJXaTlTVWpWQmFX
      MVpTVU5JYm5oT1dtbHhTV1UyTUhOTFJWWk5OR3BsUlhKTVpXZ3hjbU42WjNCMENrZzNXbU5JVFM4
      ek9XaEhiVkJXWmxaT1psRlZRVEJzWVZCaE9HeEVObGN5Wmt0VVNGSlpURVJRVFVvMU4yYzVORkJ6
      VURrNVNqVlVkaTk2WW5BeWQyOEtlR05aYzBaRFNGbHJVMjl5WTJoVFRtRlRVa2RJUzFwaFZuTldj
      WE5zTTBoTGRVMUZVR0ZVTUZKUlRIVlplalJPTTFCSmRGcGpWRkUwUVVWWFowUjJZd28zVkdkQ1lW
      SnRkamxxWWtzclFqRnFjM2MyU3dvOVlqUnZhd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit delete_module tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for delete_module for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for delete_module for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian,multi_platform_almalinux
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module
  hosts: all
  become: true
  tags:
    - CCE-83803-7
    - DISA-STIG-RHEL-09-654080
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_finit
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV0pDUVVGQ1EwRkJSMEpSU205aVNEWk1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      aFZXVkE1YWt4VmNUazFjbkIzUlN0amNrVXpla0ZYY21KV2RXY0taVWcyVFdzNWFtUkdNWGxHZFZo
      SFJqVTFLMDVXTlVsTFNrMTJjbk01TWtNMWJFaDVTM1J4VEhkTlVIVlRWM05vWWxCalowMWtMMjhy
      T1Zkc05XWjZUUXBNWnpSNFFuQmlRamR1UVd4RlZtSlVkazlSVDB4alVXZGxOVUppZGtrMVpsSnZi
      amM1YkhOWkswWlZPVWhVWnpRNWFqbDVjVWhEY0ZGNmNuSkJOM05QQ2xRMlQzQnBaemQwY0hsU1VW
      Vk5jMVJOVVVOeWNFNXNNMlpHVWtaaVFqTjVOVTVHTlhoTVJIQkRNRlY1TWtONmFqaFVVM2hGTkU0
      NFVtOXdValpMVG1RS2FVcG9NRzVHU0RkbldFcG5ibnBhZW5GS1RrRTVTMjVPYVdWM05XRlNhelIy
      UVRaUlRuaENjbVpSV0VGcU9ERk1hSEJEU2pBNGJEWm5TbGhYYTBGRE5RcGxRVzk1YmtGdE5VcHNh
      RGhEV25sSVEzSkpSVzFHYlRNMWJrdHpRV2Q1TkU5d2RUSm5SbXhWZDBwQ04xSjZVVGcwYUhKM1ls
      UkxlVVJwTDBoTE9IbFJDa0ZWYzIxU0wycHBiWEkyVmtWeWVuSkRXRWxVUzNneE5Hc3JMMFk1UkM5
      RE9HMVlkelZaYjJnd2FuSTRNbkpZWmpGaFFVMHpWSFpDYldOWUt6aHlNbTRLUXpVeWMxVnJjbEoz
      WkZwTlR6aFJRMmhUVG5GME1qSlVjamMxYXpGemNtY3ZlV3N2WVZsdVMwSnllRFpGZDNoRVFuUkNW
      MFkzVDNWc1VXWlRWelpLYVFwaWRUWm1LMGs0WTJzMldIcHhiREJZY1hkM1dFeG9WSFJRTkdGWUsw
      MXhWV042ZWxoa1NrTXdVWEI2Y2tsb1VtZ3ZWbTVQVldKVGNHSk1ZM2xhZVdoYUNqa3dhM3BETTJG
      bk9EaFlXSHBQWmxkT1UxRlhOMHhuZDFKWmEwNXlTVElyY2s5NGIyVmpVMHR2ZFVvNU0zTmFPVXR3
      TlRsd1MzTTFaM1YwWkU5RlVXc0tXbGRzWldseFowZG5aSFk1YlhabUwyNWpNbm8wWkhOU05EVk1L
      emMwU3pka0wxWkRWakJWVWxFMWNYVkVVV0k1TVZZMVdFeGtkMkZHWkZSd1pUTXliUXB4YWtzMVJr
      dGtUVTR6VjA1MVZsbERSMlIzUFFvOVRrSklaZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit finit_module tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for finit_module for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for finit_module for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Loading - init_module
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Loading - init_module
  hosts: all
  become: true
  tags:
    - CCE-90835-0
    - DISA-STIG-RHEL-09-654080
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_init
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      cE5WVkF2TWxkRlNIaDNTRTFQWVVGWFEyWjJTbmswTkU0MWFFSUtOalZwVWtaSFVDc3ljMjl1TldS
      WWVUbFBOWEZqYmxJeGVEbFVTVkYxVTBrNVNUZ3lkMUpNTldSbGJpdGhVMjlEUW5wa01rUm5NVlpq
      ZDAxTWVVa3ZVd3BoVWpSS1FTOXRaMDVFV2xJM1RXVTNhazByU1VzeWRuVkZhR05WVkRadFlVeG5R
      VkJIUjFJdlYyRjFTMjU1VTFCU1RtSnBVVWR1Vnlzckt6WTNTelZSQ21ObmIyYzBaVXQwTW1WeVRV
      dzJjRE5MVnlzNE1EZHVTVVJDVlZsbk1tTjRXV1l6Y0dwS1RqY3ZZM2N2TjJvMFowRXhXbk5pZEhk
      alZFMVdaRlUwZWtNS1J6TllMems0WTBaclowNXhaa3B1V1VGaVpVdzNjQ3RITUdzeWRYWm9iV2xy
      UjBKUVJIZHBhSE5hZGtKVGQwb3dlVWh4VUdJNVZFczFTU3RpTjI5cmJBcFZWRXhWV1hKQk16RTBW
      MnRNUzJaeFRXdFJkbkkxV0VwMVJUVXhjRW80U0hKSFFpOU1abVpVV0drNGNFTmlablJXWTNoUmJU
      QkJiR3R4ZG1GWlVqaDFDbEZKVVdkRGVqUk1SbWRRWVhsRVJFWmxPVTEwTXpKeGF6WjNObUV6ZWpo
      a05rNVBibnBMTms4M1dVUkdhbTV2WmpCRFYxQkNLMFF2UjI1a1JWTlRjV1FLVFd4SVRTdFNVMVp0
      UVZFd2NWTkJiR3d4Um5SdFMyeG9NMDB4VmxOdE1uazVaRTlKTlU1UVJYVllSMjR6TVZSV09YbzBV
      VlZLTnpWM1dXdHNabVZsVEFwT2VsbHVhMlZrUVVWdE5YZzBSVVJRZW1aNlF5OTFaMDFSTW5Jekww
      RnpZVFJ5VUdkUFZGZEtkbXhKSzFWVVlqZFRTVFJFY25oRVEyWnZhRmRVVkZkTENtYzVRVTFKUWtS
      T2VXUnNRMUpUUkZwM1VrcGxZMlZIVVRGVU5rODJZbEZWTUZoa1ZXeE5NM0JOWVZsRmVETmpZM05q
      TDJGTGNFWmtWU3RzV2poNlJtVUtNRTVuYzJrdmQzbzBaazFJT1d4SlRYSkRTVWROVG1GSFJXaFdO
      alZoUlZoMk9VZEJUSGRCU2pCNUwyUnhiV0l2YVU5c2NrdFRibU51WWxseVlqTTBNd3BCVTJkQlJG
      SkJRMFJJYldnd0wxQk1TM2xLUmdvOVNrcHZUUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit init_module tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for init_module for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for init_module for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Loading and Unloading - query_module
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_query,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Loading and Unloading - query_module
  hosts: all
  become: true
  tags:
    - CCE-88749-7
    - audit_rules_kernel_module_loading_query
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV0pDUVVGQ1EwRkJSMEpSU205aVNEWk5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      Z3pUVkFyVDBGTVdGaEZTa0p2ZDJOS1EycDZhMEpxVTNnclJWSUtlV1E1YTBac1EzSk1RMlZKVFc5
      TmRYWjZiV0l2ZURodFNrNVdTa05vYkhkemNFeG1ZVkpaUzBGcmNsWkljRlJTYmt3MGVUZHZkM3BK
      U0RSM1RVYzJTUW92VURWa2JUWlhXRU5pU1RGYVVVMXhaWEJKVEVKd1JHMVJkbXRwZFhwbVpIbHFU
      WFk1WlRCc1dubG1ZMElyWVVoMVJIRXZaMEoyTm5wbmNtOU1lSGhIQ2tRM2JuVTFVVWhyT1VWck1X
      ODBWV3R3ZFRKU1dERlBNMmxYT0dOVk1IcEtibVp1T1RNNFpHNVlMMko1ZDAxc05tUXpOVGx0VFdz
      MFMxbDFOek5UUXpJS2JFWkhkMlV3V1RkblREaDJRMjB5UkVOSFNUSlhTMFpaTUZadFJIaHJUbTFq
      Ym5GVVFYQjVZVUpPWVZJeksyWkdaV3R2ZVU1eGJEbEJLeXMyYURaMGJBcEROV3B5ZEVaUWRGbG5i
      WHBZUlU1V1NXOU5Oa1ZNTjJ4Q2VtZDFVVVkzYmxaRlJtZHdWMDFDWlVsQ1VGTkxNR2xUUVdkc1kw
      dERTVkZhVlVzMWRtazRDa2RDWXpSUlowZHVUR2cxVjNCYVlWUmFPRUZoY1UxVGJWZElhVFJoUkU5
      UFptYzVSRTFWU1ZjM1EyeEZaWGhPYVZSQmJucFRVMlJyZUdRNE9WVldSVWNLTTIxUWFVSjBWbHBJ
      TVhCUlprODJiWE40VlVNNVJtMTRTR0pFZUV4RWMyVjFURGhEVmxCTlMwUk9lRmR3U2sxa1VWaFhj
      akJEUWtkQ1Zqa3hZa2N4VHdwak0wOVFWVGhrWVVGdWNVUjZUR0Z2YjFreEwzZG9OVXBvTlZoV2Nt
      eERaM0pxTVRaMlNXOTZXbkl3VW0xNFdWVkdZVnBrVUhGa05IVkhjV2MxUldzNUNqZHZhamh0Vlc0
      clREUm5hRVZ5VlhOdFFUTm5TM2t6TWtJMldHdEdVRE5IT0ZwbU5rUTFlRVJWYkVOd1VtRm1UbVZ6
      Y21NeGJrcHNVREUzVDBVM2MxZ0tUMnN4VTFWcEwzcE5iVFF6ZUhsblJrUjZVM2xFYkRaUWRHOVNP
      VVJWSzJVM2QxazJkVFpPVTFSb2NVSmxla1I0YkZVM1dtaEpkVlpwVmpGdU5qQnljZ3BUU1VkbE9V
      c3dUa016WVZoWmNrRTRaVTlyUFFvOU5ITmpWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit query_module tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for query_module for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - query_module
            syscall_grouping:
              - init_module
              - query_module

        - name: Check existence of query_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - query_module
            syscall_grouping:
              - init_module
              - query_module

        - name: Check existence of query_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for query_module for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - query_module
            syscall_grouping:
              - init_module
              - query_module

        - name: Check existence of query_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - query_module
            syscall_grouping:
              - init_module
              - query_module

        - name: Check existence of query_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=module-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Attempts to Alter Logon and Logout Events - faillock
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillock,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Logon and Logout Events - faillock
  hosts: all
  become: true
  vars:
    var_accounts_passwords_pam_faillock_dir: /var/run/faillock
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SkNjMUZCU1RrMldVSmlZa05uWm10RVZWcGtUV3hqU0c0dmNVRUtlV00xWkhOd2NFSlRRalZMZFRN
      NWNqTmpaMDFoVTBZMVFtNHpSMWxzTnpKRE5VUkxlV0Z6YkRoalowZGFlVXRCVVZJNVoyWjRSa2xE
      TUdScGNHRm9WZ3BhWWpScmFYTmhTM2h6ZUdWTVlUQm9VWEZ0VlRkSlFuRTFlVGxJZWpGMFVVaFRL
      Mk5sUldkcVVsaFNWSEpuY1hNMlVGWmlLM3BQUmtJeVoyRkRWVkFyQ2t4cFowNHhkVU5GWkhwMFZq
      UmlaSEZUVFc5QmIydFJMMFZxVWxOSVRGWk1NMVpTTjJJMU9YVXhjazVVU1ZBMWJrVlJMMjU0Y0ha
      eGEyRkdUbHBDV1RBS1dGSnBRbFJLUlRWRVNXVXlibGhqVnpNM2RTOVFTRnAzVlhJM1NraG5URko0
      ZFRBdlpHTXpTRTVpWjI5QlpFNWlRMUpYWW1sSmFYSXlLMFJOYzNCallRb3dZMVpWYjFBdmFsY3pl
      RVJCUnpkRFkycE5Za2xLY25oamJIVjRWVmxXVTBvNWNrdDVVRk56TDI0MmEyWmFTR1JzUjBOMVQx
      cGFNRnAzUjJNeE5VRnZDbGhHV1ZFM1RtUmFRamtyVEc5aVJWWkNaMFpJWVdNeVMweFRiWHB6TTA4
      eVkyeHNlV3QzZFdwcVJHRjNTMk5ZTTNGd2RqaEtOMVFyTWtNd1NrVTBVMGNLSzBwWmNreFNjVWc1
      YUVGSFJUTk1VVmcwY0hsMVMxbG5SbEpaTm04dlZVcERUVTVvUW5kSmJuTklZakpKTlROTlYwaFZM
      MEU0VWxobE1uWmpUSEJVZFFwSmJUaENhMDFCWVRaVmFFUldaakZqTWpoMVNIbGpNa0ZtZVRGTUsy
      RTVTVnBuT1RnNGJuRXZaa0ZRTUUxSFdHaE9ObUpZTVc1aU5HSnplSFJUWjBwWENuWm9VRGhwVkdw
      elp6aFhUV050V1V0aVptVlJPV3A0T0RaVkswYzJjSHBXWkVJemRrbFlVRkIzZFhOT2J5OWhPR0Y0
      UTA1SFlUbExWMUF2UkROamVtRUtOV2hqYW1SQlJtRTJRWEZhWTFCNWRuZFdURUUwU0RsRVVtOTNU
      MjVPVmt4clJuSjZjRUZIT0dKMU9WaFlUelpPT0dWbmNtbEhLME5JYmxwV2RWTnRkUW9yYTJaT01W
      cHhRbk00U0hOSGFHRktOM1pUTndvOU1sVjVRUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83783-1
    - DISA-STIG-RHEL-09-654250
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.3
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_rules_login_events_faillock
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Check if watch rule for {{ var_accounts_passwords_pam_faillock_dir }} already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+{{ var_accounts_passwords_pam_faillock_dir }}\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Search /etc/audit/rules.d for other rules with specified key logins
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)logins$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Use /etc/audit/rules.d/logins.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Add watch rule for {{ var_accounts_passwords_pam_faillock_dir }} in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w {{ var_accounts_passwords_pam_faillock_dir }} -p wa -k logins
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Check if watch rule for {{ var_accounts_passwords_pam_faillock_dir }} already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+{{ var_accounts_passwords_pam_faillock_dir }}\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Logon and Logout Events - faillock - Add watch rule for {{ var_accounts_passwords_pam_faillock_dir }} in /etc/audit/audit.rules
      lineinfile:
        line: -w {{ var_accounts_passwords_pam_faillock_dir }} -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Attempts to Alter Logon and Logout Events - lastlog
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Logon and Logout Events - lastlog
  hosts: all
  become: true
  tags:
    - CCE-83785-6
    - DISA-STIG-RHEL-09-654255
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.3
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_rules_login_events_lastlog
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      WjVPRkF2YWxaa1YwaFdZbEUzVmxCUmVWaHBSWFJuY1U5Wk9TOEtUMGxCTVdNemRFOTRRV3BpYUZR
      eGRqQkpkRzFMYUhoV1NraGhja1JTWTA0MVdtWjVSMGR1TlRCb2IyOWxkMU13VDJOWlpVOVVTamhu
      YUdSMFdEQlRZd3BXVkRjNFpVaExjSFJNTVRGTVRIRnFTQzlOVUVoemQwUlJlVEJGYUhoTFdWQjBX
      RkpqU3l0bGIyMDFSRUUzZVRRdmJFTlljbG80UTFZclNIVnNVRmxOQ21OcmRHZDJUM1Z2T0dOdVky
      Tm1iV2syTmtKdlVEZDJVbTE2UkhKbFpuQk5UWFJLUVRFMGRtUjNaMWRSYUVGWlkzbG1Za05YWVRa
      bFJuTnZRazh6VnpRS1kyeHZPVm93WldkdUt6UnNTelpOYUdJNU16TlJkMEZIZWtWSVpqUTNlSEpR
      Wm1JeVpGZ3ZZVmcxT1Rsa2VFMU9SekJSTkc5cVpFNU1kR000WW1ob2NBcHlPR2cxTDJReGFHeDVk
      alZHTDJKa1FWbEhhRVIwTVdkR1VUSk5aMDFHYUc1dk9WRlRTblpxWkRWVWFIUkZObk16TUU5aU9V
      dGlSMjFGWWtGcVMyMTNDa3RMZEZGcE4xcElLMUpqVmpsaE9GUktTV1p2TW1VNE1VNXlUVU5zZDI1
      blJFeEJNVGd6Um5wVldHbFZlWGt4ZUZSTllVWlVZWGR6YUVkcEsxWnRjRWtLY1RWb2FVWk1RMWty
      TVVGVk1FeHVabTFvU21WNlQzRlROV2RMYkdKa01rMTFVVlpsTkVzdlRXSlNSakJ6YkZVeVdFRldi
      RzVqYkVGb0swaDFVMFZ6VWdvMFEzbEZlVEJKT1hSck9XaFJlR00zUmpCS2JuaE1XRXMwYXk5d01D
      dFhVMU5WY1ZOc1dFd3JiMFJDZG1KS1IwUlhRMkl5UzAxeFlUSlRkMHh4TlRWR0NrVnFVV3RTVFhs
      U1REbE9PVXRMVDNSaFdGTlNiVGQyUzNaWVEzcHJkRGhLY1ZadmFuTXhSekZFU25KeE56ZHNNM0ly
      VjBaR1JXWm5hMll5ZWxKelp6a0tUSEpsYnk5a00wOVFTVlp5WWpWTlIxRlVjWHBUVG1sdk5HWlZj
      RmRaUzFZd1IzVnJZblpzVURnNFZrdHZWMnB5VlVGWGFWZHdOMkoyY0hwQ1JHOWFWUXB6VW5saFp6
      VmpiWEJEYzFodFUzRkpNMVoyU1FvOU9VdGpNQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Check if watch rule for /var/log/lastlog already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/lastlog\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Search /etc/audit/rules.d for other rules with specified key logins
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)logins$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Use /etc/audit/rules.d/logins.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/logins.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Add watch rule for /var/log/lastlog in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/lastlog -p wa -k logins
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Check if watch rule for /var/log/lastlog already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/lastlog\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Logon and Logout Events - lastlog - Add watch rule for /var/log/lastlog in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/lastlog -p wa -k logins
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify the System's Mandatory Access Controls
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_mac_modification,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Mandatory Access Controls
  hosts: all
  become: true
  tags:
    - CCE-83721-1
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.8
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_mac_modification
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WnJhMUFyVVVWRVpVSnVhR1pZTmxsMWRqTjRjM1JsTW5aMUsySUtUVkkwWVZOdFYyMUdlVnBsVkVN
      emNXUjRNVlphWkZoSVZXOWpWMWxKU21sVFRUVlFVMmxsZWtOUE5tWlNUVkkzZVRrNWVVRmpXaTlU
      WVhRM1duSjBaQW80WjJOU1ZsWnRia2xDVkZaMU5YRkRaV2c1WjFGdWEwY3pUVmhxVVcxdWRWUndi
      bGhKVEVVM2FHSkRRWGROTHpSdGFXbHZjbVYyZFdwS1UwTlpLekJ3Q21wa1dGYzBiR2xpTlM5WGVF
      cEVPRVlyUldjd09IUkpMekF3YzFOdlFuQldjMmRoTkhSMGMydEpORVZPUlRSdmRXaHVTbVJzVjBw
      NlkweE1ibE5uT0dFS1RGaE5XWGx4YTFKcGNrZ3ZVbTF2WWtsdmJrY3ZNRWMwUVZJdlZDOVFhRFo0
      TlRZM05qbE1hSFJrWW5NeGJrSkdkMlZVYjNJNFFrdFJOelZFZHpadVVRcEtOWFIwY1hWMmFqTmlh
      bFpNYm5wSFNTdHFZVlI2UzFSdVRGQnFSSEVyZVc5dFRVcExSbEV2VVdWVk1tSkVkRkZxZEVGdFZu
      TmFiazlMYVU0NGRtNTVDbXBWVkhwTmVIZDVNMnR1YmxGNFoycEZTUzlUVFc5elRtcHlZVkZ3YlRC
      SlUwUTJSaTlIVkd0WFl6VmxVVTQwVGxVeWIwTTBZM00wWld4TWRWaHZSR29LUzJoalV6SjBUbXRa
      ZFZGMldWSllNa0o1VVhoU1dGbEZaRGRVT0ZwMGVsbG9abUZLVEZrMWFUQjFhRGxoV0habFZrVm5l
      V2d3WmtJNGIydFJTV2MwT0FwaWVWYzFhMnQwZWxwelQyZHRaalZISzNacWJscE5VRUZtYVVwek1W
      QjFjbmRtUzFWUVZraHBNbUpUVjJkcFNERlBUMFV4YVhkRmJTOU5kVWw0Y0VzckNqSjNRVUl5VTJO
      MlNVTlJRV1oxTjNnMFFqVlFSRWh3ZDBkMUswcHdjakJOVGl0Nk16TkxaMnM1Y2taRGEwUTRhVzlE
      VFhsdFp5dE9XaTlpTlZSVldEa0thazlxV0dzNWJUYzFaakpHUTNrNEwweGhlbUZLVG5WWFozQTFZ
      M1ZSVEhST2RIUjBPVGQwY2taaVVpOTNLelZsUVVKUmFVazJaVVJFVUZoeGRYZG5Md3BZWWtNMWJH
      dEdNa2hoVWxab2JqQXZTRGh5YlFvOVYzRlZaQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify the System's Mandatory Access Controls - Check if watch rule for /etc/selinux/ already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/selinux/\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Mandatory Access Controls - Search /etc/audit/rules.d for other rules with specified key MAC-policy
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)MAC-policy$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls - Use /etc/audit/rules.d/MAC-policy.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/MAC-policy.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls - Add watch rule for /etc/selinux/ in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/selinux/ -p wa -k MAC-policy
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls - Check if watch rule for /etc/selinux/ already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/selinux/\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Mandatory Access Controls - Add watch rule for /etc/selinux/ in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/selinux/ -p wa -k MAC-policy
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify the System's Mandatory Access Controls in usr/share
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_mac_modification_usr_share,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Mandatory Access Controls in usr/share
  hosts: all
  become: true
  tags:
    - CCE-86343-1
    - NIST-800-171-3.1.8
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_mac_modification_usr_share
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      TnZZMUF2VW5FMGVEQTJRek5IU1ZkYWNuaFpkbUZCUTJaT2RrY0tXRkpIYnpaeGN6SjJObXA2VVc5
      VFZGRXJjMWhEV0ZGb2RIUlVaRmQ1ZDNsTlNFSjZWR3hoY0U0MGNtSm1NMFZUUmpWNFRIbGlaVEk0
      VkdOdlZrODRid3BJWWpoRVZqWTJRbFJITm5sSk9YWlhTa2RNTmsxNWEwRTBNRE15WVhGTk1UVXdZ
      aXREYzNVdmNuRllhRmhEZVVORWJYRlVVRmhPU1hreWNGTkJSMk5YQ2tRcmJWQjRNV1JOWkZreE1U
      RkpjR1k0U21reWJXdDJlalU0UmpWU1JHYzRTMUo2VVdoc1NqSlJRM0Z2YldSSWVWSjZWRUowS3pB
      eWJrbENia05PWTJvS1kxUlNOazVDUmtsc1pGVmxOVVJyTDBGT0wzWmFWakl5VEcxamF6SmhXWGh2
      UWpWdk5YaFZhV3BYVUhSNlluWTJSalZIZUdadlNtWnpkeTlZYlZSWGN3cHpLM0poY2tWVE9IYzNX
      aTl1WkZNd1FXWjBTMGhCTTNkTVJVdDZSa295TlRCV1R6aExlbTExVVRoQ1JFVTRMM052TW5CWlEy
      SlpTa0ZrY0c0d2RHSldDa05aVEVkT2RrMXRRVEZsZG5oUVIzUm1aMnRyUzNoeGNGbEJWRmd2VkZC
      b1RpdDRXbGhKVldVNWEyVjNOVGRoWjNvMldWVkpRMGRUYTFvMVRtbEVZVGtLWlVSRmNraFZVbmRO
      TjFWUFlrSm1jaXRSVDNobk5XbEhaa0l5U0ZSb1duVjBlVUl6TURZeU9WZE9TRFEzY1VSUldHbDRO
      VlpOTjFsaVFYWnVkWGhSUmdwS1drOWphbXMwUVc1cFF5OTVXbG8wZWl0QllXaGxRVGh1TUVkUE9Y
      TlVkVmx3ZEdGQ05VWXhOSE14TVRseFNrMUVPV3g1TlZaSGQwWmxTbEJ2U0ZGRkNrTndhV1ZRWlU1
      SlpHMUxiM3B4YzJkbGMyMUJVbWRVY205bVoxZE1iRmcxTjNGT1dtaGpVM1ZEYVZOblUwcHdWRXBK
      U3pWSmFVeG9WMEpwYmpKeFUwMEtPU3RWYWpBMWJpc3ZSeXRKT0M5MlRVSnBTVUpFWlZGc1JrbG1V
      MnBHZWtrd2IzaE1ialZ3VlUxUlZuWlZUa3AwV1ZSVFJtNUtXVE5qYkhOS1JITkJZUXBsU2xkdWVr
      WlJSWEZJWkZGR0wyaGxUVmM0YWdvOVRFdERRUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Check if watch rule for /usr/share/selinux/ already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/usr/share/selinux/\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Search /etc/audit/rules.d for other rules with specified key MAC-policy
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)MAC-policy$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Use /etc/audit/rules.d/MAC-policy.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/MAC-policy.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Add watch rule for /usr/share/selinux/ in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /usr/share/selinux/ -p wa -k MAC-policy
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Check if watch rule for /usr/share/selinux/ already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/usr/share/selinux/\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Mandatory Access Controls in usr/share - Add watch rule for /usr/share/selinux/ in /etc/audit/audit.rules
      lineinfile:
        line: -w /usr/share/selinux/ -p wa -k MAC-policy
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure auditd Collects Information on Exporting to Media (successful)
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_media_export,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on Exporting to Media (successful)
  hosts: all
  become: true
  tags:
    - CCE-83735-1
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.7
    - audit_rules_media_export
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWk9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      WlZkMUF2UVd0dWVuSjNiak5rVlZaU2VYTldPRWhEVkhSRWNtZ0tkakppVW5GdFdFOWtXVGxrYlds
      YVNWbEhka3RqVFVrd2RYRkhkSFZMVTFOYVpXZFdiRWs1VnpWSVRGbHhOVGQwT1hSa2FpczJRVTlO
      YURCeFJsZEdZZ3BqY2psbVVuVXJTMHA0ZFhGc1YwVXJURUUxYkhOUVoyZDRkV1ZqYkdWd1YwUjNh
      elJ2YlVSV1F6a3JNUzlrYUc1Q2NXaHNWblJHZDJsQ1dVTkVaVUpPQ2xjelprcGlSRFprWjFNMFRr
      UkhSbWs0TUM5Q1JXOUJRVlpJTnpWT1MyRkxNVXMwVVM5Q2JXVXJTa3BpTkVWQlFXNVlVR1Z4ZUhW
      YU9GbHJVbVJUTUVzS0wzQllNRUk1UjI5NVVsa3llRGhSTlhGNWJXazRSbU5IY0RSTGFXZHBZWGM1
      U21Nek9GTXJjRmMwV0cwMFZFTXJhbGREZW5aVWVFVk1la0oyVm5WcVdBcGhPRzFrVkdFeWJ6UjRl
      VWNyTTJzd1luTmpiR2RxWjJObllXZFFjR2htTkc5V05uTTRUR051UkRWR0sxaDVPR2RCVWpOUWNt
      OWFhRmR4Vm1sd2NVZ3lDbFZ3TXk5dFFUTTRhbmh2YWxJdlJGYzRhQ3M1VVZSb2JHWTNXRFpNU3pN
      M1Z6TjVkVzVZWVVGQ1MwcGtkMjVLVFcxaFEwUjVRMFJWYld0eVNGWm1NMlVLYTJGc2Jtd3hhbEox
      ZW1kVVYwTlJTbFZDTm1FNGNqbDBRa1Z2U0dkdmQxQnlVWHA1T1ZsS2VuUmhhVVF5YjFKT2NEazNU
      bXd4VTBWT2RVWXJhM2N3YUFwaUx6RTBXR1V6Um1GdmQxcEdSemhvVWpCb2EyNWpUbnBOYjNSME5I
      UmtaMGwwUnpaM2EyUlpaMUJ2VjJaYVlrVk9kWGhpTTI0clFVNXFRa2RUY1hKR0NsRmpSMVJzVms0
      M1pHeENiRVJMVlVKRFpUVktXak5zYVdocFNUSnVUblpzWnpaVE4xTlJNbkJVYlVNNFNDOU5TWFZE
      Y0doRWEzUTFVMDVvVWxSQlZrTUtLM05YUkdKcVFYaE5WR1IyWjFsYVZ6TnBZMVZCZDNKb1NuWk5j
      VGh0VVhCalJtVXZjMGt6ZWtwdVdtZEVXa1ZyUjAxaE0wUjZXRFZvWTFkMk5YUmFkUXA0TjFWVFRr
      eFNRVWRuSzB0TFpURkhjWEZCY1FvOVJrOUlSQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit mount tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for mount for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/export.rules
          set_fact: audit_file="/etc/audit/rules.d/export.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=export
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=export
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for mount for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/export.rules
          set_fact: audit_file="/etc/audit/rules.d/export.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=export
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=export
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify the System's Network Environment
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_networkconfig_modification,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Network Environment
  hosts: all
  become: true
  tags:
    - CCE-83706-2
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - PCI-DSSv4-10.3
    - PCI-DSSv4-10.3.4
    - audit_rules_networkconfig_modification
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      TnlXVkF2VWs5TE0yaHNaQzluU0ZKcVdWWndOVm8yTlZnd1QzWUtTVzUzTDA4NU1VUm9VME56T0ZR
      NVRERkNkRzR6YUVkMldsZENhakZJTmk5VFZESmtSa0l3UWpoaGR6QXpWSFpsTWt4WFkydzFSU3Rx
      TWpKSldHMVRTd3AxY2s1bFptNXFXWEZIWm1jNE1XRTJVbEpXVEcxbFlXSkdRVlZZTmtOcGJVaEZV
      MFkyYTNkVGFVZHRNWGRGWlc1SVFYaFhZbFp1ZDA1Sk5EZHBWbHBEQ25KTmQzQXJNemh4Y21oMVNt
      bHVNa1YyY21OMmRFSlVhMUpTZUZwaFpHTnFWSEkwSzNGbk5VcG9lamc1YUhwUldXSkhkM0k0WjFs
      dGVqZHVMeXRyYjJzS1kwTmFRVGRMT1VJeVFWRkpPRWx5UTI5amFUQllhMUZqYUZWNmFHVXhNeXR5
      UkdGMmVGbEtUSGM0WXpoak5FODBXa2RUTkRkbGNWVnVkeTgwYkhSbldnbzRTRGRPYkVoa2VqZzRR
      MkkyUmtaR1V6WnlMMXBFUmxKVFJuUlpTamN6Um1oR01IQkJUV05yVG1ZdmRUaGFVMWhuWlVOVWNI
      UnZZbk5YVFdWcE56SjVDakpDVVhOeFJsSXpNVUp0ZEdselJrWXJWMVUxVlZONEwzQjBSMGgzYVdo
      V1QwSmtSRkZzYVdrdmFHcEtVV0ZrU1ZaTFJ5OXBhVFZOUWxKUldHdHpkVXdLUVRWdWRHSkNlalZh
      VHpZemFYTkZUM2x1YUVoTE4yaFplVWR5V1VwQmJVOXJUVUZ1U21aRWVuSkJUa2hDU0dRck1VeDZi
      RFoxYTJ4UWN6TnNObTFUYkFwTUt6QnBOa0ZPTlZCaVREaDVTelpwWmxaeGRYTlFaVWdyWkVveFNF
      VnVTa1JQWlM4M09XMXdZMDg1WkhsVVNEQm9jR05vVVdkeGIycFdia0ZtVERRNENrRXZOSGxxUlZo
      bmJXNW9aV1J1YjBWQkswcHpLMFpOVW5sSU9FNVJlRGxYVTAxQlVqSlhUSFozVEhwRFNrRTJabmRC
      UWtNMU5WcDZPR1J2WlVGSVNsZ0thRWRKUlc0MldHcEhWbVJTYUdVd2RtWk5SRFF5ZGpOUWJXTjNX
      a04zYTNabk5UWmFLM041TTI4eVIwMVNlRnBDWlVWRlYxSnJUV3hOTkZWTk1sSlFRZ281WW5OaFJr
      VnNMMWR4WW1aNldEbExaWFZZTmdvOVFtTlFXZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Remediate audit rules for network configuration for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_rules_networkconfig_modification.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Remediate audit rules for network configuration for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_rules_networkconfig_modification.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/issue already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/issue\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/issue in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/issue already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/issue\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/issue in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/issue.net already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/issue.net\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/issue.net in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/issue.net already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/issue.net\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/issue.net in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/hosts already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/hosts\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/hosts in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/hosts already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/hosts\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/hosts in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/sysconfig/network\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/sysconfig/network in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/sysconfig/network\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/sysconfig/network in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify the System's Network Environment
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_networkconfig_modification_network_scripts,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Network Environment
  hosts: all
  become: true
  tags:
    - CCE-86940-4
    - audit_rules_networkconfig_modification_network_scripts
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      RnRUVkF2VW10MVJIcEZhMDE2V1dWTk1rVjBhbGxJZEZCRk1Wa0thSFZyVkhkTVlYbHFMeXRDUjBk
      RmFVbzFOVFpuUlhCMllrSlROV1JvYlhoWlJuaERkRFZKZHpaR09HcGlXV3R2T0dWcGNUWnplbE0w
      ZDNCbmMzQjVSZ281VEZnM0sxSkxUVkF2VURWR1JFNVZZMHRaVlN0amJqRldVVEE0T1ZsTlkwTjFR
      MHQwUzBwbE0xb3JaV0pxU0hoNVl6SkZSWFpaVFROTlYzWkJkV2RwQ2pVM1MyNWtiMjVKV0VGS1pq
      aHRNWFp3WkZsc1ZGb3pabFpxWkVOYUx6Z3lNRnBhTTJSQldsUXhTWEF5VjNkbGJHSlFjVXRFVjI1
      TFREbDVlVEJGWjB3S1NVMHpTQzl1WkVKWmVHTlFMMHAzTDNkalVtcENNMUJRYm1kT2MycGphMUpK
      VERoemVVOWxUa3hEYkhKVVZsQlRibkY2TDFwQ1NrcE9VSEJxYjBobFJ3cHBNa012YjFVdlUwcERO
      VzFuVGxWWWVWWTBhMnREUkc5WE1qRkJUemRuU2s5b09GRXhjSE42UVhGVmNGYzVRbmxQT1dvMFN6
      aHVkREptVXpnMWNHRjBDbmxzWVhkMGJuWm1RVXg0WVhob1JETnBjVmswT1V0elJVMVhhamh1TW1w
      cmRFUXJlbVphZGpORWRFbHNlbmRoWW1OclRYUlBTRGRIVTFGclVXUm9jVzBLVXpCcFNXUjFWVkZ5
      YmtocFpsbEtjM1pTVlhRdmMxZHlTVFpJZG14QlpVTkRPRlkyVWpaSlZqQkdUbTlWVlZsSk0xTnJR
      VGhVWjBwUk5VbE1kVmhTTlFwTGFGUmlVak5WVGxBeE0wTjFha3BoTjBkNVRqZFlZbkJtZVVReFUz
      VlNUVEpUZUdsb1FsTnlVMU5xVjFOb1FYRlNkV3BpVHprelNWTmxLMUZUUmpoUENsSTVZMnM0SzFK
      NFNFTXdTbTFHWm1GRGRtRndNUzl0Y3pCeWIybFlia2R1VmpBemFsbDVia04yUmpoa1NFVkVMM292
      VmpVMFZuTTRSbUpDVDFwRmVqRUtTRTFWUml0UWFIVnJRM1pRZEhod1pFaHlWa2sxTkU5RFNVaHVS
      VmhtZEhsa1ZWTXlhRkJrZWpOUVEzUkplbUZ5WTNGblRGSjRURlJhWkhaWVpFOWtaQW95VDFJdmNu
      QllWM2RIVkRkc2FYWXlkMWhtS3dvOVVFcFNZUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/sysconfig/network-scripts already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/sysconfig/network-scripts\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification_network_scripts
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification_network_scripts$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use /etc/audit/rules.d/audit_rules_networkconfig_modification_network_scripts.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification_network_scripts.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/sysconfig/network-scripts in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/sysconfig/network-scripts -p wa -k audit_rules_networkconfig_modification_network_scripts
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify the System's Network Environment - Check if watch rule for /etc/sysconfig/network-scripts already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/sysconfig/network-scripts\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify the System's Network Environment - Add watch rule for /etc/sysconfig/network-scripts in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/sysconfig/network-scripts -p wa -k audit_rules_networkconfig_modification_network_scripts
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure auditd Collects Information on the Use of Privileged Commands
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_debian,multi_platform_almalinux
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on the Use of Privileged Commands
  hosts: all
  become: true
  tags:
    - CCE-83759-1
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.2
    - audit_rules_privileged_commands
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      TXZRVkF2TWxSd1RXVm9ZbXQ2UjNack9ERXlPR2xCY0RORlprWUtlVGhKVTNad2VubHVObFJtZURW
      dVUwVjFUM0pYUmxGTVJISlhSMHc1VDI5SGVEWTBTM2xYVTJWNlZDczVhelExUldFd1YzTllWU3Ro
      Y1VNelJXTTVhZ3BzTUZFeEwxZDZlVmhDU0hvMldIZEJTVmRsUzNONFl6RjFPRVE1V0dwUVIwazRT
      V05RZWpaWWNta3ljRXRWZGpFeFlWVlhPRk4zUWs0ck16Sm9OR05XQ25OS2IwWkJPVVJ6SzNkWGRu
      TlBTbWhtUTJkV1ZsZ3ljVlJKUmtWUlRtRnpVamR6VldFMFNYQndPR0ZTVlVwblREUTROVEV4VW1w
      bVNVMW5NVE12Um04S1RIa3haWGw2UVVwSllVTndjMDlwZEhWemRHeFNXbFJuTm0xSVJXMURZMlZR
      Um5ZM1FVNTJaVmN5VVZoMmNrSTNkRko1VTBRMlVFMUVNRzV1TmxaellRcE9iMUIzVUdwdVVUWkph
      MmROTTBOMVUzUTJVVkpETm1Nek1uTXhjR3h6TXpKcGJYUm5iMWRGT1hsTlRFOVFha000VlRJeU1r
      VlVXRkpFZGxOVU0weFdDaTlXWm5oemRETkROREo0U25KS1RXeEphRTg1ZVhaQlpuUXJlRmhETUVG
      VWJXbGxaSEZaWm1JMFYycGxWSEUyUVVJd1drdHlRVzlWTjJVMFIzUlJVV3NLWTFWTU0wOVZjV3Ra
      ZDFabVRtSjNjRTUwUTNsVlN6QlhSRUo1U1hGVmIxWnhaazVCZG1SUlZGSjRhRVpHUnl0bVIyRk5Z
      a1pQWmxwVFVGTlJVeTlZUmdwbFoweDJURFZHTUV0YVEyZFZXSGswYldkNFZuZE1SelUwTTJvelNY
      WmtVRE5KTDNWbk1HTnZZbEZ5UmtZd1Fub3dVbHBRVVVSRVpsWlJWSFZXTUZSUENsUjBWbUpDT0ZC
      UmVrOW1jMUJMUXl0aWJ6UnJRaTlpWWxBeGN6aHJiWEpTTkRsNE56TTBkV04xTkRSeldubE5WVEZS
      WVRCSVpXeHdNV3RtVTBWSlJFTUtUemx1U2pWa1QzZEtabEZvVUZvemQwSnpTVXM0Wmt0MWFGWlhV
      a2t3VG1GSE5tMXBaa2QxYkdWQ2EwVmtWa0VyVHpWUVRHNUdSbGh3YzJ0cldrZHNSd3BoT0hwS2Iy
      cGljVTk2UTNGalJURmhhVU5sVFFvOVlVNHJVZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - Set List of Mount Points Which Permits Execution of Privileged Commands
      ansible.builtin.set_fact:
        privileged_mount_points: '{{ (ansible_facts.mounts | rejectattr(''options'', ''search'', ''noexec|nosuid'') | rejectattr(''mount'', ''match'', ''/proc($|/.*$)'') | map(attribute=''mount'') | list
          ) }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - Search for Privileged Commands in Eligible Mount Points
      ansible.builtin.shell:
        cmd: find {{ item }} -xdev -perm /6000 -type f 2>/dev/null
      register: result_privileged_commands_search
      changed_when: false
      failed_when: false
      with_items: '{{ privileged_mount_points }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - Set List of Privileged Commands Found in Eligible Mount Points
      ansible.builtin.set_fact:
        privileged_commands: '{{ privileged_commands | default([]) + item.stdout_lines }}'
      loop: '{{ result_privileged_commands_search.results }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - item is not skipped

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - Privileged Commands are Present in the System
      block:

        - name: Ensure auditd Collects Information on the Use of Privileged Commands - Ensure Rules for All Privileged Commands in augenrules Format
          ansible.builtin.lineinfile:
            path: /etc/audit/rules.d/privileged.rules
            line: -a always,exit -F path={{ item }} -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            regexp: ^.*path={{ item | regex_escape() }} .*$
            create: true
          with_items:
            - '{{ privileged_commands }}'

        - name: Ensure auditd Collects Information on the Use of Privileged Commands - Ensure Rules for All Privileged Commands in auditctl Format
          ansible.builtin.lineinfile:
            path: /etc/audit/audit.rules
            line: -a always,exit -F path={{ item }} -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            regexp: ^.*path={{ item | regex_escape() }} .*$
            create: true
          with_items:
            - '{{ privileged_commands }}'

        - name: Ensure auditd Collects Information on the Use of Privileged Commands - Search for Duplicated Rules in Other Files
          ansible.builtin.find:
            paths: /etc/audit/rules.d
            recurse: false
            contains: ^-a always,exit -F path={{ item }} .*$
            patterns: '*.rules'
          with_items:
            - '{{ privileged_commands }}'
          register: result_augenrules_files

        - name: Ensure auditd Collects Information on the Use of Privileged Commands - Ensure Rules for Privileged Commands are Defined Only in One File
          ansible.builtin.lineinfile:
            path: '{{ item.1.path }}'
            regexp: ^-a always,exit -F path={{ item.0.item }} .*$
            state: absent
          with_subelements:
            - '{{ result_augenrules_files.results }}'
            - files
          when:
            - item.1.path != '/etc/audit/rules.d/privileged.rules'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - privileged_commands is defined


# Ensure auditd Collects Information on the Use of Privileged Commands - kmod
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on the Use of Privileged Commands - kmod
  hosts: all
  become: true
  tags:
    - CCE-90262-7
    - DISA-STIG-RHEL-09-654105
    - NIST-800-53-AU-12(a)
    - NIST-800-53-AU-12.1(ii)
    - NIST-800-53-AU-12.1(iv)AU-12(c)
    - NIST-800-53-AU-3
    - NIST-800-53-AU-3.1
    - NIST-800-53-MA-4(1)(a)
    - audit_rules_privileged_commands_kmod
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      TkdWVkF2TTNaWlR6Z3JSVWhIZUVWVVQycHRRMHQ0UW5oSWJuVUtOVWhrVFVRelpqUnNObkowYUV0
      RE5sa3JNek5XTURRM2QwSXZSM2xLT1ZWWGRHVkZXRXRsYkhGSlIwRnRiakZWSzNaWlZWRm5aU3Ru
      WjNoNlkyZDBTQXAwV1VGNmJFcFdNSGxKWm1zemNVOWhOSGxGTjNvMlltRkVPWEZXZUVKWWRrUjRZ
      V1k0T1U1VllsZE5ibGhTYnpsWWRHaEdRMlExVnpkd00yWlhRWE51Q2pOemVFUnhWWFIyUW1KNGVG
      QXJUM0pOY0RZeFpHdHNXa1YyVTBVMWRYVm1PR0p5ZFRORU5tNXhhVzh4YWxkSlRVdERjak1yYWpN
      eFVrTkhXVFZ3WjBRS2FGVTNlalZDV25wUlRsSlNiaXR5U2xwbk9UaFFPV1ZLZEdsMlYwNXNXSE54
      UzNOWFNrTjFNQzgwT1ZKTGFVSTBVSGx6VGxKUVUwUmxPRW9yUkhBM1ZBb3ZMMEZtYjBsblVFTlRa
      emRoTml0cGIyTnlZVzlDT1N0c1ZVMWlNbmgwVEVac1VuQkRWVVpsTjFWUVlWTkZhMUJEVTJwYVlq
      VlphMHA2Y3psYUswMVdDazVYZURCTlJGUnZSMVoxZHpCa1Jsb3dRblVyYWxORVFsQktlbEJhVWk5
      R0t6RTBSMEpxVEZsUVZuaG9RV0ZzWTFwVWJtRk9TRkl6YzFGelRVNXpUakVLTkdKdlVGbzFZMlp2
      Y0VGak0zZG1Oa0l6YjBJeWIxSTRiWFpXTm5vcmVISjNlRkJQYkVzM1UwWnZXbXBMVlRKMVMxcE1P
      R2h0VW5ac2JHcGxibFV5UWdwb04yWnVjbGhTY1hkNGNYQTRNUzl4UjBGQmVpOVRPVTVOT1ZCamRs
      UTBhRXBJYzAxeGVtbENaemhTTlRCSWFXVlplUzgxWjFKUU9TOW5lSGg2YlhOa0NuWkdhVlZQYzA5
      elQxUlpSRU12ZDBnM1ZpOVdhVXBKWkdGTlduTlhMMFpYZUhwbk4yZ3hOemRtTURKUFNHVlhiR1Zt
      VTIxME1ETm9Zbkp2VTJaaWJsQUtaMUpVTkd4QlFYVXpSVGRxSzFWbVMwZExTMXBMYTNFNVVuTTRX
      VW8xTm0wdlNGVk1TalJGYVUxUFJEVkZZbkZHU214SU9GSkNaaTl4VFcxdmRqZzJhd3B1VUZaSVIz
      RkpWalpPTTBaa1lXMWtTVmR1TWdvOU5HMHdTQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - kmod - Perform remediation of Audit rules for /usr/bin/kmod
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Ensure auditd Collects Information on the Use of Privileged Commands - usermod
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on the Use of Privileged Commands - usermod
  hosts: all
  become: true
  tags:
    - CCE-87212-7
    - DISA-STIG-RHEL-09-654175
    - audit_rules_privileged_commands_usermod
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      aEZPRkF2TUV4VU4wTjNObVJ1TW1aemRuSk9ZU3RWVWxwa2IyRUtibEFyWlVkNVptZFBNV2RTTjJ0
      bU5tNDFRMHQ2UlZSaFNXeHBXbnBMZW5SMmVWbFVZM2h6TjFVNGNWTk9ka015V21OcGJEbERkWFZN
      VUU1Vk0yWkZhQXAwTmpKU1pVRXlPRzgzY0RaelFtNTVWVVIzY1RGNWNsaGhPR2x4Ym5KNGRWZHpV
      VGQxVUhkR1VWRlNTRzA1WW5kd2FXSlpialZZVmxaSVdYUk1lSHB5Q2xoSlJGcFlkbkUwTlRKWFFs
      WnBTMjEzTkZKM1JrOTRVRlZEWkRCU1dYUlhNVXRsTDNZeWVtOVFiVUZSVW1rNVdtWlFNV2hUVDAx
      aVptUnpXRkJoUzBRS1JWWnVOblZsVEZSWEsweFNXbFU0UjNkM1NVMVpTVkZrWTNaU1ExbE9iVTlI
      UjBseFNHNVNaRUZDUVZjeVUxVlJiV2xTTmt0UFUyeExZbWRpWjJwVWNBcFdZbnBNWkhCTVdWVXZU
      azUyWkdKRFRVMVlLMlZoYVhvM01URTBOV2R2WVdSallsZ3JVSGQxUjFFMGN6WjFPSGt2TkcxbWQy
      bEViVE00ZVdsVVJIQkhDakJ5Um1GWFlYQlRUR0ZPVDFkaFNtUkRUR2MxY2pKMVdUQlRPV3dyWmpO
      RUwxVmFOR3BWVXpSaGEzTXZRalJHVUU1U01WSnJkbHB4U1VocGFYTllWME1LYWpodGR6QnRMelE1
      ZGxjeGNXVktaRE4yVlRZelFUVktXVWh0YkVaT1VIWllSRmh6UVhkaloxVnhVWE13UWk5UE1uZ3Jj
      RWRhTW1vNVZFWkRURFZsYkFwRlV6TlBaazVNVEZaNEsycHhVVEpRUkV4WlVYbDFUM0YzU0ZOdFVq
      QnZabFp5VnpadVkyMUlTelJ5V2pKSlpYRm9OalkzVERkNGVYaE1SRXRrVm5SWkNtb3dLemRvUTJS
      Uk1WWnFWbmQ0VjJoeGVYTkNNSFV6UnpRNFZYVklRVUZqWTBjemJVMHhZbXBNYWxWdFpXZzRjV2RO
      WVdkb1RFSnBZbWhCWjJwclZra0tZekJOZGpSa1VIRkJSRUpLWmxadGFtTkhTRlk0TjFNeFZHdzBP
      V1J2Y1RreWVGbDFWMnBUWTNsQlFuWnpjMlJ5TmxOWlpuQjZjVmh4WWpBMFRYQjFhd3BuY1ZOTFMz
      TTFORzVhVVRoVGNsVmhPRkJrY3dvOVdGZHFXZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure auditd Collects Information on the Use of Privileged Commands - usermod - Perform remediation of Audit rules for /usr/sbin/usermod
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/privileged.rules
          set_fact: audit_file="/etc/audit/rules.d/privileged.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F
              key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls: []
            syscall_grouping: []

        - name: Check existence of  in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit{{ syscalls | join(',') }} -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'


# Record Attempts to Alter Process and Session Initiation Information btmp
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_session_events_btmp,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Process and Session Initiation Information btmp
  hosts: all
  become: true
  tags:
    - CCE-86198-9
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-12.1(iv)
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_rules_session_events_btmp
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      UXJRVkF2TTA5MU5TczRLMEk0UnpOTE0yTjBjbWxYUXl0cVlVY0tRM013WnpOcWQzTkJRMnhuWlRC
      RFEyWlVhM001V2xsUlUyOVdLekYwVG5WbVRtaHVXbUl6ZDJoUloySm5TWGhKZG1GTVlYRlBVbFJ3
      U0ZkSWJtOVdaQW93WjNBMVExZG1NRWQxYURWcU16ZFdkVFJ2UlRSeFdHbG5NV2x4WVM4NVIySnZZ
      amh5WkdsaWMzUmphRzFGWmxoS2NraDNLMjV5WVZZdk9VTnNlRTEwQ2xKR05GZGllRlJXTlhoV0sw
      ZGtjMk01VkhoQlRUWjRTREp6VG14VU0wMVdRbkJzTWxGUVpVTk9PSEpDZUZacGMzRnVhRFU1YWt0
      S1JubHRja2RhZUdJS2MwZFZTMnRMVDI1cE1sVlFhRVpNUlZsaWFqaGtOWGxDTkV3dmVXWlZWVWh1
      WTNsMlpGbG1VRU53V0VOaksyUXJaRVZ5Y0RGU1JrVnZLMjFKY2pONU5Bb3pWSGRaUm5KaFltbEpU
      bUozYVZCM09HaDNValoyWW10cVpGRnBaVE4yTTNJckwyTkVha1YxWjFsblQwNW9UMVJCYlhCcUsw
      dERNa0pGUzJRNVEwSjFDbVpzZGs1V1VIQjNjSE42VWt4WVVXdEtURlJJWVhGU2NXUldRbWN4ZFZO
      MVEwY3plVzVuU0hwd2FYaEhkbnBMU210aVJtVmhlSGhHWTFaeVdtNXZOMnNLV1dkcGVtUk9PRWRJ
      YjJaTWRsb3diSEZST0dsSE1DOVVSWGMzUlRodmMxaFRWbkpxUlhwWE1ESlZTa3BKUzJReFNGbEVP
      RVIzVEV4elJVTnpVbEpuVHdvNGNUVlBjalI0ZFcxT2MwNUhXbWhEZUVaSGRVNVlSVEpWWjFCeE1G
      TkpORkpMTmtkMVdTdFZVbWhWYWtSRWNreFhRVU4yWldZeWRrRk9lVEZRWldkRENtWmhWVTFYVTFW
      R2VDOXRhV3hhTnpSRU9USkNaVE0zVm1kRk5UZE1jMU5KT1hob1JtTTBTM2xuUXpaUWFGRnhZbEpq
      S3k5S1ZuazNNWFUzTUVod1ptMEthbVpYV1ZjelpWbDJRMlZ1V21aeFJ6UnVSMUJrYWpSbGNrUkxO
      R1ZEVEd4RFNtRTBObmhDV2pkYWQwbzJRbmRuTTA5TWVqRkllRUk1ZGxkTVMxcGlRUXAyUjBGRVVt
      VTRaMlprT1VsNFJYcEpNMVJaY3dvOVJ6QmhlQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Check if watch rule for /var/log/btmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Add watch rule for /var/log/btmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/btmp -p wa -k session
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Check if watch rule for /var/log/btmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information btmp - Add watch rule for /var/log/btmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/btmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Attempts to Alter Process and Session Initiation Information utmp
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_session_events_utmp,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Process and Session Initiation Information utmp
  hosts: all
  become: true
  tags:
    - CCE-86202-9
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-12.1(iv)
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_rules_session_events_utmp
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZFVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      ZDBSVkF2VWpGVmNGcHlTMlprYlcwM2EzVTRkRXhTZVdobWFXNEtNMUZCWkhCd1JWaHdSMGg1Wld4
      T05FZEhhamxtY0dZM2NqRXdPRFlyYTJsTGVHVlJjbEp4Tlc5MU1VTnJVMkpKT0cxblpIUjJhME5p
      Wnl0M1VXUXJlUXBDUWxCQmRTdDJTR0ptV1RBdmFYQmhhbTVrZG05SGRXcHpZVFJKU0ZSTWFHNDJP
      U3QzVWs1SlprVjNPVXBSTDNwRU5TdEVaMDFhZVdsUVJHeHVhbTgxQ20xTFFYYzFkbVpZUlhSek5s
      UkVOWGhHWWtwNU4wZHhhblJVWkRCWk9HVkxaeXRPTTNKemNHVk5OME5xTVd0dlIyUXljVk5JT1U5
      UFRUQlFOWFo0WjBjS1JXbEtMMFZ2Y2tkVFRrRldOV2w2VVdST2RtNVJaR3hFV0RoUWVXSktaVGsz
      ZG1wRVJIUTJabkJ0TTJOR1RESjRWREZuYlhKbGVYaG1OQ3RsTDBWTFdRcEVObTF5T1haa1UwMVBW
      bXhQWjNWemNqazRZMWx6TUVGQ1lVTTRha3RtU3pSMWRGUkdVWE5TT0cwNWRHbFRTRUZ3UkV0R1Ju
      TTVWM2MyUW5vcldTOHhDbkpGUlZGbVlscFVjbWhsUlRCWWFIa3ljMnh6VmxkdGIxcHlNRzlGVERC
      RVFqRktVa2hMWnpKb1VYaGxRbGx3U1hCT2IwNXhRbkJ6YUZWYU1uQmxhMFlLTVZaRk0yUjRlVmha
      SzNSNVIyNWxTakZPYkhCelNHUlpSV3g1ZW1vMVJTczVWbmxGWjNSWFpWSk5NVkkzWjAwNFQxQXZV
      VWhMVTNGRldrVnVMMHd2T1FwWmJrRXhZbXBDSzBsS1JuSnlRelp2UzJwSk0zb3hjMmhUV1ROblJt
      dDJkMWxNTUZWalIxUkRSMVJFTlZGVmFXTk5TUzl3Y2pBM1ltMURWa2RXZVcxYUNrdFZSR1FyY0hw
      V1UyRkhXazFqY25wQ01YSTVhRm93WW5kSE9FcHZaVXgwVEVsc2FtVkRUMjEzSzFvclUwdEhOR0Z0
      TlRGbVkzTnBiME5yVUVwRmVuRUtOMFpSYkZCbmR6SnlXVWx2Wm5GbmVUTnBiVmxITTNWWlJIRjVU
      MnBGWm5vNVJEbHNiblpFUlRWTll6WlFPVlEyUmxreWVYWkNXbkZEUjI5V04xbHJSd3AzZW5oQ04y
      dHFiMDl2ZUhJM1UxbzJSa2hLVFFvOVNuZFpVUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Check if watch rule for /var/run/utmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/run/utmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Add watch rule for /var/run/utmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/run/utmp -p wa -k session
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Check if watch rule for /var/run/utmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/run/utmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information utmp - Add watch rule for /var/run/utmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/run/utmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Attempts to Alter Process and Session Initiation Information wtmp
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_session_events_wtmp,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Process and Session Initiation Information wtmp
  hosts: all
  become: true
  tags:
    - CCE-86203-7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-12.1(iv)
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_rules_session_events_wtmp
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SXJRVkF2TUZaWVJrTjROalJrVXpkd1dGSmlWbkZ1UVRCSWVYZ0tlVU5aWjBJM0wyZHBWa3R5ZUc0
      dmJXMTRla0pHVVdjeFlUUlBXbTVKT1hwVk4zUTVaMDFEUlZOV1UxQkhNRFIwVDBOWVoyRTRhVVYy
      YmpKalJEVk5NZ3BQWTFOSGNuWjJXRWhSTjJSTlQwOUlZMnA0TldWc1FXMDFiV1l4U2pSMlZpdDNh
      ekJEZVhaQlNsTlNNRkpQWlVSVVlVY3JkMnhXUlRkS2RHdFlRamxaQ2pKbVdFeDBaRTFHYVZKNmJu
      UnRaV1ZEYWxKbFlsSkhZVWxuVURKclJtRnVkRE5MSzA1Qk1YQktMMWRLWldWSE1HcGpkazVvYTNn
      eFpGcFhZbXBtVTJnS2JIQTRjRkIyYm5kVlNFeDJSa0ZDUlZKWFFXWjFaR3hKU205UFRUbEtUa1pp
      Wlc5YWFVSkdabWhwTjBOWGNreHZZbTV3V1Uxdk9VUlJZV3B4VDFWRmRBcFJlVTlMVms1cGVUQmFV
      Mjl4ZUhKRWExaENRak41WlVGUldHbHRPSE5aTnpCT2FtWjVRbEpITjNGMGIzQmlSM1V2WlV0bldF
      aDJlRFJ3TWk5elVrNWFDalZqWWl0Q2FHWklPVUpIYWxCQ1NreFFWQzlRTWxsS2MwMDBUbFoxWlM5
      R2JYTXZObk5wUW1ONWMyMWhZV3g2TDJkcE5FcHpWRGhCYWtscFlYazJaR2dLYmt4ekwzUkNUVEox
      UWxacFZXVmxNRmhGUm1Vck1VMUVNRTVIV25jdmFrMWlkekJtY1ZCSE9YWTBPVFZNTkRKb1lWYzJi
      a3hOVFU5cFMydEhWVlZCZEFweFEyWnNZakp3ZWpkdVFXeERLMFZFTkZSMlMwOWpNbW8ySzNsTlVG
      RjNZeXQ0UTJ0UFFsTXJURGcyTHpoelRuQjBVbWxSTVdoTWVua3dPRTFwTlRoNkNuVktWVUpUWjFB
      d0wwaFpTRGwwTmtoRGF6UmxNMkZJYTA5SWIxQkpVWGxuU1ZKaWJtWjVLMWREYldkWVRuUkJRMUYz
      WTBOTFJGbDFha1p1Y25KMGNXUUtkV2hGWVRKWlVtOUlNMk5yUzJoNGNrRXJWMmxrY2pOeGNsZFBk
      a2sxV2pWalRuTkZPV2xTTVVsS2JsRTFTV05DV1hrelpTOHpPRFJuUlUxSGRpOW9RUXBMYm1KTVJV
      TnFLelZPTDFwc1ZtSm5hV0Z3ZFFvOVNUQkJNUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Check if watch rule for /var/log/wtmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Add watch rule for /var/log/wtmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/wtmp -p wa -k session
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Check if watch rule for /var/log/wtmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter Process and Session Initiation Information wtmp - Add watch rule for /var/log/wtmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/wtmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events When Executables Are Run As Another User
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_suid_auid_privilege_function,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events When Executables Are Run As Another User
  hosts: all
  become: true
  tags:
    - CCE-86368-8
    - audit_rules_suid_auid_privilege_function
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      Um5ZMUF2TW1JeGRVdzJiV05aTmxKcVprNVBjRmt5VERSUU0xb0tVbVJZVTBaak1XZzVVSHBUY20x
      cU5ERkpabGR5YlZCb1UxUlNVVFpsY0RRMlNEaGFLMVZaV1RaU1RucFlMMUJyVWpKMk1GTlFWMUIx
      YkRsV1ZtVTJNUXBJYUhWNldHSmFPREI0U1hCbk0zWlVhbWhpZFROSFNqUnNRMFJFYm1ObWRWbHdR
      V0ZCTDJjeWNGbHdNVzkzUlU1cFVXTXlTM1k0ZERoSGNUVnZjMHByQ2xGSlRFTlNVRkpGTkZsM2JX
      ZENlSHBuVm5CeGQyOXNkR050ZFcxUFVXeFZkMWc1UWpOdldWYzRTM1pTYzA5ek5IVXdZMFZuVVdO
      NlVtSjJjbGgzVFdnS1dFOURkQ3RpWTBSVFdVTnlXbFYxVkVoMk1sTjNZMDVzYW5aTmRYaG1kR2x4
      V2tGMFVqRnhZM3BIZGpkeGMzcG9jM1pVT1UxRE5EbGpNM2gzWlRWa1Z3cGpObmRyYzJNNE1VWklS
      RWhGUjNCTGQwTnFhR2RNWkRSb1dISnFWeXRTZFhOR01HUTNjbkUwYkUxV056UkdVbWRqVEhSTEwy
      eFlVRGhLWkdKSFFWaFlDbXRhV1ZkemFGTm9TbnBWYTJreEx5dDBhak5MTW5SUmMyNVVaR1k1VjJa
      RGJDOXVjQzl2YzBWV1JHYzFaVzUzZGt0bGFucEpWalppU0M5WmVIZDVTRGtLYlhVeGIwbExkbk5Y
      ZG5GTlNYUlZNV1ZsUkhkeVFuaDRXSE5WVjJsU1VXcGtWVlZoUVhCRE5XRXZRMHBMTWpKaWRXVk5Z
      a0pSTVhSMkwzWTNjMUpDT1FwRlJGZzJjak55V2tJMVJIY3JaVGRYTjBwRWRrRmhjWEJtWkdSMVFV
      aEdNbnBhTjBzM05XaFhVMUV4YkVaMWJEUXZRV3hyVTJNemFrdEtSQzg0T0RRMENqZENjbEZGUkRa
      MlNVUmxVMVZSV0RaVFUzQlBOSGN3SzB4S1EzQlRSa0pVTlRSdmRXNTZibk5VYVZBeGVuQnRaMjh5
      U1dselRFVk5ORTlxZDFkSE5pc0tSVTk0TkdsSFNIRlFVRzFQU2xJemNuUm5WMUpKZW10UlNEWXZj
      bUZQYTBacVZFZHVTelprVkd0VVJVaFBTM05rVTFwVVJUVjNhVWxpYWtJd1kwbGpNUXBJU0ZsWE5H
      OHJPRlp1TVRZMlRFTnlZVXRKVlFvOUwzUXpLd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Service facts
      ansible.builtin.service_facts:
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Check the rules script being used
      ansible.builtin.command: grep '^ExecStartPost' /usr/lib/systemd/system/auditd.service
      register: check_rules_scripts_result
      changed_when: false
      failed_when: false
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Set suid_audit_rules fact
      ansible.builtin.set_fact:
        suid_audit_rules:
          - rule: -a always,exit -F arch=b32 -S execve -C euid!=uid -F auid!=unset -k user_emulation
            regex: ^[\s]*-a[\s]+always,exit[\s]+-F[\s]+arch=b32[\s]+-C[\s]+euid!=uid[\s]+-F[\s]+auid!=unset[\s]+-S[\s]+execve[\s]+(?:-k[\s]+|-F[\s]+key=)[\S]+[\s]*$
          - rule: -a always,exit -F arch=b64 -S execve -C euid!=uid -F auid!=unset -k user_emulation
            regex: ^[\s]*-a[\s]+always,exit[\s]+-F[\s]+arch=b64[\s]+-C[\s]+euid!=uid[\s]+-F[\s]+auid!=unset[\s]+-S[\s]+execve[\s]+(?:-k[\s]+|-F[\s]+key=)[\S]+[\s]*$
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Update /etc/audit/rules.d/user_emulation.rules to audit privileged functions
      ansible.builtin.lineinfile:
        path: /etc/audit/rules.d/user_emulation.rules
        line: '{{  item.rule  }}'
        regexp: '{{ item.regex }}'
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - '"auditd.service" in ansible_facts.services'
        - '"augenrules" in check_rules_scripts_result.stdout'
      register: augenrules_audit_rules_privilege_function_update_result
      with_items: '{{ suid_audit_rules }}'

    - name: Update Update /etc/audit/audit.rules to audit privileged functions
      ansible.builtin.lineinfile:
        path: /etc/audit/audit.rules
        line: '{{  item.rule  }}'
        regexp: '{{ item.regex }}'
        create: true
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - '"auditd.service" in ansible_facts.services'
        - '"auditctl" in check_rules_scripts_result.stdout'
      register: auditctl_audit_rules_privilege_function_update_result
      with_items: '{{ suid_audit_rules }}'

    - name: Restart Auditd
      ansible.builtin.command: /usr/sbin/service auditd restart
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - (augenrules_audit_rules_privilege_function_update_result.changed or auditctl_audit_rules_privilege_function_update_result.changed)
        - ansible_facts.services["auditd.service"].state == "running"


# Ensure auditd Collects System Administrator Actions
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_sysadmin_actions,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects System Administrator Actions
  hosts: all
  become: true
  tags:
    - CCE-83729-4
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(7)(b)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.2
    - PCI-DSS-Req-10.2.5.b
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_sysadmin_actions
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      Rm1VVkF2YVdvMWFVMXBiMjR5YVZwSU5ucHpiM0p3ZWtwcVQwWUtUM0ZxSzBWcFpWVndXRkJwYWxO
      TmVFaFZRaXRwZVc5RVoweEZiRkp6Y1dGaGIwbE9NbUkxVlhCMk1FOVRWVkp1Y1hoQmFsSnVkblUy
      ZFVKNU5rNXVNUXBwWmxKcVdHTm1iSGxWVkdoWmVWcDFVR2RUUm5kVlpGbHVhbk54VTB4NVNDdFJj
      elkwWjJJeFlUQndLMGhaU0drMVIxVnJlRkJUYUdoUVluWXdZM0ZOQ25Gb1ZFaHNRWFkzUzFad1pu
      WlBOVXhDZVhaelFreG9Sa3hRYVhwUmMzQnBORXA1TDNwdE9WVnhORWg1TUhGMFdXVklaa1ZaYWsx
      bmR6TlFPVWRNTjFrS2MyTktLMFY0VkhsU1pWWTJXRloxYkRSelpVNHdTbE5tYUd0alptNDBjbkZv
      UkM5Q1QxSm5OMDVPYkdaV2VtaG9PV2tyVUVFeVdUUklVVEJxWkd0T1Z3cHNRa2xWVm5JNGNXZEdk
      MnR3TTBaVmJ6STJaWE5wU0RVek1VbDZVa0ZuWmtreFdXODBWV28xWlRkTlVtdFFjbWRSWTJ0S2FH
      WnZhRWh6TjFoRmVUZHlDa1pXV0dkUFdGSjZWWEZrVmpOT1FsUXZlSFZIZDJsTk5GRlJNSGN4TkhG
      dVJWWkxWa3BYTUZVeVRXSnJSMDFWYTB4RmJXMVZZelpIWWk5blJWbFZRMk1LWVhjNFdqTlFjMFZ2
      WVVzeFlVcElMM3A0UldrMGFHbHdXVTl2VWpOUFVHaDFWak5RSzI1cGNrNDJVMlowWlZwTVYzZFdi
      VEpEY1ZneU5FRk1ja3MwUXdwWFdHaElNakZvZEVoUWIyRktTWFpXUnpoTlJ5dDJNRmsxVDNBMldt
      eGlaM2htVFZKUk5ETXdhMWRuTlZRd00yMDJTblZKWlM5RGVIRmhRMnBYTld4TUNuaFVibW8xVkdo
      S2VGTXJWbmRaZFdjNWNrWk1NeXR3TXpkUFUyczNNRzFpUjNOaU16bDJhVEpTYjBORVkxbFRMME5x
      Y0RObFdFTnFhbkJ1YUhkTE1Xd0tSVzFrZEVoVFlUaDNWVFIwZEhFelZFVlFiMWhQU21Odk4xTkZT
      elV3Wmsxd1dXeGpWRlZRVm1WcU5Ua3ZVVVpLV25GSk5uSnBZelF5TTJsS0wwMU5OUXBGTjNwQlZX
      bGtWelJLVGpKNE1tSXdlVTg1UVFvOWNtdHBWUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure auditd Collects System Administrator Actions - Check if watch rule for /etc/sudoers already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/sudoers\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects System Administrator Actions - Add watch rule for /etc/sudoers in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/sudoers -p wa -k actions
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Check if watch rule for /etc/sudoers already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/sudoers\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects System Administrator Actions - Search /etc/audit/rules.d for other rules with specified key actions
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)actions$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Use /etc/audit/rules.d/actions.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/actions.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Add watch rule for /etc/sudoers in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/sudoers -p wa -k actions
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Check if watch rule for /etc/sudoers.d/ already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/sudoers.d/\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects System Administrator Actions - Add watch rule for /etc/sudoers.d/ in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/sudoers.d/ -p wa -k actions
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Check if watch rule for /etc/sudoers.d/ already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/sudoers.d/\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Ensure auditd Collects System Administrator Actions - Search /etc/audit/rules.d for other rules with specified key actions
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)actions$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Use /etc/audit/rules.d/actions.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/actions.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Ensure auditd Collects System Administrator Actions - Add watch rule for /etc/sudoers.d/ in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/sudoers.d/ -p wa -k actions
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0


# Record attempts to alter time through adjtimex
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_time_adjtimex,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record attempts to alter time through adjtimex
  hosts: all
  become: true
  tags:
    - CCE-83840-9
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - PCI-DSSv4-10.6
    - PCI-DSSv4-10.6.3
    - audit_rules_time_adjtimex
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      cFdTVkF2TTFKR09HaHplR0ZGZERFelptWmhUVWxWU3pWSFVsRUtWakoyVjJ4YWFVMUllamR5YzFK
      NWVqRjFTblVyZGtGSVJIZHBVbWx5WkhFMU9TdHZRMnR5VUhCQmNVbDNaR050Y0daQ2VrSkhWVTV0
      UjI5dk16RXpSZ3BhZVZGbWRXOTRVRWhIV21KTVJDdDNNVzEwTVN0SlJscHphV1V4WWt3elVDODVS
      Vk5pTDBOdVRWWTFiV3B2VEV4WmJEVjRlRFJoU210VVdqQlBOVUpIQ2tOek5XMXlhM2RFUnlzNFJr
      SmtUemhvT1VkRFZEZFhhMEZPZEdOcVJpOVdkRkIwTm5kYVYzZHlhM1Z1ZGpaWWVXSkJNbmhRZDJK
      cE1EUmtZVGR3T0ZNS01XTTJWRmd6SzNwWFQwNHhhVm93U0ZKS1NWWmFXVXBMVWpVNU5FdEtWR0ZM
      VVVsdWNWQlROa3RVV0RJMlpsSkNPV05PZVcxb0wwNXdObGxHWmtoRGVnb3dLMnRZYWlzMk4ydE1S
      azFvWlZGb01HdEVjRnBGWjI1cWVrNWFjemhZYW1aSmNETXhaalV3V0ZJdmRtWkxNM05vTW5kRFVF
      VnBlWGhzVG1OSFltWlhDaTl4UkhSaVNGZHVkWGxzV1hkQlpuZzViVlpWTkd4dUswRnpSRTFHZERs
      aWFrNU9lRE14WjBGVVRIRkVWbXR6VW5CclQwWXpPRk5MTTA5Sk5tTkVRWEFLTTA5WFdDOHZLMGgw
      Y1ZGS1NTdFFaaXMzYmxVeWExQnVTVlZ2VTNGdmRGQTFNVGd6U3pCeWVtdEVLMnczVTJKak9DOVpX
      alZ6ZDNkS1oxVXdWMVoxTWdweWNGTkxiRE5XU0hOSmRHUnBlVXRIY1RkcWFqZHViVkJDZVVaMWRV
      WlZlR000TmxCbGVXSjBkWEZMVWxoQ0wweEhSMnRFZERjeVVqUlFZa2wwV1V0VkNuUTFZV2hSUkV4
      QlVteGpUV1F6U0dSa1FqZEJOR2RVVWpnMFMwaFdPSGxSVTFnMWExQnZWMlVyUlVSUVZIQlBWVnBr
      UjJJemVFdzNlbEl6ZFZwYU1XWUtiRWhVT0cxUE1tNHZTVlpXUkRadVRqSlNPV3gyYjBwVFZXMW9W
      a3RCYUhkcWVqSlhSV3RCZDJaT1UwaEZjMjVqUnpSbVdqQllOMEZUUW1kQ1prTXhkUXBrYTBReFZt
      VXpWakI0TkM5a1FrTnllREZNV2dvOVRVVnlVQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for adjtimex for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for adjtimex for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday

        - name: Check existence of adjtimex in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Attempts to Alter Time Through clock_settime
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_time_clock_settime,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Time Through clock_settime
  hosts: all
  become: true
  tags:
    - CCE-83837-5
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - PCI-DSSv4-10.6
    - PCI-DSSv4-10.6.3
    - audit_rules_time_clock_settime
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MDVkMUF2TXl0Q2VIWTBkMDl6U2xNd2RVczNSMnB0Ulc1S1ZtZ0tTMjlDWW1aemFUSTNjREV5VUhk
      MlJUSm1SRTlLV2pkdGNXMU9aRm8xYmpGclYyWlhNa3R3UjFwd1QwdDBSVlpWTTBGSGJuSlZNM0ZL
      VmpSMmRVUkdjd3BXWjNrM1NXMVJZbFYwYmt0Rldrc3hlbmcxY25GQ1FYUm9WMkY0TlRjNVZITjNk
      akZSYTNJMWRuRnJlSFJJVjFWMVRHUlBTVWxyWVhrME0ybHNZMmxPQ2pVeWRraG5RMUJyZWxCMVpG
      aHlTbTVTU210NWRrSlJTVWhVYW5VelN6TkhZbFpMWVdOMmVVUnFjbU51YkU1R2FscE5kbUZ1WlRs
      S1NUWnFaVmhsYlZrS2JITXlRWEZaWWpnd0szVlNNa1p5YW10d1pVdEZRa2h5TmxGcVQwVlRkVXBZ
      WjBsSE1VNVFTWEpuVDFWSlFUQkZja1l2WjBNNU0zUXplRFE1WjBka01RcElWbEk1VXpCdFYwUlFV
      WGszYkdjNFkxSk9lRTVJWkZOTWJqaElaSEpRU0RKV1RuTnljVzF2TldjNVlqbERSSFI1YjNSUFNr
      NWlSV2x1WkZkRlNGQXhDbGgzV0dObVZ6Uk1OemRrWnpWV1dXVXlRMmhVUWxGTmRYTkNNakZsZWtw
      SGF5OXRabkpQV25oa2EwMVpMMVU1Umpkdk0yaDFNRmhyUVdwdGNHZFJiMklLUmpKT09DdHhkVE00
      V0ZWUWRqbFNOalp0UldoWGFsWktNakZTVEdZelNrdDFaeTk0Y0VsQldUQnpkMDFaVVhGV2FEWlRk
      a2w0Tml0dFdGSldlbGcxZUFwU2RWZHdlR2hWYkdFMmFUaFhkbEozVVN0RWNtbFdZa0ZSVkVsTWRE
      WkhPVFE0V2xwVlZVSXZkM3B4Y0V4NVNFRnBZa1ZZVTFoVGQxcEpSalZXS3pKckNrVkNOVXd4UWpC
      d04wNUlZVE0yUVVaTmVqTlVaVlpKWmpOaWF6aFhTSHBFVlhadVIySnNNMUY0VFRJMlVXMTVkbTlv
      VjNZeU1uQTJTVTgxUjA1eGQwa0tkMUJMYVZWa1prNVJORlJqYnpVclMxTjZSakpUVGs1MlFucE1U
      akZUVm1Sa1FXbHlReXRFYnk5bmNWSXlhMHRoWVhsc1VWUlJUMFV5TnpWbk1qQjRTZ293ZURFdk5t
      SnVURW94VTFwVkwwSlVSalZ3U2dvOWVIWlBkUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for clock_settime for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules
          set_fact: audit_file="/etc/audit/rules.d/time-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for clock_settime for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules
          set_fact: audit_file="/etc/audit/rules.d/time-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record attempts to alter time through settimeofday
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_time_settimeofday,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record attempts to alter time through settimeofday
  hosts: all
  become: true
  tags:
    - CCE-83836-7
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - PCI-DSSv4-10.6
    - PCI-DSSv4-10.6.3
    - audit_rules_time_settimeofday
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      RlZXVkZCU2pSVU4xWnRNR0ZSTTJsSE5WTk5ibmRrWkhkTWNGRUtNVFVyTm5VelFXMXZSV3BOTTFs
      aldGVkNXRFJxY3poS01XRnFMMFVyYVdkUU5qY3paM3BTTTJsVmVsZHpObmhuWkZwc1owVjVTVXQ1
      ZW01bmMyeFRhUXBYYzNKQll5dFFaRzVGYVdkNlltMHpUMUJKZDNNNVRqbEVZVkpJY1ZKdmMyRXdj
      VGxNVmtFNVIzZFBNaXRzZGxreFdqSnBTME5zZFVOdk5sWlRTalJCQ21kNGFFTkNLekYyV1RGRFEy
      UmhNVEpzV21KQlJYbEhSR00yV1ZkRUwydEpaVzFyZUZkaGFFVk1URzh4V0VSdGFrVmFXa3dyVTNa
      eU5ETnRjMlU1TW5RS2QzSlJWSGRyVTNJeU5FNVVRVFozYldOSU0xWmhjVU5qWTJOSWJuUk1UVE5K
      VEZSdVZubHdLMW96VEdaTFptTlpWRGxxVlVZMVRHSkZUVGhxTm00dlN3cGFUMjkwUWtZdk4wZGpN
      VlZZY0ZGamJrMTJORE14WTNCWk5EQnVNbEpJYlRrNVUwVTNSRUZCSzFoV2RYTjNOblY1TXprNVFt
      STNNRmxQVlRneFVsbEtDbG92U1dRM2RtTktZVkZzU0c5WWFHNVFaakVyUzJVcmVHNWlPVll6WjJ0
      Mk1qTTJXbnBpYzFSR2RtdGxkbEZGY1RGTll6a3hhMVZOTDFCQ1p6bHRNMDBLVVdOMVJqbG9XbWho
      TVN0R1JGaElhRWhNUjAwNWNYTXJNbUprYXk5eVZUWk5kVVpYUW14alZsTnFkVEYwWWxwWlduWlVL
      MUExTlRrd0sxSnhSRXR4THdwRVl6ZGpVM1ZwU0cxVk0zRmFlVFZ5TUhaemFFVTFOVzl0UzFkSGJ5
      OURTa2RTT1hsUVdtSkVPVTFYTkV4eVNUQkthU3RqY25WNFdDOTNkVWRKVDB0akNuaERLM0ZrVjBa
      bFdYcEJiMVpJYUd0dVVIRkxiVk5UYWtjMVkwZFZWbU15Y2poVmFuWlBTVmwxZWt0eFdWUTRMMEpw
      TURBeWFXeHRiemM0VGt3M01FWUthV3dyWkROUlVtMWpjbEp6WjFSU2RsZDVORFozVlhCdk9TdDZN
      VlpOUkc1UGNFUlZkMVJTUm5aYVRWbHpOVWxxTjAxeVdtRmhTMUpGTldNcmRFcHpSUXBNVWxNemVX
      eFdORlpaVFRNeVRXaDNlVTVOVXdvOU5uaEpVUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for settimeofday for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for settimeofday for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Attempts to Alter the localtime File
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_time_watch_localtime,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter the localtime File
  hosts: all
  become: true
  tags:
    - CCE-83839-1
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - PCI-DSSv4-10.6
    - PCI-DSSv4-10.6.3
    - audit_rules_time_watch_localtime
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      VTBjMUF2TTBneE9FSjJVbGRxYVhkQmVHSmhObGhIWW01TlEyWUtMMGt2ZVUxcFJtdFFkbXhpTVZr
      MVFuY3hkWGxQVTBkbFdGbHlWVEpHYjNrdmVuUjNhREZoVDI0clUwc3hVbUV2YjNGVVR5OHhXbUZz
      ZGpSVVFreDNVQXA1YUZkbksxRlhaVXN5YVVWV1ozcEdNRGxxTDBnME0zUXlMME01Y2paVWJIcE1W
      a3AwVmpoek1IVlhOVzg1UlVaS1ZsTTVaV2hoVlVkWmFuRnlla2hxQ25keVEyVnlTRFZ1VmtSRFIy
      bzNWa2xHZVRsd2F6UTRia3R6TkZGb1kxVm5Sbk5JTUV4WFJUaHJVMUZ6TVRCV2FHUXZPQzkyVVZk
      a05XdzNXVVZoVlRZS1pYQm5lWEZDVVcwMlVUUk9hbEkyVmxSRFQwcFNkRlZhT1dwUlZFSjJZV0p2
      VlVsREwxcEJUMnB0VUN0MFVta3dURmxxZGt4RFpVRklOR3hyVUhWRmNRcEdaRXRhUW1GSFpqVjRh
      R1JMZUUxclZVdGFVMmM1ZFZCT1kwMXFZME1yZVVGMk5FSkNLMUZvVTFsVFJpOWtNemhXYTBkQlNX
      SlhNV1pqVkdFdlMxWnBDa0pTVEd4Rk5FeDJLMFpQUW04NVRXRkRXRzluUkdSaWQwWndaVzF2U2tK
      TGNUTnNPVFl6Y1ROd1IwTlNjMkpHY2t4MlFXWlhRbTFhWjNack16UnBVa3NLU25jME1FZzFjV0Zx
      YURab1VGaGtXbHBtVUUxbE9HSlNkbWR0U25kVlEwMXJNbUZ6U2pabGNrTmxSbTFZU0M4NVNXVkNR
      V2QwSzFCRlEydDFZemxtZHdwQ04yNVBabVZ4VmtWTFprVlRVR1JrVUZKRWJqUlhlVlpLYXl0WldF
      UkRhMVZQYVRCQlltbzVaa052T0RsUWVsRTBOekp3WkhZMWR6RkNXV1k0UWpOeUNqTTBOMDFoWkVw
      YVZHbGlUMDVTU21kTUwwMXZabXN5U1Zkd2VISk1SRXBPYzI5MVVETmpVRWR0TVhWVWFESXlRM05y
      TkRCWFRtaG5LMkZWVTB4a1MxTUtXbUV5UVRObFJqVjROemRPS3poSVJuWlRlVUYyWTJ0blZFOWta
      eTlOYVZOdWRqTXhXbWxwTlhOV1NEaFZPWGQyUzNRcmQxTnpZbEpxTUhVM01IUTVTUXBaUWtSNlYw
      ZHJTV3d5YzI5RE9UTnVjR1I2Y0FvOVJESllhUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to Alter the localtime File - Check if watch rule for /etc/localtime already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/localtime\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter the localtime File - Search /etc/audit/rules.d for other rules with specified key audit_time_rules
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_time_rules$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter the localtime File - Use /etc/audit/rules.d/audit_time_rules.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_time_rules.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter the localtime File - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter the localtime File - Add watch rule for /etc/localtime in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/localtime -p wa -k audit_time_rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to Alter the localtime File - Check if watch rule for /etc/localtime already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/localtime\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to Alter the localtime File - Add watch rule for /etc/localtime in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/localtime -p wa -k audit_time_rules
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Unsuccessful Access Attempts to Files - creat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - creat
  hosts: all
  become: true
  tags:
    - CCE-83786-4
    - DISA-STIG-RHEL-09-654070
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_creat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      WlpVVkF2UVRKT1NHVnBNbkJETlVodk1DdElZMmx2Vms5VE1Fc0tRM2xGVFdNdk9GVjRPV056UzNJ
      d016QmFNbUpEUVhwTmVubDNXQzlNUVRrMmVGUlpabUZJZDA5TFdHc3pkbmxsT1V4UVExRktRMEpR
      U21SQ04wSTVNUXBJT0dWM2NXc3pWRFkxUVdjNGNubHlZbmxFYjJ4Rk1saGpURkZyV0RNMWFESjFk
      R3BWUXpKcE0zaEtUMDlPZFZnd2JVaGxORFpsU1Vwd01IRlVOVkJQQ2xweFVERTJSVlZ4VDFFeWVq
      ZGFNRUV3VFVWNU0zTjFNMHRhUW5KTVVITllVSEZsY0VsRU1sWkRVa2R6TW5GaFEwcFRWazlMTHpk
      YVVUVndRMk5qZEVzS1ZYRTNVa2t3ZFZaYWMwdEZlbkEyTXpkVlRXRjBjbWRpYUU1dmRXMXNaVTVy
      U0d4TWRFWTRaRlpCYkc1RWRFNWxZbVJtUTAxRGJXNDVUak52V21wUlR3cHpPRms0VmpJNFRuUTBS
      MHhVUlRSd1EwSllPVEV3WTFCWlNFVTBTVTB5Wm5wSmJFcEZUbWhpVnpkWVNFRlJURlJQVTNjMGJU
      QlpNSGRNYUZsb1lVbG5Da2x4VlVWNU1XcERPRVpQZEVORlIyZElUMHN5Y0dKSVpua3lPRzA1VjFw
      VE1rSjBTa2hIWW1GSlVteDRiazVRWkd0UVUweGFNVWRPWjAxTVlqTjNNV1lLTWxoNmVURkhkSGxr
      U2pGc1lteGlWbFF5TlhKWk5sSmpUbU52VGxkMFlWUmpTWGhLU1ZJd2VVVmxRamcyYVV4T2VrWnlR
      MDExWWtSelVuTnlXa2xzZEFvdk55ODNkbTF4YkVsNlJHZ3hVbVpMVXpKMlVHRndVRnB4WmtOTVND
      ODRPRlI0WjBKM2VrNUljRVp4ZUVGWk9IUXlTMlJrYVVWTGMyRTRRalpYVHpWWENtZEtlWFE1Vkcx
      TE0xUk5NbU5rUmxGRU5XRjFjbVZDVDJNeVkxWlFLMWhLTlhoUlkwVXpkMDVRWTJOclVrZE5SMWxz
      ZWpkVmFGSmtUek01V1ZsV1ZXc0thRlJrTVZscU5GUjRjVGRqYjFWd1owVTBWWFpoVEVOWFNYZHNS
      R0ZIWkc5VE5rRkJaR2Q1YVZvMmJFZzFhM1ZRY21WalluTXJVa0lyT1hCdVExSTNjQXBtY0hGVVUx
      VjZaaXROTUVkSFZIbFRPRXBMZUFvOWEyOVJZd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit creat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for creat EACCES for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for creat EACCES for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for creat EPERM for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for creat EPERM for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - ftruncate
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - ftruncate
  hosts: all
  become: true
  tags:
    - CCE-83800-3
    - DISA-STIG-RHEL-09-654070
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_ftruncate
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      OXFNRkZCU2s1ek4zZHdPQ3RUZGpaclUycFdZVk5XY1doS2NYUUtXVWwzTkhGbFdXWlNaV2s1VVdr
      MlNEUkRTRzlUWjJsRFFsQTNXWFZCTm1oS1dqZzJUM05tYVVwcWRFMTNWM2xpVldoVE0zUktkMjU2
      Tm0xVGJXNUdTUW93YlUxYVF6Z3ZNbmxwVTBVdldIWlViR1J3U0hwNGNXY3ZlVmhHY3k4eWJuaFFO
      VzlRYVdodFJHaGpOV0Z3UW1aaGMzUTNURFpyVHprMWVrRjZSR016Q2toRVRUWlNRM1kyYmtZdlNr
      MDVSM2RrUTB4cGVtcEtaSFEzYkVSQ2IwY3ZhM0ExZFdSc2FGWllLMWw1U0dFMVJXbHdNV2gzWW1K
      MU1Vc3dWbkptTjA4S1RFRmhPWE5OWm1ab1JVWXJOMHBRUkRWU1kxWm1TbEJTVkZoWVNWQXhOakZN
      T0VkeFNFUTVjV1pRT0hSNGIzUlZlRE12VDJ4eFoySmlOMFEyUlhwM1ZRbzVPV1pwZEdkd1JrNVdT
      RWsyUzJ0UU5VTnZVMFJPUXpVM1JVb3pURUZXTWtOUFIwcDFXRmxCVVhoVFExUnBaVmhOU0ZCa2Qw
      bElXRGs1Ym1oeFRDOHdDblpNVGpjM1VXMWpNRFU1WlhCUmJGSk1ibFJpVTNrNWJ6SkRTV2hHVDJ4
      Q2FGUldaR3BxYjJsdmNFZHRjMlo0WTJKWFVVMVZNWFV4UjJzMFF6SjBVVk1LVjIxak9GRjFjbGx1
      U2tvMmIxWlJaUzlVYzBOSFpGUmpkVGhEV0RCclJEUmlUVEF5Um10SWJuUkxPV1JLY2s1elFUaHJO
      MnROTUd4dGJHWnJRMDgzYkFwMVUyZDVVVVo1Y1hkcGVrcFZLM2xtUnpndloxZzFZMFpzV1dORU5G
      UXhhM3BCVVhWSlVETlNWeXRWTkVsUkswaE1ObE0zWWxCR05XcEhObTkyUkU1ckNsaHpRell3ZVZw
      MlNqSnRlV0ZTU0VzM2RVMU1TR3RrVm1wWFRTOU1VV0Z3VkcxSWVIZHFaVlZWYW5vdlJFVnJXbEJS
      Y2tsM1pHVlJOMFJMUW1SM1pWWUtLMFpHYjBGYWNGRlFZM05XVTJaTU5tWklZMWRhWWs0MFdtdGlk
      SEZSY3psaFNGWTBVRTk1ZW5BcmQwSkZXVGsxTDFOTEsybHpiRTFKVmtjNGJWbDVTUXB4TkZkRGRV
      MDRTbE5CSzJGR1pHRjBTMXBCVUFvOVEzUlpTQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit ftruncate tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for ftruncate EACCES for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for ftruncate EACCES for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for ftruncate EPERM for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for ftruncate EPERM for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - open
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - open
  hosts: all
  become: true
  tags:
    - CCE-83801-1
    - DISA-STIG-RHEL-09-654070
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_open
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      QTFjMUF2TUM5TVV6SXZhVXMxY0VOTFNrbDRkVFp4UkM5dE9Tc0tVemhHVFN0M2QydERWbXhyYmtk
      ME4xTk5UMUV3WTBWeFNVUlZiREF5V25CSWJFVklUR2RZWm01bVppdEliVFptY1VSaVVGUlVXRnBH
      VFVWaVdGUnljQW80ZURKSGJVcHpablJGVW00eU9FVnVSekEzUzFScGRGZzFOVkZ2VEVKUWJHeGtN
      VEZMV1VGa1NtNHZjSHBzTkZaRVZtSTRkR1Y2VlRZMU1ETmtNRkJhQ25sSmJuZ3JlRVZTYkd0RlYz
      RnRWVE15T0ZoMWNFdEhWa1Z1WjFGdWFEWkdNbVlyVGl0M1drUkdUVFZOTXpodmRUTm1kalJyYjBn
      M01GSjRjbUZhVHprS1JsSlNZMW94WW01U09ETk5PRVpxYVZCTFpIRjNjSEkxZVVOR1IzZFNWRFE0
      ZGk5QmJWQmFSRzVaV2tFd09ISlpMMnhLZDBaS01qSXpiVmhZTW5SNGJncG9Xa1k0SzFoT1lVdFJU
      VWRQYlROcGIyODVRamtyY0U5VVFrdGFaRlFyWnpsSFlVdDJielpuYkN0TlpEQlBhRVZIZEdORU0y
      TjNVMWxtY0dkck0xRm5DbFpPU0VKd1VFdHdUamQ0UjA4NFoxRTVNMDUxVldkUk16SmhPV1pLT1d3
      eFozZFVaRkJ5Ym1VeVNVaDBXa0o2Y2toeFRWTnZNMFk1V2xCNWMwbHpWMGNLU1ZKNGRrSTRWV3RV
      T1VrME5taFJORmhzYjJ3MFQyUnpLMkpzYW14TlUybEJUVUUzVlcxVU9FcG5VbVZ6UzJoelUzRnhN
      Qzl1VW1KTU0waDBRVmxoZVFwSFVWbHlXREkwTW1Ga1pWSllTRzB2UzB0TVJtTlFhRGhwV1V4dlRF
      TlRRMjFqZERKT056UkdLM2hEYTA1RFRISkpSbVl5VXpGUWIxUjBjR0pLYVZabUNqUnFOMmxDWjB4
      SE15dE1iR3czWlZoQk5FcHlUMDFDZUdaVFNIbFRXQ3RpZFVzMU1WZDROamQ0VjA5blptVlNSMGRw
      Y0ROQ2ExWnJTbXhGVDNoQ05VVUtZMGRaYzBrdkt6a3lVblJwVDNSTFZHaHNOVmx6T1RBMU5VUlFj
      bnBIYUcxc05rRk5hRmhxY0ZKT2NVZDRiVmx3T1haVlFpODVXVTFwY0dwa1kzZDNjQXBzT1VaS05E
      TTVMelJrVW5WT2IyeFlZM0ptVmdvOWRUaENZZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit open tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for open EACCES for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for open EACCES for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for open EPERM for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )

    - name: Perform remediation of Audit rules for open EPERM for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - not ( ansible_architecture == "aarch64" )
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - openat
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - openat
  hosts: all
  become: true
  tags:
    - CCE-83794-8
    - DISA-STIG-RHEL-09-654070
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_openat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWldRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      aGpVVkF2YWtoRFUwZDVOamR2VUZwT1dVZG5VQ3RzT0RKRmFrVUtRbk5XVEhabloxZEllR2RyTkVG
      dllXOWljRzl3T1VORk4wdzBaVXhHVDNaR1ZqVXdZekZXVEVkM00yOXBSMlpRYmpSV1FtOHJOWE51
      YXlzNVpsWnNWUXBsTW1oUFNucG5XbkJvVEZaaGQwOWxRM0o2ZUdSQk1uUkpXRGxSU25Kd2VIRnJj
      bFJtVVM5dGJWYzFNRmx3WVRsRU9FZHVWMGMwV2tac1YwTlpNMmhoQ25oeGQwNUljV1ZGTldKeU5t
      NUhaR1V2TmxSR1UyMW1RazV2VTA0ek1TdGtlbE5NWkZkcFV6SlVjVGd6T1dGU2FXTnhiRGxMUkM4
      Mk9IWklaMlp2VmpBS1JVWlJjWFZvYm5wNmVqaGxhRWgzUTBsbWVFUm1SbUZoUnpGbEwzVXpkRE5L
      YkhGWlEweGlVMW93TmxrNWR5dFRVSFkxVjJKRmJtNVZSSGM1TjIxMVJRcGxWRUpvWlZCRll6RkRi
      bEZYV1VWYVJtbFpaMFpKY2tOT1ducEdXRUV6YjI1dVJ6RnRWRGREWlM4dmJtaFRPWGdyYm5kV05F
      aDRNVmQ1T1hWTVJUWnZDbWwyWkUxdWRWQlhiVWxtTlhVMlVYUnVSVEpEYzJGd1NGUmhaMEZ2V2pO
      bE1tc3JRV3RSTDNGRVRqZzBXVWQ0YVVkTVVrRTFWazA1ZUc0eVkxTndVbGtLVVVNclNraDNOamxy
      VFVWYVkyOUVlR0pxYVVkdE1HdEtTREo0VjB4TVZVUlZOV3R0WlVsblJETnBiWFF6VG1SM01qTjZO
      VTB2Y20xaFV6RnlNbHBHY1FwSmJUZHlOazl0Ylc1R2VFdFZOakIxTHl0TU4xTjNORzVWV2poMmNX
      MTJaMFpEVW0xWVpVVXZiVVkwTmt0amFsVm9VSEpOTlhWQlZFUkRVekpRZEdGckNscEZjVTB4WVZs
      bU9VTlFjV012WVRsR1QxZEZlRmQyVmtseGNXOXJkRnAzVm5WNVoySjJZbkZ6ZUU0dlQwOHZMMDVu
      TVhCRVNWbENXazVEZUVKWFVqZ0tNRzVwVVdoWU1tUmxNemg2VWpGMGRsQmpVR1JCVFUweVRsUmtN
      UzkyVlRkS1NVaE9iazlKYVVOUGFIQndOVzV4VUdwemQzcHFVMHBUT1Vkb2NXZFJSZ3AxWTI4MVUw
      eGhNVkZ1WjFKeE5XUnBkSGxLYmdvOWVUWjFSZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit openat tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for openat EACCES for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for openat EACCES for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for openat EPERM for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for openat EPERM for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - truncate
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu,multi_platform_debian
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - truncate
  hosts: all
  become: true
  tags:
    - CCE-83792-2
    - DISA-STIG-RHEL-09-654070
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_truncate
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWldRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      WTFVVkF2YWl0TVZuaERiM3BpVVVvMlNEUlRVMGhhV0dkVlpVd0tTbUl6VlVvek4yNUxiRFpCTjI1
      ek56TTBNV2xzU1ZocmJGbDJlakZXVUhBck5rWnpabE5hVWxCUmVVMUdNbTlDVFhObk5FVmxVakpV
      T0hSYWFuTjZiQW81TTFreksyVkxZMkpxTDJWU1ptUkhURTQ1UVRCbFVHWkpWSE5wZG5vMmNVVkZh
      bUppUlcwMllrZDNjVnB4ZHpOUmNqbDZiVnBRVTFRMFQybDFZMkZPQ2xka1EzRmhTRmhLV0d0dWVF
      NUdZVVl3YTFBeGRrOHdjSEJqU21ZMFRubE5SbGd4TUdwaGRtcEdiVEp4U0NzdlFYazFiMHRHYm5a
      TGQzSnRabk5WUVUwS1kzWXZXamRvUm10aVEzbGFhRnBTY1hKelRUVklZa3BxV0cwM1JVcHZRbVl4
      VW5neFFVeFZSV0pXWlhjMGQwSmhVbTlWWVZoWU4zZFlXbmRJSzJOb2JncHVWMk5UZW1Vek4waFBN
      VzlKU0RaMWExcFdXRkZJWm1aWmRXbEtVV2hzWWtKamVqWjZUMGhLZDJ4TmJDOVBWalZQV0RKbVdI
      RkxNMjFGTVZCcVptVlJDbWhxYVhka1VqY3pUbVEyYkV0MGJFMURLeXRUVW5VcmJVSlZiREkxTnps
      aFEza3lNbVZpZDBreGVVMU1jamR0YjJKR1lWcEZhalZHZEhWb0syUlNSRWNLZEdkWlVXUmllVWg0
      YTFZMlRXMUNTR00xWjBkMGNVWklURmxWTVZoMmRESjVVV3RaZEdReFpFbzJUMUpsV25rMU9DczVX
      RTAyUXpBeU4xSnRPV3RFVHdwT1RGbGhTRUZUYUhCMU1XVTFXVU5KUkRKM1ZISmhSVXh2VUc5U2FY
      UmpjVXcxUTBKVllqVllSMEkwT0hjclVVSlBSMDlhSzNjMlNERjBaakZYT0VOa0NtTldTVVZSTjBG
      VlJsTkNiRloyUjJaaFNsTXdVelJNSzI5YVdFNXNXRlJCVDJKeVdHaDJZM2N6ZGtGTFVFSTRhVzA1
      VEU0MlRuRXhRV1ZLTDJ4clprNEtMMlUwWldGS1dEZDBja05tUlhZNVdYZGlRa3BVUjJsNVVHTm1P
      Rkp1T0hOalRWVlZkMmxNYVZSVVpHcHBaRTlGTWswclYyMW1VekZ3VlUxV2VYQkdkUXB1ZWpoMWJt
      RlhNblZTWVZZclREWjBZMFl2VXdvOVZuQktNZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set architecture for audit truncate tasks
      set_fact:
        audit_arch: b64
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - ansible_architecture == "aarch64" or ansible_architecture == "ppc64" or ansible_architecture == "ppc64le" or ansible_architecture == "s390x" or ansible_architecture == "x86_64"

    - name: Perform remediation of Audit rules for truncate EACCES for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for truncate EACCES for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for truncate EPERM for 32bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Perform remediation of Audit rules for truncate EPERM for 64bit platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
            mode: g-rwx,o-rwx
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: g-rwx,o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - audit_arch == "b64"


# Record Events that Modify User/Group Information - /etc/group
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/group
  hosts: all
  become: true
  tags:
    - CCE-83722-9
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654225
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_usergroup_modification_group
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      cG1WVkF2TWxCWGVraFBlRzlpUVZOeVV5dDJjVXRUUVV4d09Ga0tRMVY1Y1ZGaVozSlhaMlJoVmxv
      elpqRnZNVEYzUVVoaVowOWxLMFp6YTJWaVEyOUVaeXRXYW5ORFVHUnZaM2haV1ZOMllXeFVjRlJW
      YUhKbGRHMUVVUXBoTkdOTkszRndNalE0ZDBOeE56TjVZVFo1VG05NlNtRjNPR1JNWjJsRk5UVkNO
      amhSUmpWeU1IbE9PWFYyUlhGdUszQnJPSEozVFhoSlIxWnVhWFIyQ25JNFFXaHNNMGRQUkhOb2RE
      SkJXbWRyTWxoV1FVNDFXR3hwVWxkc1IzTlJabmxGZG5kd1lTOTVaVlZ5TlZKUFozaG1aV3hOWTFS
      WFYwVXdZVEpCZURnS1YwdFJaVTlMTkdKcGJYSmxWMmRuTTB0T1pHVXlWa1JLZWsxSmVWaElPVk5L
      UjNsSlpVeHFOM0V5Ukc5d1ZVWmhNa1p1Uml0WldDc3ZUemN6WlRaUk1RcEZWSGRqVEc1WGNERXhX
      RTF6YzFwaE5VSlZhWHAzTXpCcFZHZ3pNMUo2V1RjeWJuSTRWRTlIUkdWSWExRlZUM0ppVGxRMlkw
      ZEpZa1IxZERkcmJFMVdDamwzYzFKNlltWlVMMUEyVFVKdWIxUkhZa2xEYUhwVGFIQnpUMEZCTmxo
      RE0xUnZOa2hzYWpGUGJGQjZkMnBKUlZvMWJHeEpVbE5YVFZCVlNYbzFUMmtLVEZKV1pFTTJhU3RM
      YTFWVU1UZFNMMmRRUTI5dWFtY3dWVXBITVRkT1ZrazJaMUJTTVVrelpHd3pPRTAzTkRaTGQyaHJU
      a1JrWkZJNUwwczNNREEyUmdwRGFsaFZhVUpKV1RJMVZHTnVRaTlvVTFseWJrazNObFIxV0dGRlFt
      bFdZV0k0TWt4WE5YWk9OR1ZIUTFObE1ucHlSMFZ6TkZGdVVrMHZSREo1UVRKVkNqTTJiVFJUVHpC
      SGFYbzJNbWRUYzB4T015c3dlbTVSZFhwWWFFTkpjRzk1V0ZOMk1YY3dOVWxZYWtGRFUwWjJTbWg1
      U1hsQ1ZreEpUSFpXVFV0c1lWY0tkRGRRVjNSNlJrY3liVXhxU1ZkamNHWlFhamREYm1WTVZEY3pN
      MkZEY1hwNU5IbHVVR2R1ZDI1bFQwSk1LekZwV0hNeFZUQnJka2hUVVVkTFozVndjZ3BTZVhoWkww
      dDRZa1JyUzBoa2RtSXhWMU4yYXdvOWNHNVRZUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify User/Group Information - /etc/group - Check if watch rule for /etc/group already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/group\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/group - Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/group - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_usergroup_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/group - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/group - Add watch rule for /etc/group in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/group - Check if watch rule for /etc/group already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/group\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/group - Add watch rule for /etc/group in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify User/Group Information - /etc/gshadow
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/gshadow
  hosts: all
  become: true
  tags:
    - CCE-83723-7
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654230
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_usergroup_modification_gshadow
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      aG1UVkZCU2tkelFtZEpNWGg0UjNKSVMwcENVMGhhT0ZkR1VEUUtTV0YzVFdWS1FtcEVkRU5KYjFs
      NGJUTndRWEZPZFZWdksyVmlOR0V2WkRsalJFdHJWRTVJVlhkcGEyaEJRUzhyYzB0TWNtZEZXbWg0
      TW14SE9VVmhkd28wTTBKS1dXZEdhbkZEU0VsdldHWjVNRE5vTTFac1ZIWmxNMjlDWkhkUlNsRjJT
      RFZ0VURSa09GUm9NSGRLUzJGTFYzcFpjRGd6YjBKeFVUaHRORVptQ21JMlVHUTBWalpoTW5Sa2Fs
      ZDVZMmt4VERCRWNuY3hjMEpYWlZwME5UQmtTR3BZT0RabEwxaFhUbHBNY0djdmRVWmxNRmg2VjBZ
      M1YwbEpNVWR5T1hZS1FpdDJaR0phU1RWWUwyVm1ZM1ZsZVdwSFJ6UnFOVVJZUVN0Q2FVZFZZMDlh
      TTJsVFp6VnJiekJoVEhSbGQybG1PVTUwVDI5M1MwRkJaR2xqUjFkcE9Rb3lXVkpEVGpkYVNuSnVl
      VGx2VWpVNU5HdE1TaXN3T0dsWlFVaDVURWxxYUV0SlN6RmxWVVY0Y2toRmNHRkdhbXhOZDFaaFJG
      RjVUV056VlU5RlJXMW5Da1ZCYzJSSGIwRlFTVFpJT0c5UWQxWjRlVFI0ZVhsdlNFZHRPRU01YVdj
      eFJubDRZVFJyTm1wWWQwOUZNV1p0WkdSVk5YQkpSMU5pTmxWWmNHUnhOVWdLV2pGMFRrUnpURUpv
      UVZSWVF5dE1XWGgzVFhkRmFGWjRaR2QxU0VNMGMwaEhLMmQxYUZKdFZUYzVSRVZuZDJ4M01USlJU
      M2RMWTI0eFRuZFFaVTVNWndwNlNFdzBSMFZzV2pKcE9FZHlkRWQ0YlhWWE16UkljMXB3UkhaRGNI
      UmpabEoyV2xoMFoycE1Sa1I1T0c1bUwwbElWazVFVWxCWGFqZEZURE5WV1VnckNscG1hVzFwVTIx
      dFJDdG5ORFEzUmpZeGJrWlhiekJQTWk4dlptZEtObTFyU1dzNE1VeE1ORmh1YkhjMk9VMTFhSGwz
      U0N0RWExRmlTRGgzY3k5VmR6SUtaR2h0VlVRM1JXRkhUSGN2YkZOVk5reE1NazF1Umpsek5FMTBl
      bnBOTDNjMlJYTkpRblphVkZVNVQxVTBWMnA2ZUdzeFVUWm5jbmRGVGtwM1p6QklLd3BPUXpOYVRp
      dGlWMFEwYW5SRmJIZDFaRzFIWlFvOWRuUTNaQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Check if watch rule for /etc/gshadow already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/gshadow\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_usergroup_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Add watch rule for /etc/gshadow in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Check if watch rule for /etc/gshadow already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/gshadow\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/gshadow - Add watch rule for /etc/gshadow in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify User/Group Information - /etc/security/opasswd
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/security/opasswd
  hosts: all
  become: true
  tags:
    - CCE-83712-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654235
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_usergroup_modification_opasswd
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWlhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      Tm5UVkF2TVV0ME1HdE1hbFptYVVZd2FHMHlXR2x1TmpaSlUyb0tjSE5GTm5KV1kxaHZTelV6U1RO
      bU9WTmxPRVJ4YWxwSlIzcENhbmx0WlZsU2JXaDRjSFpwTTFvdmRHMXpUaXN3ZW01cGRuSjFjWFl2
      TmxoYVVXcGhRd3BDY0dzMmRIVjBXVWMzTkVwTFNWcGFNREJGTmsxd04zTllZa2RaV2pJNVQyUjRk
      blJhZWpKQmJsTnlaR2xJWkZkTVVYQktSRzltWXpOamREQnlTazFwQ2sxblIyUkhRM2xQVTFOeGJF
      Z3hiMmgyUzNwWGVHcHNZMWxuVjNkNlFUbFJRbUpLVEZSck5GSlZaVzlSVFUxU1kyWkZSVXN4YVd0
      bWQwVnlWVWgzVG1VS01FNDFiRlJDYUdwbWRIbHhhVlZ1YkZNMVRrNTBjbU0zWVVwU1IzTkZTemxY
      YTJ4VmFGRmFWMlJQU2xveWVuVTBZV0ZsZEM5aVZIcFBRVFkyTHpsR1lncEVZMWxLUkhsa2MyOVhX
      a2huZG5wbU1qWjFRbXh3WjBaalZYRndjV2MzYm14dGFrZENkMWwwU2pOVVVEWldaM1ZhVEU1Rk0y
      ZDFaWHBXWkZOTlNHUmFDbEl6ZG5wd09WVklkWGRrVFc1b01WbFhlV2hDVDFWMlNFNTRUVTlPYTI0
      NVdFdFdPWGhUYzBSU2VYTnJWMFpDYWxCMVIxSk5aVnBQUVhSUVkxQjZNVU1LSzNwRmNEa3JXSEpz
      YVcxcmIxSnlRa1psWXpCd1VVWlFibk50VURGclNUUndVMFI1Tm5wVE0zUXJVVWxsVGtkb1ZWcFFP
      SE4xUlVNMlVHMU9kM2RDWWdwUVRGQlpVbmQyU2pVMVNuRkhiR05xZVVNd2JESnBaR0p4VW1abmRV
      eG9URXBSWkVKNFkyTk5WblY2WW5CcGVXdDFXbmhyVmtWelJEbGhUbkkzZDBwVUNsWlVObVJGTkhC
      dmJtSlZVVFpxY2xoRWREQnphMkYxU0Zwbk1rMHhiRWgxYWtOU1ZYUmxjREpFVDJ0YWFuZFljR3BE
      VlU1WE5raE1WekY0VlRsTFZIb0tlVWR5UlVNNWMxWm1lU3R2V0U5M2JGZzNPV0ZJUXl0ellVaEJk
      V0pNTjJSaVozRTJZa1ZvWTJvNFJsVjFOazFQWmtFNVJUaG5iV0pTU0VOWGRUVTFhd3BaZG14UU1E
      aDFMMmhVVGxNM1lrMVFkMDVzWWdvOVJYTk5Od290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Check if watch rule for /etc/security/opasswd already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/security/opasswd\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_usergroup_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Add watch rule for /etc/security/opasswd in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Check if watch rule for /etc/security/opasswd already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/security/opasswd\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/security/opasswd - Add watch rule for /etc/security/opasswd in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify User/Group Information - /etc/passwd
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/passwd
  hosts: all
  become: true
  tags:
    - CCE-83714-6
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654240
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_usergroup_modification_passwd
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWllRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      RnNiMUF2UVRKaFJIZG5lR3R6YzNGWFQyNVNNamhYTkM5NlFUY0tNMFpyVmt4a2RESlpNbTFRTTBo
      dVZYbEViRFJ2ZUVjNU5sWm5jekJvTUVkclIwbFJabTVWVkd3Mk56TjZjWEZ6V2k5d1dtWTNhbmh5
      WWtaUE9FbFdVQXBDTlRJMGQzZHJRM1pLYzFWcVZEQkdTMWR3ZURka2IwWXhRamhRY2pCNllqRk1T
      R1UwUTFWbFp6VXJXblZDVTJwVWVHVTNkRXBRVEVsMVZFaEhhbU5aQ21KaVNGaHpXRGN2YkhSNWVW
      UnRUemhuUmtzMmJFNTFWRWQxV2tGM1V6VnlRME5pVUhOcVVGbG5lVE55UVhNNVRpOVFiVGhhSzNS
      TGFGcHBUbGRzV0dnS0wxWk9TVkIwZVhKd2JrbENjMHRFTjA1eVpEUnhPVU5wUmtOQlExaERWWGRs
      VW5keFVrSTJOVGwyY0ZCU1RHSndOakExY2lzMlQxVlRVbTlIYUhKTVdRcFVaWEJQWlZWTVVuTnhW
      alU1VEhGSE4xazJSMEZVUjBsclprVnZZMmxMUTAxRFoyNWxNVVYzTlZrM01ERjNka2hQVEZadlFt
      UmlWV2hDVjNsS2VtMXhDbmxyZDA5U1dYaHdiV2dyWTA5MFIzRlpPRGhFUWpKRlRFOUNkbGRtVGxs
      QlRtZHVNVWR1Wnk5TGNWcHhhMnBOV21kRmVYVkhTa0prVWxCaUsxZFpOaklLUzFsdWFWY3JSMFUy
      UzJ0SVQxaHljRUZpY0dWbFpqbG9XVVZaV2tOVk1sVnFXRGRLUTFaSFlXdFljVmxVWjJsQlpHSnZO
      akU0WXk5RVNTOHZja3RZV0FwbGFDOHlNMmxGWVdwWGRHb3phbW96ZGt4QkwwaDVhamd5TjJWb2Nu
      RlpSVk5xWWxsR1pVaENhMnR6VFRCSFdteGhjRTl2VG5RdlltbHpSMnRFUlVWQ0NrTmlVeXRJUldw
      VlFrVk1WMEV5V2s5M2JrY3dZa05MZVVOWVVsWTFTRFJYWm5Rdk5IRjNhMlZRZGxaMFQzZDVOVGt4
      ZUN0cVpVaEVaRmRxYldkRWVsZ0tiMXBLUVhFeVdrVk5jR2h2VkdOV1JsVXhaVk4zU2xBeVpFRjFa
      akZHU1RFM2NsUkxhWGd2TVdkS2FGRnFUMDFQYW5CWVVYbHFMMFZZY0RsWWFrVlpaQW9yTDJzMFFq
      bGFabE5MZG5CUVVraFdLMFV5TndvOVJWZHdaZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify User/Group Information - /etc/passwd - Check if watch rule for /etc/passwd already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/passwd\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/passwd - Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification_passwd
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_usergroup_modification_passwd$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/passwd - Use /etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_usergroup_modification_passwd.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/passwd - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/passwd - Add watch rule for /etc/passwd in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/passwd - Check if watch rule for /etc/passwd already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/passwd\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/passwd - Add watch rule for /etc/passwd in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification_passwd
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Events that Modify User/Group Information - /etc/shadow
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/shadow
  hosts: all
  become: true
  tags:
    - CCE-83725-2
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-654245
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.5
    - audit_rules_usergroup_modification_shadow
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWllRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      aGlPRkF2VWpCc2VrZEVVMWRhTW1sbk5tZEpZa05QUlV4WVJrZ0tORE53WXl0eVluRnhTMDlETTFO
      eFJETktPWFZMV0VGclMxUkpWbEp3Vm1aVGQyVktOR1JGVmpaS0syeGFhell2ZDFJcmVWaHpRWEJ1
      YVc4NWNtNXhLd3BIYURreloxY3hWMU5tZVdGbVlqTXJiakJ4U3pKaGQzRXhWR3hoYkVWdmNVbFFV
      RFZITmt0R05HaHlOMEZMU25GbWVVUmtTMWxLVUVFM1lVdG1aMjVUQ2tObU4xZFBNMVp4YjFSSGRV
      SjNRa0pXZUV4eksxVkRWMHBMZFhSVVEzTmlTMWR0WkZkUFYwaHpSV2h0VTNZeGRYUmlVRFpRSzI1
      dGFsZDFiM1JsVkU0S1dVaGFMekVyWTBjM2NGaGxRWEJ4Y2pSRU1XZzVSSEEyVGt4WlYyZ3lVVUky
      TUdONkswa3dVRXMxUnpSVE5GTnRhME53ZW1nd1JrUjZjVlZPWVRoaFp3cFNPRW96Y2tabFVrTlJO
      M1o0V0d0aU5IRjZSM1p6WVdVNVFWbFBSSEZyVTNWaFYzZFFWU3RWVmtscFNETkViVlJTY0hSNFZY
      WlBObXBIVTNkWE1uZzNDamR3WWtSNFYwSnpVRnBNUldoT1JWTktUVFJZV21GamMxb3lXbXhEZHpB
      clJVWTBSazF0Unk5TlRHSnRabE15U1UxcFl6VlZZMnRNZDNGeFEzQnRPVVVLYldjNGJXaHpkV3h6
      Y1ZCdlR6ZGxkV3RNUWpjMlNra3lla3RMYlRWeVVuWjFlR1ppTDJ4Wk1uUnpLMjV3VEdsR1NHTXJU
      VTVTWVU1d1pqZGxla3RuZFFwUFdreE1URXRYUlRaaU1XeGhWMHBHVDAxNUswcFBjSGcyY25Sc01G
      RnplWE5aWms1MVNrWmxVM1p3TDFsV1MwbGhUa1JIWTBveGJWbzBTekZFU0hKVkNtUmpOUzgxU1d0
      b1ZXTjRTR1ZtUkhOWFJWWTRRbHBqWld4c1dtd3dhelkzUTNoUFkwcHNTRTB2UnpWdFdGZ3pkWEZK
      YkVwV2FqTkRPV3R3YVVwMU5tUUtjMlZoUWpGRmF6TjJUbXhoV1dNMU5YaEpZMHN4TWpKT1NsbzVk
      Mk1yTkRZck0yaDJVMFpyZDJGaFpXMXhZMGh0VFRkNE5WSnNLMHBsYXpCeWJWTm5jQXBXT1dsME1V
      WXhiMjVJVDJzMVVFTjVWWE5JWlFvOVVVbGhRZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Events that Modify User/Group Information - /etc/shadow - Check if watch rule for /etc/shadow already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/shadow\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/shadow - Search /etc/audit/rules.d for other rules with specified key audit_rules_usergroup_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/shadow - Use /etc/audit/rules.d/audit_rules_usergroup_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_usergroup_modification.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/shadow - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/shadow - Add watch rule for /etc/shadow in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Events that Modify User/Group Information - /etc/shadow - Check if watch rule for /etc/shadow already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/shadow\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Events that Modify User/Group Information - /etc/shadow - Add watch rule for /etc/shadow in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Attempts to perform maintenance activities
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_audit_sudo_log_events,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to perform maintenance activities
  hosts: all
  become: true
  tags:
    - CCE-86433-0
    - PCI-DSS-Req-10.2.2
    - PCI-DSS-Req-10.2.5.b
    - PCI-DSSv4-10.2
    - PCI-DSSv4-10.2.1
    - PCI-DSSv4-10.2.1.3
    - audit_sudo_log_events
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWllRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      RjRjMUZCU1dsVlNYZG1SbTlvU0ZOaVQwMHpaelJLWVVoa1VrSUtWMngzV1RacmFXRnlNalpsVFhw
      amNubG5VVTlaUWtOT2QwUTBTSFJKVlhGb2IyazRRa3R6TDNkQlJuRXZWMWxsTnpZd2JXVnFVVFV2
      YTNJelZERjRaUXBSTDNOcGJHbFBSbHA0VWxad1RFWktNMjh3YUZScVJWY3dVMmhXWXpGSksxRkxP
      RXB1UkZWa2IwTlpkbGRLWTFoa2NrRldabXRuYUV0dFRqbG1VV1pRQ21FNWRIWjVhelZ3VVV0elJI
      b3ZTWEpGVERKNGNYcDJTbXhzZUhsR1QxZHVXV05aZURsV2VsRkhTelZuYWxCR1ZYbG5PV0p2VDFW
      dk5raGxWbEZ1WVVFS2F5dEhUSEZNWVVaQ1ltTkRNRmRrTTNkc1VVSnBiU3R5ZWtwaFRubHZSVGhR
      WVdsa1UwVlNNVkpZU3pSTVpHRjBNRkIxU2xKVk4wSjRNalZKYlZkeFlnb3pWV1JZWlhOQlNXOHdj
      VzFLWlRsb01VczFOekZETnpaNk9HaHJXV0owT0ZobGVYbHpORE5aWW05cE9XRm5Zek5CYjNGdU1G
      cDNPUzg1U3pWb2IxTlJDbk5YUzNJNVdWZzFlalp3ZFZSUmNIZFdiR1JGYVVodE1USnhSRzl5ZGtk
      MmQwNVNlVU5sYjBFNFRsWk5SVVkyTVVKa1FUZEZjbXhtVjBSYWNWSlBaMGtLYkVWcVp6SjRaVlpY
      ZUVRNGQwcGpUVlZDWkdKWVVsaDNkRUppWTI5TU1qZDFSWGh6YVRScVVHRlVSMDlwUW1aRU5FZzNO
      RlpUWWxZMGF6VjNSbVpMTmdwR1VIcEpWRXhZVEZsTGRIbFVSbmRNTlRScVlpOWplVFJ1WVZwa1NW
      SnJWWEZxY0ZackswZEdVVTVXYjI5SVFpdHZRMGhoUnl0dU1FazBhSGwxWlhCVkNtMTVUemxXZGtG
      UWNIbzBlWFJtV1RGbGMzRnJlVE5sWTNwVVNISnFTMlZzY1ZSaldXVlhORXMwVWpWNk0zRjFkVGx6
      Tm5WalkxVkJlR3RwVm13MGIyd0tRVVJRV1hkSVRVcHBWa05NUkRkSFltMUNPRzA0WVd0V1ZuRndM
      M1JDYTBacGJqWlhkbGxXT1hWblFXWlVjR3BPWTBKRGJHaFBjR2RuVmpsa04yc3pNQXA0WjBZNVNq
      SkhhR1YwTTJOa0swbERjbkZsV1FvOWNXVTJUd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Record Attempts to perform maintenance activities - Check if watch rule for /var/log/sudo.log already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/sudo.log\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to perform maintenance activities - Search /etc/audit/rules.d for other rules with specified key maintenance
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)maintenance$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to perform maintenance activities - Use /etc/audit/rules.d/maintenance.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/maintenance.rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to perform maintenance activities - Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to perform maintenance activities - Add watch rule for /var/log/sudo.log in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/sudo.log -p wa -k maintenance
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Record Attempts to perform maintenance activities - Check if watch rule for /var/log/sudo.log already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/sudo.log\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'

    - name: Record Attempts to perform maintenance activities - Add watch rule for /var/log/sudo.log in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/sudo.log -p wa -k maintenance
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0600'
      when:
        - '"audit" in ansible_facts.packages'
        - '"kernel" in ansible_facts.packages'
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure Local Login Warning Banner Is Configured Properly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_banner_etc_issue_cis,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure Local Login Warning Banner Is Configured Properly
  hosts: all
  become: true
  vars:
    cis_banner_text: Authorized users only. All activity may be monitored and reported.
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      TnliMUF2TUhoWFFXOXhiV2xSZFhOelJIRjNNRGgxTDJWYU16SUtSVTAxZGpoTlZUQk5RM3BMY1V3
      MmVHVnRVMmRPTms5U1oyaEtkWEpRTjJ3Mk9YaEJhR1ZXYkhWeVFqaDNPR0VyTlc1VVVURnBXSGt3
      V0RkdGNFdFJRZ3BuZUNzNVZVZ3lhMWMxV0VOM1VHZDVkazByVFd0RWJFWlNURTQzYkhRdlEwdExR
      azg0Um10SU4yZzJNR053VkdoU2NrcEdVa3RTTm1kQ1ZGWTJZemhLQ21GVlJXdGpVbGtyVVcwM1lW
      WlRPVkZxY1hNdlpGQXpZamRQT0dKM1VrSjFLMVJFUmtsaE5GaHlMMWxJZVd3eVJGWkNTMVkwV0c1
      RGMzTTNaM0JCZEZNS05qWldVVE5RWTFGTVVFcE9ia0ZvZVM5S2RtOXliSEYxUTBwWFQxZHlhbTVX
      T0RkUmFETkpRazUyYzJGNGRYVnZOSEYxYm1vclpHSjBjV2hVVWxKcmJncEpNVTFNU1d4S2FsSldl
      RzkxY1M5MlpERTNXVTl2YjJoU2FGbHRUMFk1WmpOd2N5dDNjaXN6TjNsQmIwRXJjM2RvZFZkVVFq
      ZEpha3cyT1RSWFVrTnFDa1F6U1ZOS2VHb3dXbXhCVWtSR09FbDFjVTFuUmtWUWNUZGFjV2N5ZDFF
      dlFuRnZNR05zT1VkWlkyUllUQzlXVms5V2NqQnVNMjEwU0hsMVEyczBaMndLWTFSamVISTVOMjk1
      TnpOcmFVaHZlRUpHYUhKcVZrOTJWbGxFUVZob1FsTlpaVWRsY0ZObFpsWXpOMVJuWTJGcmEySjVT
      R0puYW5SeFJISkJSelJFZHdwRlZtMVVXamRUYVVaQ1RqWktlVkZHUkZsVFdXMVJlRkJ6VjFOb1Zq
      bGtkWGhJWW5SRmRYUTJhVlIxVldSWk9HWjJXa3cyTkc1SlFYaFFOR2s0ZUdoNkNsa3ZkbFZpVlRK
      NmMwaFhTVXBhY21sVlJXeHlkVWhhVDJSS1VYWmlaWGxhWjA1RWVYTmxURTkxWjFWRWRYVnBVaXRI
      TUdsdFFUYzRSRFE0VEc1TmEyUUtTWEV6U1dWb1ZHZEdZM0l4SzB3NFZuSlJZMmc0WVRGS1FuZEZV
      V3RMVHpaQldWWjJaRUZzTVM5T2VYaFlibE5rTDJvNGFsbFFOMDlhVkdONVVVSXJkd3BJWVV4dFdW
      RlJORU5OYzA0dkszZHZOMEYxY0FvOU1URkhNQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86142-7
    - banner_etc_issue_cis
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure Local Login Warning Banner Is Configured Properly - Copy using inline content
      ansible.builtin.copy:
        content: '{{ cis_banner_text }}'
        dest: /etc/issue
      when: '"kernel" in ansible_facts.packages'


# Ensure Remote Login Warning Banner Is Configured Properly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_banner_etc_issue_net_cis,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure Remote Login Warning Banner Is Configured Properly
  hosts: all
  become: true
  vars:
    cis_banner_text: Authorized users only. All activity may be monitored and reported.
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      VlBNRkFyZDJaTGJYYzNjSGs1VUZSQ1YxWlRjRE5GWmpSUlUyd0tMek00Vkd4d1JEZFFORmc0VjNC
      RE16RkplSGxvTkROT1ZYcDVSbTlJWWs0dk9VZFVRMDFITjBsaFNuTnhUWEpSWjBKeFZteHVUSGsy
      VlhsbGRXa3hTQXBLTWt4c01FbFRhVkJ4UjAxd1EyVnZia1YzY1haQ1ltRmlURmRISzBoQmQyRlFi
      alZUTVRkU05ucElWa05SV1doNU9WZG5aMnBOZW5wTk5GSTNReTl3Q2pKcVRUaE1jMmhETmtsTVV6
      Vm1Wa0Z2WW5GMmJqWjRORkZ3ZFZWbGQyUlBlRW80TUV0U2EwazJWamxRVlRJNU5GZDJORFYxVmto
      ck1XZDFSSEIwZWpRS1MzcGtVbE5wYVhCQ00xQnRLMHd6VW5aemRXNTBWV3h5T1V0c2IzUlhOWFJy
      VlhObFZFb3diMlpyYTBOclJrSm9lVTlQYkdKdFVtUk1NRmt3Um1OUWVRcERRa1JIY2pkMFZ6bFdl
      bGdyWjI1SE5VUTRhekl5ZWtwRFFuTjJjMWQyU2pnMUsweGpUWHBoVHpobFdVNDRURE5tYTJGR05t
      bGhaMHhuYVhaSU9VOTZDbll3YjBwVGJsQnFVMDEzU0d4cmNrMVBTR0pyUWtoMk5XZERWa0ZMWlhk
      VVdYQmpLMmxuU2tsUWJrdHJhWFJJV1VnMlNWbHZaRkJ5T0VRdmVHTnhaM1lLZDBWNWJXZDNNMFZC
      YmpFeUwwSXpkVzFQVURSSWQyOXhSMjF3UjB0QlRVRmlNbEpxWm0wNGVuaFhhVGxZV1hwbVRVWjRa
      akV6YUZGYVpEaGpWMUpYWndwS04zVlZPVWx5T1RaS2MxbDFRamt6WWsxQ05VNUVTa2hyYTFGSlRG
      VkZNalY1TlRZNU4xWjZkVEY1YnpaeGRVeEtiMEZNVjA5c1dHZFZUMWhUYm1ZdkNuSndXR0p5VTFV
      M2RUWmFiWHB2WWpaeWVtbzViMGhwWmxJMFUzUk1WMjh2UWtwc2NrOVlORzlsTWtWSldqa3ZiRVpP
      ZW5WWGFtNDNURTE0UlVadGNuZ0tSWGc0ZDNvdk1YRlhXbU54YWtVM2JUVnBZVFV4VW5vck1GUk5T
      ekJEYTNaVVNFeDZZMk56V21odEwzTkxVRTl0VDJnMlJGVm9WRGxRYzB0dlJUQk5SQXBGY1dOVGF6
      a3hSVEo1V2pOMVpXNVdaVlF3Y0FvOWNXY3ZNZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86143-5
    - banner_etc_issue_net_cis
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure Remote Login Warning Banner Is Configured Properly - Copy using inline content
      ansible.builtin.copy:
        content: '{{ cis_banner_text }}'
        dest: /etc/issue.net
      when: '"kernel" in ansible_facts.packages'


# Configure System Cryptography Policy
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_configure_crypto_policy,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure System Cryptography Policy
  hosts: all
  become: true
  vars:
    var_system_crypto_policy: DEFAULT:NO-SHA1
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      UldORkF2YVZaSWFYTkpNVzVrU1RWa2NXNUdUak5uSzFvMmIzZ0tkbXB2ZVdkT1pHczVkSEpMZHpO
      eGExSk5NeXRUYUZWaFltcHdUR1JMVTNOSU9UQmtTVFpKVDFOQk1VTXhRM2RVUnpsdE4xSkJZVzAw
      TUVoc2NVeENVZ3BNTDBKd1JFODVUalJNYURFeVYyMWtXRnBCU201NlZFODJVMnA0VEUwMU9XWmth
      RWg1UlhkSWR5OUZNMHBxVTJ4YVRtVklPQzl2YTFScVJHVnhZMk5VQ21ORldERTVOMmxMVkRSRWRY
      Wm1ORkJJTjNCTFJraE5SUzgyZUhSS1VFZzFXV1pIWlVnM2JrTnpZMWxRTW5wR2QxWTFObTFWUTFw
      d1VpOUJhSFpVWWs0S0wwOW1Oamw2YldSV1J6QldlRzFrV0dWWk0xTnZibTQ0YTNBNE1tWndORTE1
      V0hsUFZEVnFXalZHV25scVV6SkxZbTFUSzJGTlJISmFSbEZxYTFWcmN3cHRLMkZJYmtwU1ZUaDVT
      akZ3UlVoa2FWSnZTMWhWV0cwNWF6aDJkMGg2Tm1kNVRXcHlWVWRJTVdFelEyWlVNell6YkZJNVFX
      eGlWVVJvUTNSa1dqUnBDako0SzJFNFRrWlVZa2hyVjJkT2VVeGtZVmRyWkd0aVptZ3lZVTR3YmtK
      NmVscExNR1o0WjA5TE9VZDJVR3hUZVc5WlJVcHRUbEpuVUN0M05uWkdOVThLSzNKQ1puTm5PUzlD
      U0ZodGFVbE9jVWR6WlVKMlpFVnhWVWt2ZGk5RE9VMVVTbGhDU2t3eldHeFFhak12V0VGaFlqZFpU
      aXR1ZWs1NVRrRTNXalE1VmdwRU5FVnJWRWt2WjNJd2JXeERXRk5uYkZkclVqVlNiek5JWWpKak9E
      SnZPVGRsT1c5blVtTjRla2xhTUVzclR6TldNRVJvV2tFelFqWktPR0YyVGpWb0NuQkRUM2h3VGxR
      d2NYVnpWMVY1YzFwRWJqWTJZWFpuVkVwNFNubEVWVFl4UlZCQ2RWWkhTRzB5TXpSelNXWlJUMmMw
      YTJSdFFWQk5iemRLZVdkMFFub0tNbWx5SzFFMmVGa3ZjblpOZGtVclJ6TTRUamRUTjA5dVJubEda
      SEV4VlRNeVUwRkxkMGhGWjBveFluTnFWemwwZG1zNUwyWlhhSFpqU1dSMFRsRkNSd3AzVlV0WVVF
      Z3dTa05GTVZSUWRFWlFjMEp2TndvOUt6RndWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83450-7
    - DISA-STIG-RHEL-09-215105
    - DISA-STIG-RHEL-09-671010
    - DISA-STIG-RHEL-09-672030
    - NIST-800-53-AC-17(2)
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-MA-4(6)
    - NIST-800-53-SC-12(2)
    - NIST-800-53-SC-12(3)
    - NIST-800-53-SC-13
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.7
    - configure_crypto_policy
    - high_severity
    - low_complexity
    - low_disruption
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Configure System Cryptography Policy
      lineinfile:
        path: /etc/crypto-policies/config
        regexp: ^(?!#)(\S+)$
        line: '{{ var_system_crypto_policy }}'
        create: true

    - name: Verify that Crypto Policy is Set (runtime)
      command: /usr/bin/update-crypto-policies --set {{ var_system_crypto_policy }}


# Disable core dump backtraces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_coredump_disable_backtraces,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable core dump backtraces
  hosts: all
  become: true
  tags:
    - CCE-83984-5
    - DISA-STIG-RHEL-09-213085
    - NIST-800-53-CM-6
    - PCI-DSS-Req-3.2
    - PCI-DSSv4-3.3
    - PCI-DSSv4-3.3.1
    - PCI-DSSv4-3.3.1.1
    - coredump_disable_backtraces
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      QnJZMUF2UVRWNUwwaG9TbXBEY0VoaVlqQk9PRU16TmxKUVdTOEtMMGg2VkVwSlZtcHJTMWRtUW5o
      MVVsUnJOamtyTUd0UWNFbGxXVFl4TTBWeVQxa3JUbXRpZVVjelIyTlVLMWsyUlZWRmNuQjBVbkZG
      TmxoUk5ucHJhUXB4UWs4M2RIbHBiSE56VFdaclkwMWhWamN2WkhneFMxbzNTMVpPWkVkaGNuRm9O
      R1poSzBkMWMzVlZVM2w1U2xwclZHRTVObWxtYWl0c1oxQTJVa3BhQ2xacGRVeDROREpJV2xsc1Fs
      QlJMMVk0TWpOdU1FOUNNRVE1YmtOWVJsY3lkMWRRUXpsT2FEWm1ObTloTnpsT1JVdGpZMGhQVlV4
      TlMxUlhOMHd2ZFdrS2F5OUJNMUpxUmtWUFkxQm9abGxzYnpCVlZETjJUVk4yU1dGS00yOUpRWHBO
      UXpsM1ltTkpRVmMyZEZkcGRVVllkV1ZYTVRRNGMwNXBjbEZsTUd4cU1BcFVjMFZNYUU4dlRXbGpZ
      a2d6ZEdjeU16Z3hLMmg0TlZKUVltSm1RbkoxUWpOQ1UzVkhZbU56VFZsTFJUZDJlR3RaVnpObk5X
      MUdaVlIwUmtkM2QyMTBDa1pVU25SM1NrSXlRMXAzTDNsNlVGcHlNRU0xY2t0S1kxSmFUMmRhZERC
      ak5sSXJMM2w1YkM4M2FtTllOek00V0d4blN6UnBNbGhQTkZWNGVqQkVheklLTWtZelNHUlRLMHhC
      Wnpsd1NpOXNSbWd4WVdoNVltVkVUMmgxZGs5WE5uSmFTRGhzU0dwR1NYRnZTSE5XUzBWeE9YQTJP
      WGRNWVVWaGRXZzBOazlsWXdwSUt6RkhVRVJZUWpKbFpDOHhaVVY0YkdKcU1qbG1TMGxQVTB4MlVt
      TkxjalpMWmtWb1NtTnNka28xWW10d1RVUlFaRTFFUjFWRFlYUXliVGhGYmpsbENrSXliaTlIY2tk
      T1FWZG1VRzlTYVc5MmNWa3ZkbmhDWTI1cVZGbHRkRE56YTFKc1RUSkVRa28yZERaWVYzWTBkVVpO
      VDIxMVdsazVRVkUyVjJZMk1YY0tVRzlhTkZnd2FFWjBkV0ZCVUV4MWJUTktaRU5GTkRsRFlsVk5Z
      VnBTYTNFMFpsQnVLMGhtZWtRdlkwc3lia1V5ZVVONVNVNUpaRUo0TmtSamNXcEZTQXBKYVZwWWQx
      bE9LMkpLVG1STUwybDRaaXN6V0FvOVdVOWliZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set 'ProcessSizeMax' to '0' in the [Coredump] section of '/etc/systemd/coredump.conf'
      ini_file:
        path: /etc/systemd/coredump.conf
        section: Coredump
        option: ProcessSizeMax
        value: '0'
        create: true
        mode: 420
      when: '"systemd" in ansible_facts.packages'


# Disable storing core dump
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_coredump_disable_storage,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable storing core dump
  hosts: all
  become: true
  tags:
    - CCE-83979-5
    - DISA-STIG-RHEL-09-213090
    - NIST-800-53-CM-6
    - PCI-DSS-Req-3.2
    - PCI-DSSv4-3.3
    - PCI-DSSv4-3.3.1
    - PCI-DSSv4-3.3.1.1
    - coredump_disable_storage
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWmlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      aFlkMUZCUzBsT1ZrVkxhR1ppYmk4M1EyaHhhVGRUTjJWMFoyTUtURGhsTW5GRE4zaHJUMU5UU0Vk
      S01tNTVlazQ0TldGdFozTmFkMkZYVld4bVVtNHJNa0ZYUlRBck1ucHNaVkZ1UzFkdmVqUlBTelpM
      ZW1kek9FMXNaUXBKY1RoeVNUaFVkaloxY21odWFXZE9OMlJ3YWxkaWFVWlZiMVJSZEVkb2JtbzBZ
      M0JPYTNZelNHTjBVMGh6YkNzMGNVWm1OVWR2YTNaSVNGSnBLemxrQ2s4eFoyaFphV1JHVEdoU1lX
      ODBTbFZDV2paVFNVeElkVWd3T1haUkx5c3JVRkY1ZG1KcVRVMVFRV3MyTWxNeE5tTnpTbU4wVUM5
      SmN6QmpVRnBvUWprS2F6aHpLMVkyVUhNNFJFOXBSRzFEZW5GbFVqQm5kVEU1VUN0V2RVZERabTFV
      VWpOTVRuUktMM0Y0VG5OeE55dGhibTV5UkdJdkx5OHpPWGRUSzFNNVp3cHNaekk0V25GRFEyWndW
      RVpSY2poVFEyRk9NbkZpVFdOV2EzZHJTR1JOUzNoRFJITXdSWFJqWWpsb1VXOVpTbUZZV0RsRVkw
      cHFUM0ZNVW0xRlJrNHZDbU53Wkc5SlduUkRlR05oYlVZNFNsQnlXamhKVEdGc1dGaEdNVEJIZDNs
      ellsRlpVQ3RRYzNwMlN6VlJZVVYyVldOa1pqZE5hRFUyWlV0cU9DdElTV1lLU2pOV1lsWnFOVXM1
      TkdGR1ZsVlhLemMxUTNWUFpGbG9OR05HUXpGTU5tUXpVbFE1TUUxV1kwcFRkamxsSzB0VGRFcENl
      bkJrTWxveFFrcFlhVVpuVkFwRVNtdHZObVpaYzBneFpFdG9NSEJNTmpKSlMydGhTV2t4YlUxd0sz
      SnVia0pTVDJSMVRuUkdjMDE0YUdjemMwSTViVVZxVm1KVmJGVTFhbk5oUlhWbUNtRlNjRmxWVGxR
      NGNqQnBkbTVhV2tKNVdWVklhMHg1ZFVnclRGQjJaMmR4Y3poVWNsRkNiazgzYldoSlYzRTJiV3RP
      VkdJMk5WVmlSMEpsZUU1cE5IZ0tha3RyZFdGYVNsWTBRV2t3Y2xNNVlXRnlUMU5MUTNaR01IZFlj
      emhsZHpoYWQxQm5TVTFSTVhvNVVqZHpkbTk2TDI5MlJuUm1TQ3MwVFVGcE9Gb3Zid294VVRWclVF
      Z3lVREZUS3k5b1VFbHhRVmRsTXdvOVRtTXJTZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set 'Storage' to 'none' in the [Coredump] section of '/etc/systemd/coredump.conf'
      ini_file:
        path: /etc/systemd/coredump.conf
        section: Coredump
        option: Storage
        value: none
        create: true
        mode: 420
      when: '"systemd" in ansible_facts.packages'


# Disable Host-Based Authentication
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_disable_host_auth,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable Host-Based Authentication
  hosts: all
  become: true
  tags:
    - CCE-90816-0
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255080
    - NIST-800-171-3.1.12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-3
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.1
    - disable_host_auth
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWm1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      WktUVkZCU2tOMlZYcEplSGczTUVSdWNHNUlXWEJPUm0xWVkzWUtURWhTVGtkcE1FODJVREJPV0hw
      R2NUQllNRWRWU1doRGFpdEljMmRGYkVsbU1rZGlLMjUzUXpaVmJHTXhhMjlZY0d4RWJqUkdaWEpK
      VEVWNldteEJOUXBQZUU1elV6SjNXSEF5TWs5SGJFRTRLM1JsVURWb2JrTlpaQ3REVDI4eFJXWlJW
      V3N2TDA1dFMzWnFMMVZzVTB4a0sybDJOSFZsV0hSNlpHUmpkVEpXQ2pkb05VdENVV2t2YkRORlNu
      STVNMWMwUkZJMmNrOVRhRFI2Y3pReWJUZFFURzUzYTI0NWVTOTFaRFZSYW1rdlJubFRUbG80ZVdw
      SU1WZFViMlZFTkRBS1oweHBhM2wzZUZaM2R6RnpVRFo0TlVneEx6Wm5kVU5UVlhsNVJYWmlhMU5o
      UVRsV1VpdG5ka0ZYTkV4bGVGSTRSR0pTU2xCUE1GQm9ZakZTU21wcWNRcHJOR05SVFhwTU1reFRk
      bVJUZEcxTmRXeHNWM0JZZEVGb1pDdHRkVkZCUjBzMmRqSnZkMG93WlVoMWQzQkhkekV2WVRaTmNV
      OURXa3BpVURaUWJEZEpDbGczY0ZSSWVFTnRObVV3YW5KbGEzVXdTVFZ4YUc1RWFuaFphM2t4Tmta
      cldYcExZMGM1VDA1dGVqSlNORWcwWW14bk4zUnVVbXBqTHpWbGF5dFBlSEFLYm05TU9UaExjVlp4
      T0daaWQzVnRhMkpKSzNRM01XZFBNWGxETkdNM2FrTkJVSGhPYjFVM1RWa3hZM2cwTW1oMFNVMHZN
      Mk0zZEdKbFdFb3hla0l5T1FvNWJWWkRSbmRPVDBaclJtTlpaR0kxUW5SV2F6bFhiV0ZVTUdVemRu
      Wm1lVGRGV1dKb2JqbERXV0YzVUVGWVIyUTVZamRMSzFKTFJEVXpZbFpsVEVSbkNsZHRVa3BpY0VS
      RmRERlhjekZqVTFodlJuRmhSekE1ZVRSdVdWZHBjWFl4YUhCWFZ6Vk5ZMWxSVVZVNGVGaE5MMGxY
      Y0ZwMmVWUTRiRnBDUjJGTFJIRUtMM0pLYWtOTWJYaGpOVzlzYUhwVFdUazVObkZrTm5oNGRHUlda
      blJzTDJZeFMzWlRZbmhHU21sdU5FcG1TRTU1T0ROdFZtWTFkV1ZLUVRSUU9EWTVVd3BMSzNaM01q
      a3hWMHgzSzBkcFlsTnRjRXRPU1FvOU5XVndaUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Disable Host-Based Authentication
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "HostbasedAuthentication"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter HostbasedAuthentication is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "HostbasedAuthentication"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "HostbasedAuthentication"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "HostbasedAuthentication"| regex_escape }}\s+
            line: HostbasedAuthentication no
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Disable Host-Based Authentication - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Ensure the Group Used by pam_wheel.so Module Exists on System and is Empty
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_ensure_pam_wheel_group_empty,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure the Group Used by pam_wheel.so Module Exists on System and is Empty
  hosts: all
  become: true
  vars:
    var_pam_wheel_group_for_su: sugroup
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWm5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      UmxNRkF2YVc5VGVFbHFUaXRYV2tSWGFTOVBTVEExYjBGdmEzVUtiRzlrWjNwSE1TdFhkVnBMWjFa
      b2JVZEhWRXd2ZUhCU1NVaFVRVGh3YjBaRWNtMUNiSFJsU1U1bWF6RnRlVzQxYlhSWVl5OW1WVTl5
      Y0VvMWQzWkRUUW8yZEVWclZEZDRiVEpoTTFKQ1ZXeENUVVZIZEN0RGJWVk9XVmRqVEdNNGVIaHhl
      SGwzVFdRMWVGZDBTVTFGTUUxNFdVbE5WMFExYmk4MloyTnlVbmd4Q2tSNFNGTlVkR3hRWVhVemFX
      OTFOamN6ZFc5MVRGQlZjWFF5YUdkek5sTmtjM0pLZURGQmJGVnJWbnBJT1hWRlVWRlVMek5hUzJK
      bVpXVnNjbUpsYVV3S1ptOHpWbloxTTFWdFYyRkNjbWxSZFV4Sk56VlhkbGsyUWxaMlJtWnhNa2xs
      TlhwdU4zUkJRVXhrWkhGSE5VVXdkbTV4WTNweFowNVNka0pUYW5adFFncG5XR1p4TUZGVVJUTkJZ
      VU4yWWxOMFp6QXJUMXBTU0ZkUU9WUXlSMlJaUlc1VlRrSjFjWGQxZGtKNFRtbE9kVkJLZUdwelJF
      Rk9TSGxuVkdwdldTOWpDbVJYTmtZNWFYZERMemRsVUhORlpEaGhPVkEwYUVSdFNrbGlaSFoxWVZW
      SmRqUmxSbUpxVDJKb05IZFJSVmxoYldKeE4zZGxWMDFqU2pSTlpEZEROemNLYkRReUt6VkdjRkpR
      TjA1S1NWSlZTVkF3VFc5NGJGbEtVMHRIVmxKaVlXeFpNVUZaV1dsRk5raExWVXB5ZFVoRFRGSnRj
      bXM0TldWcU1sVnNkMEpaZFFwd1ZYcHNRa0ZCWm1WWVoybFNaV1JJUm14UVZ6SllSMXB4TkdWaU5r
      MU5NSEJtYkZSeVVqbHNPREJOUVRrdmVVY3dXVlJ5WnpoWlkwZDBhMDA1TkU1MENsTTFiMVUzT0dK
      VE5IVTVjakpyWkV0blYwOUtVVkE0ZDFocVJUQTFla3hZVFZwS2EyTXpUV0Y1UnpaWmRHdHhRbE5V
      TUc1TFRsaE1OMkpqYURCUVNqRUtWVlZ0TXpaRGNURkVWMU14UmtsSWNXUTJaSEYxT0dkRlRVTTVR
      Mkl2Wkdaa1VscEdWMU0xTTI4MVIzVkhXWFIzVWs0NVFuVTJha1F4ZG1NellrdFJNUXAzWXpsSVlu
      Z3piRmt4WTAxemMyTndVVkU1YWdvOVN6VkdNQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86072-6
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - ensure_pam_wheel_group_empty
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure the Group Used by pam_wheel.so Module Exists on System and is Empty - Ensure {{ var_pam_wheel_group_for_su }} Group Exists
      ansible.builtin.group:
        name: '{{ var_pam_wheel_group_for_su }}'
        state: present
      when: '"pam" in ansible_facts.packages'

    - name: Ensure the Group Used by pam_wheel.so Module Exists on System and is Empty - Ensure {{ var_pam_wheel_group_for_su }} Group is Empty
      ansible.builtin.lineinfile:
        path: /etc/group
        regexp: ^({{ var_pam_wheel_group_for_su }}:[^:]+:[0-9]+:).*$
        line: \1
        backrefs: true
      when: '"pam" in ansible_facts.packages'


# Ensure that /etc/cron.allow exists
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_cron_allow_exists,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = disable
# complexity = low
# disruption = low
- name: Ensure that /etc/cron.allow exists
  hosts: all
  become: true
  tags:
    - CCE-86185-6
    - disable_strategy
    - file_cron_allow_exists
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWm5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      aDJaMUF2TWt0RlNWWmhOMFZwZG5CbE1XODJTQzkxUW1KTmJFOEtiRko2YjI5TEsyRlZUaXMwYm01
      dE9FZGFRVGxXVWxGMFJHZGlla1lyZWtwMWNqSXhWMEZOZUVWNFZYSnVOV3RuVDBsaWFEVmxVRmwz
      YW1nemN6UmlOZ3B3ZWxWRFNUWk5XRVpsWVVWd2QwTnNURmRGVG1WamJFRXJlak5wUWtKcmJWRjFW
      RlIwYW0weFZXMU1OMU5tT0U1RFZVeHVTbVZGWlRGU01FRXdVVWd4Q2xOV1dsQlRORmxyUTBKNlUx
      QkRZVVJFTlVwU1dXeHNiakZ6WlhCdVFrTXdWMmxLVERZMWVWZ3ZTbWwyT0dScFZrbHpjemMxVTBK
      amJtSlhNV3RVTUc0S1EwMTVaVGtyY25jM1VYQjVZM1ZFYUc1VE1YcHhTQ3RYUVRSemVWQmtlV2gz
      V21SUU1FTkJTRmxFYzJOa1p6UnBiekpLVFhkbmVXOHlNbEFyZURaYWJRb3pVMVpSYzFaRlpqaGpL
      MDFWVFhnNFFXNUJkSEJxT0VrMVFqSlhTMUVyUjNNNVpFOHJXbUpxUm1keVUwdFVMMHB0VDFKVmIw
      UnVUWGxIVjA4dlMwczFDbGswVldwQmJVZE9Ra05wYlU0dlExZFJXVkI2YTFGU1UzWk9ja3BHTjFs
      NlVscFlhVXhvUlZjNVJuY3lUVTk2ZW5OQ2R6VnJRVEYzUzFGcGNYUkhTbVFLZGtGS2JuQTFiSGRp
      TDBseWJGRTRXbnBIVTNCcWN6Vm5aV2x0U0c5b1VEUnlOVE5NVTJaWWFrMU9WVEp1VnpobmFVSjZV
      MnRxV1dkT2JuUk9MeXRoWndwaWFYSkNWM0JMYTBOb05tTm1NM1F3YzNkSGRFaE9kbFZSY0M5NGVH
      NUhSVlptWm5OUlpGcE5VRzFtTDBZNVozcFRObkpGVERoaGVrZE9VMmR1U214akNrRlNkRXBzWlVa
      MmFGYzJhbG81SzFwTmR5OUdWSHBCTDFKVFEwZDZVMUZyTURSVmVUbFhXbGRKV0hGck1tUmFWakJV
      VTBwQ1RFbFdXamRVYWxoMmJuQUtMM1ZVTVVsc1RpODFUV2RJUVVwRVowNW5SbEJ2ZDJWWk5uSTNZ
      V3hhTTJRdlYzTktLMk14V0d0aWVrdzVVVmd5VmtKcVNXaG1ha28xVVdST1IzWklVQXB0ZVRWUFMy
      OVZORk5VUnpneFVYbGtkVkJzWlFvOVNUWkVRZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Add empty /etc/cron.allow
      file:
        path: /etc/cron.allow
        state: touch
        owner: '0'
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Ensure that /etc/cron.deny does not exist
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_cron_deny_not_exist,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = disable
# complexity = low
# disruption = low
- name: Ensure that /etc/cron.deny does not exist
  hosts: all
  become: true
  tags:
    - CCE-86850-5
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - disable_strategy
    - file_cron_deny_not_exist
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWm5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      OWtNRkF2TUhORk9HNVhZbGxGV0M4MFdIUmxWRGxhVDNBNGRGY0tSVkJGU0ZwUmRsSkxUV2hVWVho
      RlNrWTVSMjl3TDNGRGN6RjRNWGx6U0ZsU1drZHhjR0pIY1RGRldreFNXR1JUZENzMmRrdExZVVJW
      WlZSeldEUlhUd28xTkhsM1lWaE9NMXBDVUZFMFN6QndPRGhDTVVOQmJTOHlNRFF6TWpjeGNGRnpU
      R2RWY21WSlFtWXZiVWcwT1M5aVRFTlJRM0puTlRGdlZGVldOMHh6Q2tKYU1YbElMMHQ1ZGpOb1JE
      bHNRVmxWT0RrMldHbDBkRFEyV1RGYVIxWnRTVFJEWTI5R1UySjFNa0psWW1WbksyVmFUekJDZFZO
      RVJYRnlja0Z3VjBVS1pYa3JTREkxVkRkWVNVbHZObkU1UTBGRFFrZE1SalpKSzBsTFRWZFBRbWxP
      WjBjeU1tNXFjSGRJVlhSMVQzUTBiemhFUzNCNGF5OTRNMGRHV2pBMVRRcENOR1EwY3k5SWVrUXdP
      VGRRYWpGRGVFVjRkaXN6YW5SS2NHZEJhbWhXY2s1d2NuVjBMMlJHYzA1NGVYWkZUMFp4TkhaemVV
      TlhSVGh3YnpGUFVVeElDbVZ3Y201SlMyZHhkVVZDT1UxWWRrbHZRV3BhUkVFdk1WaHZVek5ZVTIx
      WlNVUjRVbGx6ZURaTlVXUm9kRGhHUjJkNVNHeDZlWFk0WkdSWlNXSmFZV3dLV0ZOT1pISjNTMEpE
      UkV0cFNqUkNhbG95V0cxaFdtVldVSE5vTWtSQ05VRjRkakJGVFVvdllURkdXa1F5U2xjMloxaE1k
      a1JNZVRkR1psUnBRM0J0UXdvMGRWUTBWWEl2VXpKVVkwVTVkVFlyVkZaNFpXZERUVUoyWmlzNFdI
      VnVhWFZ4ZUd4V2VqbENlRkp0WkdzellVUTVka1F5UkdFMVEyNVVVVVIzT0RKWkNuQkpibmRFZEU5
      RVlXZzNOVVUzUTBKYU1GQlNXSHBIVVhaTGEwOUZiUzlOTlRSNFpHRXpObmRrYmxwMlNTdHhXVWRX
      TW1KS1VGTnFVa051UXpOa01qQUtLMmhTVVhSM01YQnhiSE5WU1dSTWFtUXJTelJWUjBoU1EyVmpl
      bkpoU2pWcmFHMDJjM2xJVUdjeVFWVjVjbXBNT0c1NlF6TkxVVFowYTFoWFl6aFpUZ3BYV1ZaSlJG
      VnBWRzVoTW05QmMyd3hXa3hOT0FvOU1HUkxTZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Remove /etc/cron.deny
      file:
        path: /etc/cron.deny
        state: absent
      when: '"kernel" in ansible_facts.packages'


# Verify Permissions on cron.d
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_cron_d,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on cron.d
  hosts: all
  become: true
  tags:
    - CCE-84183-3
    - DISA-STIG-RHEL-09-232040
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_cron_d
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      RldWVkF2YW05UmNpdHdXbkpqTnpsUE5FZG5Oamt5Uld4U1NVY0tOazR2WkdRMlpXMUNWSEpJWm01
      M2JEUktNa1Y2YlhoSGVtdDZjVzFWU0VGWGRWSXhVMFZKV0VONU5UWTFaazltYUhkQk1DOUROMGs1
      ZUhNMlJVaE1kUW94Ym5wdlFtTnpPRkJqT0ZoNmVtazJkVkV2Y0dWTU5FbDBkMkpXZDJwNFJXbE1X
      a0p6VFhOV0szZG5UV05wUlU4MVZHRkxTRGhKTnpWTVMyMVROM0YwQ201TWIwZDNTa0UxUlVkNWJs
      RTVkMVF6Um1kdVJXOUlUa2RMUnpNdlQwRlJXbFl2T1d4aFJsSnlhVEJuZERsSFlXczFObFp0WW01
      UVJYQlJkMUpSTVhjS2RFRjJWR0oyVUVrdk5IaEhRamRGZUVrdlpEUk1iRnBvZWtwWVYzcFliekJH
      WVhoS2JscE5MMnh5TUdaRU1XeGhVR2swYVRreFJXRldTRzVLWm5aMVJncDBSQzlUVjJ4NFVHNVhZ
      bkpoWjBsUGFuaFNZMUkwTmxOTmEwOU5TRWh6ZG5wSWRqY3JWQ3R0UzNFclZucE5TRnBvY3pGQmVX
      SlFXV2xoUzNSYWRGUnpDbWRHWjBwNE5sYzNNbXR4YVRWWWQzRlFOMk5zU1dwNGNFVmplbWN4WVdK
      dk1IUTVlVFJwUmxCelVHbGtUelF3Um1sbVRVaG5abTlzY1hrMFJqRldhWE1LSzBnMFFuVXJNMDkx
      VWs0NWMzZGlObU0xVVRKMlZWaG1iWE5RYUdRMmVsUlZNalZzTW5Nd2JTdEdPSGhNTm5WTlJFWjRi
      MjVEWmpWbFZHRkJVMWhWUmdwSmRsZHBiMHBCVXpkSk4zVkhWVTVGYmpCblFsSkhWelJSUm1SVmJD
      OVViVGxsTUd4VFNXVkxRbkoxZVV4RWEwOW5iMkY1TVdsTFNYbG9iR05XWVZoRENuWlZha2c0WWpk
      NWRrVk1Sa0ZWUlhZME1uQTFaV293YnpJeGVHbGxORFpFWkVnMVQzQTFWblY1U0dWNFJVbFhWWHBC
      ZGxKcFlYcFNRbXBtY0RSSmVHa0tlSFpsV25BdlEzUlhaamR0Y0dGWVpWZHNWSEpNVUVkM1MxWnZh
      MU5hUzNKM1MwcHhabkpGVkRsUVRVTXhaelZDYzJwTlVWbDZjM0ZSZUZscE9EZEVZd3BaZUc1RlJV
      OXhjM0pKTmt4UFQzZ3daRzVGVGdvOU9FWm5lQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Find /etc/cron.d/ file(s)
      command: 'find -L /etc/cron.d/ -maxdepth 1 -perm /u+s,g+xwrs,o+xwrt  -type d '
      register: files_found
      changed_when: false
      failed_when: false
      check_mode: false
      when: '"kernel" in ansible_facts.packages'

    - name: Set permissions for /etc/cron.d/ file(s)
      file:
        path: '{{ item }}'
        mode: u-s,g-xwrs,o-xwrt
        state: directory
      with_items:
        - '{{ files_found.stdout_lines }}'
      when: '"kernel" in ansible_facts.packages'


# Verify Permissions on cron.daily
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_cron_daily,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on cron.daily
  hosts: all
  become: true
  tags:
    - CCE-84175-9
    - DISA-STIG-RHEL-09-232040
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_cron_daily
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      Vm9UVkF2TTFVck1UbE9WamxZVVd4SVkyaFRNbkZ6ZFhsUFJtd0tjWGRQTjBSNFlUWnlZa2RMYWxs
      VVJsWkxVRE4xVjFvMEwxbEZkbFIyYlRablpqa3hOWHBtVVhsWGIzbDVNRVpESzFOVlVIaE9aM1oz
      VWpFelZVNW1UQXBJWTBvck1taHVOMVJNVDJSR0wwNXRNRXhuSzNCQ2RVYzVOM05oZW5SaUwyTldU
      MjkzT0hCRlNqQk1ObGN5Ym1ObVRISk9kV3h6U1ZkWkt6ZGpTRGhPQ2pGQk1FNDBhekpQV2tSdGJ5
      dGxPRWM1Y0dWaVdtcDBXVmM0V0VSVlZ6ZGxiWE5QUldoeWRXSmlWbEUwVTBkb05VRXdXblUwTUV4
      cFMxZE1kVGhVTURVS09YSXZORVJ6VjA1bWJ6aHNTSFZqY0N0UU1qbE5aVlJvVUhacGFtSndiak12
      ZUVneVFtcGxOblZyZEZWamRuUlpSV1I2WmtWWGVVeHBTVkJ3Ym1oR1VBcHNka3B4TTNWbFNIUkxV
      bU5sVWxSemFUbERaSEY1YlZJNVFuVnBWbVZ6WWs5a1RVdFZjemx6UW5WdWJrWTFibEpDUjNGbFJE
      bEVWWFZqU1RVNFZWWmpDbEp5VkU5RWVFUTJMMWxEY2pGMWVHMVFia1J6WlZwbUsweFBXRWN3Y1RC
      amIxZFVNbWhvUnpSMEx6VnlUVE5GYlRZd2RIUTFORVEwYkN0RVJUQnlNVklLZDNGaE1YbHhkWGx1
      TUhaUFpGcHZLMlF6WlVOQ05ESlliVWgyUjBsR0wwMTJNWEZaTldwbWFtOWtSak5KWmxKalNXcHBa
      RkpUY205dVR6RTNVamMyV2dwaWVDOW5VVmR1T1c5WVJuTlJhM0pWUjI1UFYxaG1hMHhsUlRoM1lq
      TklTRzEwZFVoeFF6Qk5UMGRtYVM4elNrWXdRVU54UWpsbVRIaEtRbU13TW5kdkNtRnJURU5YWmpK
      aFJFbHBVMFZHVFVOU1lsTkhUbWRPUVdkTlpYbDJWVTR3TUU1NU4xQlRTMmR5YlhSNGVVaHdVV3hQ
      V1hwMFJXVnpiRlZHVjFvMWFqTUtTazVGTlhJd1QzbERkelU0WTBoWlZtRkxXbkJHT1dneU1XWlhh
      elpDVm5WT1dFOHdUMWRrWVZSSk9FRlphWE5rU0hFM1kyOXFUamhQTWpOUGQwMDRjd3BKZUdWRGFV
      Wm9abEZMV0dWcFlsSkZkMDQyZFFvOU1qSjNPQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Find /etc/cron.daily/ file(s)
      command: 'find -L /etc/cron.daily/ -maxdepth 1 -perm /u+s,g+xwrs,o+xwrt  -type d '
      register: files_found
      changed_when: false
      failed_when: false
      check_mode: false
      when: '"kernel" in ansible_facts.packages'

    - name: Set permissions for /etc/cron.daily/ file(s)
      file:
        path: '{{ item }}'
        mode: u-s,g-xwrs,o-xwrt
        state: directory
      with_items:
        - '{{ files_found.stdout_lines }}'
      when: '"kernel" in ansible_facts.packages'


# Verify Permissions on cron.hourly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_cron_hourly,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on cron.hourly
  hosts: all
  become: true
  tags:
    - CCE-84173-4
    - DISA-STIG-RHEL-09-232040
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_cron_hourly
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      Vk5VVkZCU1d4eGEzZHBRMnhrVDNNMVQyUlFOQ3RhTUM5NFdFTUtjbEZNVDNGYVpUTmhZMWxIUTFa
      eFlYSjNVRVpqVkVoS1QwTnpiM3BZYm00NVMxWlJSMUJhWkVwNWVrSnZOblo2VTJGS1ZuSTVRekIz
      VGxKTWRrYzNaUW8zYlUxdkt6azBZVmM0UVZrNVlqRkxTM3BsWVdaaVIwMWhXblptTDAxcVYwRkxh
      RzlTYUVSbFYxTjFZbFp2VmpNMGEyNDBia1pFSzBaT2RUSm5aMFZqQ2pGdlJFZHNVMmxIYm5WVWJX
      UTBibGhqYURGS01tMUZkRXQyWmxOVWNuSklhRTB6VTBsU1pVVnJkbUZuUTIxMFlYb3dUMHB4ZDNW
      RWNYRlhRblJZVFdjS1EwTnJLekl6TmxSMmJrVm1ZV2s0UWt0TlpHbENWbFpRT0dOdGFYSlROVFYw
      WWxJMGRUZHpZbXd2YUVSbWJFaHNMMGR0Ym5wc1ZEbHlPVGxhV1hwSVpncG1ha3R2WlVORmRrZHhh
      a2h6U1dGWmNVVktiRFo1YWpFcmRFZGpMMngxT0hWbU5VMXZWVGw0YWxsS1lUYzFhRVZOYVdVelZp
      OUtUWFZMU2s5NVJsbFRDa3BzUTB0a1JVbzROamRRYjFGcVZURjRWMjFrWjFSM1VWWldVazlJWjNK
      aVdTOXVSWEJNVTNwbE1XYzNaMjlqVGxkMllrcG9TRmQzYVZaMVlXUnBaM01LT0RkRWNXeDVURVZa
      U21GV1dIQk5UVlkzVGtGSlZsRjVZbEJHU1c1a1dXRjFUMFppUkZWWVkwMDRLelYzUlU1NmNHcE9j
      VU50WlRRMlJWRnROM2hFU3dwb2NGbHNkemxHWkZkNk1rNHhaek5pWTFSRVJFaG1iRk5JWTNsSE5H
      TldlRGxhWWtKdlZDOXpVVTlSV20xSWExTktNMFYzWkZWb05IVkNlWG8xUVhOSENuRlBOWGhCUlN0
      cFNWRlhiMmRHTTFGMVNscGpabXhpTWxOd1VqWXZWa1F4ZWtWM09FOTVWbEV5UTFwQ1YzRnpUVU5r
      VFZKMWVVMTNMemMxV21VMU1Hb0tMMG8yZFU1d01qWnZiRVJRTVVSMmVVZGhka1ZQVm5kS09TdHlh
      MUV6YlcxNU1XUnZaMDFKZGxscWF6RnlOa2xVT1ZkdWQydEpSazVXWmpCTU56TkdPQXBGY1U5VFlu
      QkxSblZ6VUZKRGFXdElZMVl2Y1FvOVNWQXhVd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Find /etc/cron.hourly/ file(s)
      command: 'find -L /etc/cron.hourly/ -maxdepth 1 -perm /u+s,g+xwrs,o+xwrt  -type d '
      register: files_found
      changed_when: false
      failed_when: false
      check_mode: false
      when: '"kernel" in ansible_facts.packages'

    - name: Set permissions for /etc/cron.hourly/ file(s)
      file:
        path: '{{ item }}'
        mode: u-s,g-xwrs,o-xwrt
        state: directory
      with_items:
        - '{{ files_found.stdout_lines }}'
      when: '"kernel" in ansible_facts.packages'


# Verify Permissions on cron.monthly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_cron_monthly,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on cron.monthly
  hosts: all
  become: true
  tags:
    - CCE-84181-7
    - DISA-STIG-RHEL-09-232040
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_cron_monthly
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      UmFhMUF2YW5KSEszSXhZMFF5YW5Oa2N6TklVVTFRVjNkVGEya0tkMDU2YzJSVVIxSkRlbG80Yld3
      Mk9UbFFialZOYURGdFJEUlpSUzlZWW1oQ1FWcHlNM1Z6VTBsMk5FOUNNMEpNVWxkM2JVUjVXbFJw
      V25sMU1URlJTUXA2Tmt4VmIxSmlWVWxOVDI4d1UyVTVhMDlDYTFwSmMyeDJaSHBuVHk4eFQzZENi
      VFJCYlhJclRYTlZPVU4yY21WTFdUaFJaR3RqWjBSYVpIbENUelpHQ2t0WmNrTklaa0ZWY3pGVk0w
      eHVZWEV6Um13NVMwUmxVRmg1TDJKeWVYQjJNRzFLVjBaMEswYzRaa3A0U2t3ME9HNXBkek5JYWpk
      dFJXUkliREE1UlUwS09FOUJVRTgzV1UxdGFubE9Zak4zUVZCQ2J6ZEZSVWh1T0RWVmExQktOa2h2
      VjBOTFp6SjNjVFozWXpSUFVtSnhTbHBPTkZaS2VqZE5Xa1JYYkc5NWJncG9lRGxCY2pSeGNXRm5j
      RU13TVdwa05VdEVTblZsTkVWRVIwODNVazVFWVU5Q1JUVlFkVVk0VUc5b2JFeDFkM2h4YTI1VU9V
      RjFUSHBYZVVRMFRHMUZDbU41T0hCdVNsTlpaVXhNYlVvdmRHbElNbWh1U2xwbk1HeEJiazA0TVhG
      NlMxUkRjR3hZV21Ga1FXbHZlVkZJV2s1RlRFUnVWMUoyUTJsMWJuVndiV3NLU0RORWNVNU1UMk5o
      TkZkcFFuRmlNV2RzVkZOSlRWSmpjRFJaVVhKMFMweG9UbTlvVkc1R1JVaDZTbU5xVjFZNFVWZEhk
      aTk2ZVZoWlNscHFSa1F2THdwcFV5dGxkMDF1VEVSVWVHNTZjVTh4WTNWYVNVOVJVR2htUm1VM1Jq
      bHVWMlZwVVU1UldXazNkR1pwTWxKdE5FZDNjV3d3VTBveU9XNXBXVTgzYTI5U0NtTldNQ3REZWs1
      NVRsTk1ZVE5QTjBzMmVFZzFkbnBhWkZOMlNYVTVSblpoTWxveFpGZFZjQ3RWUVVOQ0sydHNZWGNy
      WkRkWmFXeHdNbVpRUVhaUldITUtVVTlyV0ZKNVNXaDBXWFpYVmxSV01YcFJjR3d3UjBOeE1FcHFM
      M1V4UVV0dVlTOHpOVWtyZWt4NWVXTjBUV1ZNVUc0NGIxWkpVRmh2VW1aMk1VOXdOZ293YldGeFVW
      azFaMnQwVlNzNFJsUnhVR2xxWndvOU9GRkhWQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Find /etc/cron.monthly/ file(s)
      command: 'find -L /etc/cron.monthly/ -maxdepth 1 -perm /u+s,g+xwrs,o+xwrt  -type d '
      register: files_found
      changed_when: false
      failed_when: false
      check_mode: false
      when: '"kernel" in ansible_facts.packages'

    - name: Set permissions for /etc/cron.monthly/ file(s)
      file:
        path: '{{ item }}'
        mode: u-s,g-xwrs,o-xwrt
        state: directory
      with_items:
        - '{{ files_found.stdout_lines }}'
      when: '"kernel" in ansible_facts.packages'


# Verify Permissions on crontab
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_crontab,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on crontab
  hosts: all
  become: true
  tags:
    - CCE-84176-7
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_crontab
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      ZzBSVkF2TVdWRWQzbG1iRmx5ZFd4VGFUSnpkbU5oV0U5ek4xQUtiRXhsWTBsSE4zSTNSR1ZPVW04
      MmMycGpLMjQyWVVOdmJERnNhRzgyUmtwbWNXMUdZbTlzZERsWFFqVTFlRzVuY3prNFJVWkJZemhN
      WTFsM1VGTTBkUXB5ZEZCSGVrUjNWMmh2WTNCQlJUZHlka0ZRYlROcVprUTVkR0ZYUmpJM00yRkNa
      M05VS3k5TlQyTkVhMDlQTkZOb1oyTkhjREI2U2tObVNubDVReXRJQ21wRFZrZHlNM1JVVlc1NmJt
      RlRiVE5ITDI5blZ6QmFla3RJV2poWllUQXpaV3AxVW5VdldYUlNhMjlUTVdrMFNYUlNZbmRTZUcx
      RGVUUlhhVUppVjB3S2JXOWpXVXRwWVdwV1Z6VlVMemhGVUhNM2RUaDRhRE50ZVVFMWJua3lOSFZa
      UnpKa0wwOWljM1ZaVjJSMmFUUlhjRUl3ZVhKQlpsUkdXbU5VYldWMmRncDVNVkpyVFd0WVJtWlFP
      RmgxUjBzeFRGY3pVWEpsTm1GRlVDOXlOVGxNTm5SM2RFcFJPVGxUVm5WUlRXcHRaa1JvUWtwbVRr
      OHlTM0U0VG5nMVRsaEVDakZLTUM5NFJVbFRUSGx3VWtwNkwxWjRLM0ZCZEVWT1lVbFpNazl0WjA1
      VWN6Vk9lbGhQV1Vsb1oyOTNTbnBMZG1SaWIwbDVRalpaYlROUllsQkJUVkVLTXpoTVdHdDRUU3R0
      U2xaaWR6aEZkVWRaYlhObU5VRlBaMUJVVlhCNGJHdFFhamh1VkZRNFlrWm5WREJPVUdWR09IZGpa
      emxST0VWUlRXaDJXbVEzYkFvNVpFdExkSEowTm5ocGJrUjVPVmRMTVd4R1MxbERWRWRvZW00MWVu
      YzVOalJFTVN0d1FsVlJLMmRMYzJaREszVlVRbVYzVTB3d2NreHdVRU5XVldnNUNrcE9aRWQzVms1
      dFYwSnhlR1V6YjNWemVHbHNkVUl5V0hKQ1YxZGlTRTVMVkhWc1pHRlJWelF5WW14bFMyOVVVM2RK
      Y2pSSlJqUkpWRTlEUWtod1FrY0tTbTk0WkRCb1IwUlFkbWh4YW1oTU5sYzNOV052Y21KUlQxbG9S
      R1p4SzFOUU1rUTJNRVZQWlV4SVdpdFZabFJQTDNCVkszbFdkemc1Y2sxdmVUWjRVQXBYYUVwSWJH
      OURObTlQUzBOellUQkpWRWxXU1FvOVYycHhUd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Test for existence /etc/crontab
      stat:
        path: /etc/crontab
      register: file_exists
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure permission u-xs,g-xwrs,o-xwrt on /etc/crontab
      file:
        path: /etc/crontab
        mode: u-xs,g-xwrs,o-xwrt
      when:
        - '"kernel" in ansible_facts.packages'
        - file_exists.stat is defined and file_exists.stat.exists


# Verify Permissions on cron.weekly
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_cron_weekly,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify Permissions on cron.weekly
  hosts: all
  become: true
  tags:
    - CCE-84187-4
    - DISA-STIG-RHEL-09-232040
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_cron_weekly
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      Vm9UVkF2TWpKWlZsVXpiaXMyTkRob1dFNU5RVmswZDJOYVEzUUtjR3RZVWtNclkwRjVhQzlCZGtK
      U1MyZFFjbVJKZERKUGJHY3dWWFp2ZDBkaloxVjJTR0psVkdsTk1ucG5iVTVuWkRWSk1sTnZZV2x5
      VWtOWVVrUlRUQXB0TldwelZEZGliMjFoVTNSVFNsZHBTbTFWU25Gek5XcFJaMmRqYVZsUlpGUkpL
      MHRRV2tsdlZWaGpkVWxzT1daRVl6TXdlbE5RUlZGSVQwWXdaVE12Q2taVVl6ZDZNbGh3ZVV4RmRY
      cEVTVVo1V1RkS0t6UjZaV2RTYzBWbE1pdGpjazFOYVdFNE9XNVVWbmwxYUU5dGRpczFNMUZySzBG
      a1NGUTNZbmxEYlc4S2FFZEdkbE5XZG5wSlUyOXFRV3ROSzBwYVdDdG1WV0ZKWjJ0VmFYTTJNR3BK
      VjBSVlMzQTBRMk15ZFhZM2FrUTJaVmd3TWtkYVEzZ3JPRVJIZFRObGRncHRWR00zV2pNNWNERnBS
      Mjk2YW5WNU5qRlFXa2hGUmtsUWRsaEplaXRqVGlzNGVFMUxUMFU1WjJobFR6VjRTV2d2YkVwQlJD
      ODJSR2M1YUdac1RrdElDa2s1YlhOdVZIUlhOV3BsUldSblFWSkdNRTU1VkZaNU4ydDZVakFyUms1
      dWIzUjNhVkUyUjNwMldFOUxjRTVoUVVjeFFqWXpSSEY2ZVV4MU9HWnFZV0VLUmxsbU5tNTRNbVJN
      ZUV4b2RIcEVUVk54UlU1alJqRTVWRzVQYUZORU1YaGphMHBzYnpscVpXUldiSEJ5VDBWRldIZHpl
      a1J0Wm5aR1RIQm1TREJhY1FwRE5IVnZVVEIyUjB0dlFqZHVjV2xMT0VRNEszZG9NamRXU0ZadFJt
      MWFjbmwxTVhCNGExVk5aVmhTWlVJeGRIWjZORVptWmtaRFFVdEdVbFEzTjFSeENtRjVhekZHVlRS
      MVlVdEZVMFp4TkhGWFVGSnNkVWt2SzNkWFpuZEtjRWxRTkZkcVJXSXhOR1J3U1VkaFZGbEpVR1ZN
      TDNsMVExTkhiRE5YVnpObVZIY0tUVTFYYTBsQ1prb3JiV1pVTlZNMVUyMW9XVXhDYjBGNVVFUjZj
      M3BSVTBGclJ6STBNMlp3ZVZsemFYbE1WVUZZTTBOUFRrNWhTbEY2VGl0RWFVMTVOd3BTWlN0Q1VE
      UlNSM04xUXpZeldsUk1SRkYwU1FvOVYwcFNiQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Find /etc/cron.weekly/ file(s)
      command: 'find -L /etc/cron.weekly/ -maxdepth 1 -perm /u+s,g+xwrs,o+xwrt  -type d '
      register: files_found
      changed_when: false
      failed_when: false
      check_mode: false
      when: '"kernel" in ansible_facts.packages'

    - name: Set permissions for /etc/cron.weekly/ file(s)
      file:
        path: '{{ item }}'
        mode: u-s,g-xwrs,o-xwrt
        state: directory
      with_items:
        - '{{ files_found.stdout_lines }}'
      when: '"kernel" in ansible_facts.packages'


# Verify /boot/grub2/grub.cfg Permissions
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permissions_grub2_cfg,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Verify /boot/grub2/grub.cfg Permissions
  hosts: all
  become: true
  tags:
    - CCE-83846-6
    - NIST-800-171-3.4.5
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - configure_strategy
    - file_permissions_grub2_cfg
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      WnFXVkF2TTNodVJqQmhObHBDY3l0MGRsQTRiblJXUTBjd1pYUUtjekZWY1hZeE9GRkhWWHBIUjBo
      WGJHUnpRVGg1TlZVMmEyWTRNV0o2UzBkWWJFbHRSa1JFY0Rack9IUnJhR0YxUjNOQ1QwRndRbkV6
      ZW5oNE5tdERaUXB6Y0haMVEwcFpjaXRVWmxsS1duTktOVlZtTDBGWGNEZzFjR2RGWW5sVVNERTJT
      MjQxVVhKV2RGQkJVVVV2UVVZdmEwUTRjWGhzZHpSc1ZsVkxja1ZPQ2xGRldrTlpWamw1VTFOalZu
      QmtZbVJIVVRseWRIZFphRUZUTlVkeEsyYzRjREJMU205d05tbHhUMWwwVTFRNFpqUkhWVFJJV0Va
      VmIxbzBVbE5zWmtZS0x6TTFNQ3MxZEVkRFpUVnliMDE0U0U1MGFscHRWMjF4YVdWVFdETTJURVZD
      Wm1OeGVWWXpXV3MzUzBab1RrVTNkak4zTlc0NWFqTllSV3BrTVVSTGFnbzFiMlJYVmpBMVRVeERh
      a3RYYlVKT1RIUkRVMlpaWVRGVGNraEJVbGs1S3psNlJFUXZTREJtV0hBMldreHFkbVJKY1ZrclFX
      azRPRzlHZFZCWk1YbE9DbFpuYTFSbVN6QmxOREJXSzFoc2NEZDNZMFU0VjFSRWQwdzRWelpvU1hW
      bWJrSkViR0ZGV1c1cWJrZFlibWxhU1ZwTFdteEhRVTlyZEZkSmRHSnhiVWdLUkZGaU5FUk5jbWhU
      T0c1elJ6VkxPR2RyVkc0eFYzWndhV2hyUW1OcGRUTm1XRVZHVTBWTlJ6azRPQ3RLTW01b1drSk1j
      MU5PZGpReVpWTnVSV2h0WXdwcE5USTBkaXRUT0RjMVJHOUxjbGhWWjFjclEwVm5NaTh6YlVGRE5r
      dEZjRXRRUWpoSk5VeG9Ta1p1V1ZKc2NYWnZWRWhLTVhsUlRXNVdTM1JJVWxjdkNuUlBTVGx5VGk5
      M2RFbGtXVTFtWVZFcmFUUlVVWEF2VGpSWFptNVZRMmRETHpVM1NrbFZPVXBNWkVWeU1rSTJlbGhw
      YXpoWlRVSjZjVzFhUWxKMGVWWUtlSEVyY2pGNFdHRTBkR1I2UVZJMlZFZERRWEZ0U0ZKYVdXcDZi
      MFpGZDI0NFMwVkhSQ3RaUkRRMFkwWkpiVkJQWlhKell6TnRjWFpFYzBWdlYySTFaQXBrZDA5b2JH
      d3lTRzB2V204clRVbDRaaTh6U0FvOWFrVnVZZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Test for existence /boot/grub2/grub.cfg
      stat:
        path: /boot/grub2/grub.cfg
      register: file_exists
      when:
        - ( "grub2-common" in ansible_facts.packages and "kernel" in ansible_facts.packages )
        - not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages )

    - name: Ensure permission u-xs,g-xwrs,o-xwrt on /boot/grub2/grub.cfg
      file:
        path: /boot/grub2/grub.cfg
        mode: u-xs,g-xwrs,o-xwrt
      when:
        - ( "grub2-common" in ansible_facts.packages and "kernel" in ansible_facts.packages )
        - not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages )
        - file_exists.stat is defined and file_exists.stat.exists


# Ensure All User Initialization Files Have Mode 0740 Or Less Permissive
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_file_permission_user_init_files,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure All User Initialization Files Have Mode 0740 Or Less Permissive
  hosts: all
  become: true
  vars:
    var_user_initialization_files_regex: ^\.[\w\- ]+$
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXdRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      Y3hjMUF2TUcxSEwzRlNjbnBJWVhkd2NHZFZjRzh3VUdVclZVRUtNaXN6U25kaE9VTlpNRXRqVWtw
      c1lqVm5kMFpXV2k4M1IwNURlR1J5ZERGVmJ6ZHFTbXhqVmpsSFIyTXhWM0JpV1doUFFrRXJUSFpU
      WmsxWWNFZHNNUXBVTlZkblFURkZkbEpYVUZsRFEwOWhVVzVDWlZGd2NUUm9NbVEyU2xKeVZuZFpL
      MGczUTFWck1IbE1jVEF6SzBKdFFVbHFRV2RXWmxSRll6RXlWV3h3Q2l0NFRXcEhRemRGV0hSMGRH
      cHpkMlkwV0ZWWE56VkhlVkJzZEcxVVVFbDRNMDVrV2tzMWRXZHFVVXBKU0ZSeGFEUlVaRWcwZFVw
      bVYzSnRRbkJYVFVRS2FYaE9jbXREWjFrMWVsbFdiMEkzT0hkUVpua3hiekF3YzJSamJ6RkVNVTlJ
      ZFRnNFFURkpaVXBqZEU5Q1UxVnBkVFpwZDIxaVpUbDBiMlZzVnk5R1VBcG1WbVEyZG0xVU5HaEpT
      blZ1UkZKbFRXMVZZbFJ3TDFOVGRWWldORUZuZG5SUlJtcHRkVU12TWtFNFVuSXZVSEJCTjJWelZt
      MWlZWFkwTTBKd1NFWmtDbmxCTTFBMWNHMWxWakJJYXpaWE5FSk1WV3cxVm1kVk1GTkZUVGd4WkdW
      U1RXMVRNVmszYWl0VGRXWkhOM0poVmpoamJWVnFTM05UZVdGUGIxVnJOWEVLYUdkcVpqQkNhbFJY
      YTB4RmJFdExNRWhzVTFObU0weGpUR014YzJSaWVrOVJMemRITm1aYVNrcHpWM1oyYnpacmFrSnli
      WEJWUldWc1IwMVZlalo0VHdveFdXdEdha3A1ZDBGVU5HRktiM28wYTNSdk9EVnlXbWt3TTBrMlUz
      bE9TbFkzVDAxRFFWbFFXbWhUTVhoU2RVNUpMMjB5ZGtkS1RHVnJTVEpzU1M5SkNqazNXVzF1VDI5
      VVl6Rm1WMlJCWTFsTlVFWXZUMlVyVjBzdmEyNDJiVTFtYVRaYVRteE9WMXB6UjBsaWJ5dHNMekZM
      Wm0xcmVrNUZXa2xTTWxwTFdsa0tNblV6YkhSaGNuQXlMMWh4VlZWTlpGQXliRk54YkVwb2NWcERW
      Mk5rWTFGYVRXdHlPV1ZoWjBvd1Ewb3daVk5JZFRsSUwyUmFhVUl3VVhJMVNYYzFkUXBOY3psRVkz
      bGpSMFowTm14NFEwMUVOeXRzS3dvOWFEbHBRZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83637-9
    - file_permission_user_init_files
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Ensure All User Initialization Files Have Mode 0740 Or Less Permissive - Gather User Info
      ansible.builtin.getent:
        database: passwd

    - name: Ensure All User Initialization Files Have Mode 0740 Or Less Permissive - Find Init Files
      ansible.builtin.find:
        paths: '{{ item.value[4] }}'
        pattern: '{{ var_user_initialization_files_regex }}'
        hidden: true
        use_regex: true
      with_dict: '{{ ansible_facts.getent_passwd }}'
      when:
        - item.value[4] != "/sbin/nologin"
        - item.key not in ["nobody", "nfsnobody"]
        - item.value[1] | int >= 1000
      register: found_init_files

    - name: Ensure All User Initialization Files Have Mode 0740 Or Less Permissive - Fix Init Files Permissions
      ansible.builtin.file:
        path: '{{ item.1.path }}'
        mode: u-s,g-wxs,o=
      loop: '{{ q(''ansible.builtin.subelements'', found_init_files.results, ''files'', {''skip_missing'': True}) }}'


# Configure Firewalld to Restrict Loopback Traffic
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_firewalld_loopback_traffic_restricted,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# complexity = low
# strategy = configure
# disruption = low
- name: Configure Firewalld to Restrict Loopback Traffic
  hosts: all
  become: true
  tags:
    - CCE-86137-7
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.1
    - configure_strategy
    - firewalld_loopback_traffic_restricted
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rp
      dHpiMUZCU2l0WGJFYzNUR0oyYkVGMFlWRjBUQzl5Tms5elIwNEtUbXBMWkhCT05FSkhNM1ZPUjFC
      TmJVNHliV00yTWpScU5HTnpaRGg1WW0xSGVuTXpRVzQzWjBwUFdWZ3pTbUZpVXpnNGVHUnpSMWxO
      WW5kYVIzaEhMd3BNTTA4MU1sTmpWVUZNTlZwcFJpOWxiRGhPZUZscmJXVlpXbk5aZFVwb2RuWTVV
      amREYVVSU2JIUjFSa1k1WlVoclkzSlVObGhDVmk5UlZuRlZielJCQ21GWU1sbFhaalpKTW1STFVu
      ZDBUMFp5YUZrMlVXRkhPQzh3UVhodVptVnFaSE5GVkRGM1pWZFZabE16V0c1d1JGSTVZV1Y0VVZR
      NWJXaEthM1ZJYXk4S0syMU5SblptT0ZwbVZXRlRVakZGTTI5Wk9FOVNXRlpYWms1dGFXTXhUR1F5
      WkZSU2EzQklSRVZoVG5WUGRuZHpkbU5hVDI1bmQzSkRaaTlJUTAxNldRcEdUR2xuVEV4TlRXUkpM
      M0ppVEhCbWJHc3JVRTVSWXpSUlpEVnlWbWxETmxKWFpVcFpLMU5FZG04NUwxaFdWbEl5UjJaTGFV
      MVBXRWhoWmpJcldreGFDblpsZERrNVlsTnZkbnAzT0c5SVRITTBhRVJKU1ZRek1UVTRkV0poT1V0
      VVF6Wm1VbWRXUms1UE5HNVpZVWxrTkhCd2VVbFpiWGc1Tm04d1RFZExWMUFLYXpocFZVeDVTR2RO
      VDFreGNYbFNWR2d4WmtzNVZHbDRUbU54VW1SaE1HOUliRU5HTkV0dU9HRnlkbVp2YVhCVVNtVm5i
      MU0wVmtkU1F5dFZSbVpSU1FwQ01tOVRNSFZRYVVSdFltSmxOMmh2ZDA5SVFuSXhSMjVXVm5aR01X
      OXVUM0Z3ZVZkUlF6UTNTVkppVVZob05IVktVSEUxVUhKbVVqQTVaV0pCV1RSdkNrNW1Ta0ZqSzBS
      MlQyaHhWMjAzVEVkRlZrMXdNMmhxVTA1c1QxazBXRXB1ZDJnMVEwUnRhbFZYTWtSNGIxSm9NRlEz
      VVZkalVUUmhMM0JUTTJaRGFWQUtWWGxNUjFsaGRIQlFSMVpqY0RsSVZFY3hUemcxTVd0QlpGaElR
      aXRPU0UxRFRuUkNVMEpXY1VGMU9WTXdXR2N2T1c1T2FuaEVTU3RDT0dsTFNWSkJVd3BGVm1OdlEy
      MVNTRmxvTW1GcGVuQlpNM0J3U0FvOU5HcE1SZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure Firewalld to Restrict Loopback Traffic - Ensure firewalld Package is Installed
      ansible.builtin.package:
        name: '{{ item }}'
        state: present
      with_items:
        - firewalld
      when: '"kernel" in ansible_facts.packages'

    - name: Configure Firewalld to Restrict Loopback Traffic - Collect Facts About System Services
      ansible.builtin.service_facts:
      register: result_services_states
      when: '"kernel" in ansible_facts.packages'

    - name: Configure Firewalld to Restrict Loopback Traffic - Remediation is Applicable if firewalld Service is Running
      block:

        - name: Configure Firewalld to Restrict Loopback Traffic - Ensure firewalld trusted Zone Restricts IPv4 Loopback Traffic
          ansible.builtin.command:
            cmd: firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop'
          register: result_trusted_ipv4_restriction
          changed_when:
            - '''ALREADY_ENABLED'' not in result_trusted_ipv4_restriction.stderr'

        - name: Configure Firewalld to Restrict Loopback Traffic - Ensure firewalld trusted Zone Restricts IPv6 Loopback Traffic
          ansible.builtin.command:
            cmd: firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop'
          register: result_trusted_ipv6_restriction
          changed_when:
            - '''ALREADY_ENABLED'' not in result_trusted_ipv6_restriction.stderr'

        - name: Configure Firewalld to Restrict Loopback Traffic - Ensure firewalld Changes are Applied
          ansible.builtin.service:
            name: firewalld
            state: reloaded
          when:
            - result_trusted_ipv4_restriction is changed or result_trusted_ipv6_restriction is changed
      when:
        - '"kernel" in ansible_facts.packages'
        - ansible_facts.services['firewalld.service'].state == 'running'

    - name: Configure Firewalld to Restrict Loopback Traffic - Informative Message Based on Service State
      ansible.builtin.assert:
        that:
          - ansible_facts.services['firewalld.service'].state == 'running'
        fail_msg:
          - firewalld service is not active. Remediation aborted!
          - This remediation could not be applied because it depends on firewalld service running.
          - The service is not started by this remediation in order to prevent connection issues.
        success_msg:
          - Configure Firewalld to Restrict Loopback Traffic remediation successfully executed
      when: '"kernel" in ansible_facts.packages'


# Configure Firewalld to Trust Loopback Traffic
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_firewalld_loopback_traffic_trusted,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# complexity = low
# strategy = configure
# disruption = low
- name: Configure Firewalld to Trust Loopback Traffic
  hosts: all
  become: true
  tags:
    - CCE-86116-1
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.1
    - configure_strategy
    - firewalld_loopback_traffic_trusted
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      cENUVkZCU1RWaVNXNWFVMHAzWTA1SE0wWjFOa3hNVEcxRlNUQUtjVUZ2WVVSVk5FTmlXRVlyY21G
      TVpWbDFTRzFPYURacmRrSXlNMGxEYjFSd1UxWTVaRUZQWTJJM04yNW9hazFRYUZoamJucGpabVJN
      YnpWWWF6RnJWZ3BQYTJaa1lrbzBOWFp0YTBKU1YzWndOMDE2YkRKcFYzQlBUemx6VGtKS1ZURlBS
      bmRQUVRSdU1sWTJTblZFUlVWTk1tMUhPRGhvUnpsc1NscFRVUzlIQ2tSTFdXVnJjMVoxU3k5aVFu
      WTJNbGx3Vms1bFRrbFJRa2haUkVrellUSXlUMUo2YWtaSFZIWXJNMGx2UW5Bek9WbG1OMlo0UzFN
      dlZVVkhhMlZHU1VJS1duQllRVnBvTkRBdmEwVTBaR1ZOU0daQlRrSlBSRmRFY1dsQk5raGpVREJI
      VVdzdlVVWk5XbWRtWWpsNVpFTXpXSEJsU2pVM1FVdzJRM0kyZWtwall3cHlaMDV1WVRaNGJFTTRi
      Rk5XZGxnMGQwTnlSamRVVVdGNllVMHJWRTUxTm1odk1tbEVNMUY0VEZZd1MySnZia3R3Wm5OSlpq
      QlRhRmxpTkRSTVptcFpDbWRvWmxVeGJscFhTVFJ5TlZGaE16Y3pkR3N2ZFZjd2FrZEViMFZoVVVr
      eGQydHpNV3RtYmpSc1ZsSktZbGxRTmpkTldEbGxhR05hWW1OeFZYSXliMG9LWTNkM01pOXZVbko2
      YmtWNVoxSkxXbE5FU1UxNmNsQnZPVlk0Wm05RVNWRkxLMGhRWW5rMGVraE9PRzl1TkVKRFltdHlN
      MWhzUWt0cGRETmtRbVJGZWdwbVRXdHFUWFZ1VldaTVlWQnRLelI0YTJkS1duQlJXRkZhV0VwcVNF
      TkZUakZGTTA1dFptOXJXbHBJZGpsUFlqSkNRVFZDWmsxUWNWSTNlREJuZDBkdkNtNDVXVEV2YzI5
      d2FtWm1Sakl2YVdSWmJVcG5Wa1F6YzFvMVRFVnVjMVJHZVZaTlIyMU9MMEpxZUdkek9FcEJValEz
      SzJWQlQxY3JUWE53WmxOTVVDOEtVV3BQZDBOclMzbFJRMjh6WkZkV1owcDZNRzlKTUVkUWRtaEdU
      bTVuYW5CdE5VczVNMlpFTVRCWU1rZHZZWFZoWjJWM2RGbE9TREo2ZDBsaVZHZFhUZ28wU2pKVmEw
      SlRlVFZuWVZack9HRlNheXMwU1FvOUwzZzBad290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Configure Firewalld to Trust Loopback Traffic - Ensure firewalld Package is Installed
      ansible.builtin.package:
        name: '{{ item }}'
        state: present
      with_items:
        - firewalld
      when: '"kernel" in ansible_facts.packages'

    - name: Configure Firewalld to Trust Loopback Traffic - Collect Facts About System Services
      ansible.builtin.service_facts:
      register: result_services_states
      when: '"kernel" in ansible_facts.packages'

    - name: Configure Firewalld to Trust Loopback Traffic - Remediation is Applicable if firewalld Service is Running
      block:

        - name: Configure Firewalld to Trust Loopback Traffic - Ensure firewalld trusted Zone Includes lo Interface
          ansible.builtin.command:
            cmd: firewall-cmd --permanent --zone=trusted --add-interface=lo
          register: result_lo_interface_assignment
          changed_when:
            - '''ALREADY_ENABLED'' not in result_lo_interface_assignment.stderr'

        - name: Configure Firewalld to Trust Loopback Traffic - Ensure firewalld Changes are Applied
          ansible.builtin.service:
            name: firewalld
            state: reloaded
          when:
            - result_lo_interface_assignment is changed
      when:
        - '"kernel" in ansible_facts.packages'
        - ansible_facts.services['firewalld.service'].state == 'running'

    - name: Configure Firewalld to Trust Loopback Traffic - Informative Message Based on Service State
      ansible.builtin.assert:
        that:
          - ansible_facts.services['firewalld.service'].state == 'running'
        fail_msg:
          - firewalld service is not active. Remediation aborted!
          - This remediation could not be applied because it depends on firewalld service running.
          - The service is not started by this remediation in order to prevent connection issues.
        success_msg:
          - Configure Firewalld to Trust Loopback Traffic remediation successfully executed
      when: '"kernel" in ansible_facts.packages'


# Enable Auditing for Processes Which Start Prior to the Audit Daemon
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_grub2_audit_argument,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = medium
# disruption = low
- name: Enable Auditing for Processes Which Start Prior to the Audit Daemon
  hosts: all
  become: true
  tags:
    - CCE-83651-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-09-212055
    - NIST-800-171-3.3.1
    - NIST-800-53-AC-17(1)
    - NIST-800-53-AU-10
    - NIST-800-53-AU-14(1)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IR-5(1)
    - PCI-DSS-Req-10.3
    - PCI-DSSv4-10.7
    - PCI-DSSv4-10.7.2
    - grub2_audit_argument
    - low_disruption
    - low_severity
    - medium_complexity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWTVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      NXVZMUF2TTBZNFFrZFVkMDlCU2pZdlRuRTRXaTlzUVUxUGFXSUtNazB3U2sxamRGbHdVMVZTVDJJ
      NU9VRTJOM2hNUzFKaGNVWndka2xyV1VWYU5uRlJNVEpVYXpOR1ZXd3lSVUYxSzBSVmRGWnBRV2RZ
      TURCUFdGWkVWZ3BWWVRVM2NIaHphemxqTjBwS2RUSnlXWFJYUm5GSEx6bEZUMUY2ZDFOVGNXVlBR
      VkJ3U0M4MWJFRkpibVZhY1RGUFlYSTJOM2x4Y25wYVZuUkNWVGhqQ25jMFJIRllSWEZtTVZsQ1FV
      Sm1TbUZuYzJkTk9HVktlbWRuVGtKNEsySmFZMnhRY0M5cGJVMVVZVkZtYVVkdVNHRlZRbmRrVlhK
      dEswOTNVMjVTVlUwS1VIZHdSMDlvYjFKaFEyWkZkMWsyT1VWWGFWZDVkbmRSTWtoelVXazBla05V
      ZW1SQlUwdHRaRFF4TkhCRlVucERkblZoV0c5NVdtc3JkVFJWZWpJeVF3bzFUM1pFVjNSSVRtUldV
      bGcwTVVwemNsTlNjMnBMU2xwbFQyNHZSbTVLTUZoRE1HRTJURmh4THk5SU1taGtZV1VyYzNad2Vu
      cE9jVVJtWXpNMWRYRXpDa3B6ZFZZM1QxaGljbFJGVUdrelUxSkRaMVpNZFd0TFdVMW1ZMk5XV0ZK
      MU9IUklUekV5TWtkTU5VeEpkRFEyVTBsWFNXRlNkVGgyZUhrMVQwOVlWSEFLVkRaSVFrVk9iWE5O
      TDFGNWJFTTFOMjFyYUZOQ1lXTktkMlZaWTA4MFVqbFRiRnBXTVdSQ1NrWnpPRmt4ZVVFek5FcFVT
      M0Z0YTBWb2JrMWtOM2d3UkFwMVZXRmFRWFZITmt0dGRreFBTRWRpYVVsaU9XbFNVMHhNTVRONFRt
      RmhjRGRLVVRsNVNGcHJjbVVyT0RoWlpXZHpOVU5NTkVwWGVWbERURmRZU21SekNsRnRSR3huYnpk
      VFJVMDBXREJMU0N0NU1XeDNVa3hLZGpCMmVIQkVWaXRGTUZaTlpVcHVUbWRKY0hKV1JYVk5kMk5V
      ZWxOemR6aEliamRYTlV0cllrSUtTRWMyVVZKRWFEZFhlRnBpWnpSblVYWnNOVE53TXk5Vk9HdzFi
      MXB0ZFROT05GSndWazFXU0ZsRVlVSXlRMjUzWkhNMGRYZHVaVlJvYVRGalVuazFTUXAyVFZRMFox
      VjBUa1ZXWVN0bFZraDZUMFpDUWdvOU5rVndLd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Update grub defaults and the bootloader menu
      command: /sbin/grubby --update-kernel=ALL --args="audit=1"
      when:
        - '"kernel" in ansible_facts.packages'
        - '"grub2-common" in ansible_facts.packages'


# Extend Audit Backlog Limit for the Audit Daemon
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_grub2_audit_backlog_limit_argument,fix)
# Version: undefined
# platform = multi_platform_debian,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_slmicro,multi_platform_almalinux
# reboot = true
# strategy = restrict
# complexity = medium
# disruption = low
- name: Extend Audit Backlog Limit for the Audit Daemon
  hosts: all
  become: true
  tags:
    - CCE-83652-8
    - DISA-STIG-RHEL-09-653120
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-10.7
    - PCI-DSSv4-10.7.2
    - grub2_audit_backlog_limit_argument
    - low_disruption
    - low_severity
    - medium_complexity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      b3dXVkZCU25ocVlVbERXbFUyTjB0WmRucENWSFY1WjB4V1pHTUtXVlVyVDNZM2NUY3lhVk5wTVd4
      SFRUbHVUelo0V2xsaU0yNUdjelJZVXl0YVp6QkZhbmwwVFVoTFRIZFVUSGx6ZEdSUFQzbEJVaXRq
      T0hjd2QyZFplZ28yZFU5NVYybE9MM2xUVnpKbVJYUjRRM0Y2YldrMmFqSTRiWGgwUzFSelZVdHVR
      amxEVGk5VldXbFZObnBET1dFemJITldPSFY2VGpBNFpVeE1kV05wQ2xCa01uUlNiSFZSZURGd1ds
      WnJPRlJMYkc5VVYxVjZRMnRtWnpGdE5Tc3dWMEpQYldvd1MzRlBiVWxGYnpkRk0yWXhTbkZuYzNW
      cFZqQTRhV2xzVTFVS1ZucGtkRWhUWmpGWFNsaDNabFZVTjBFdlNHdHFWR0V6Vm5ZMk0wSndTMWs0
      VWxoUFZuSk5WbmRaWW1Kd1UwNTVTVkpwYTBsdWNHRnZLMWhxUjBWUVFncFdWemM1YURsNE5qUnlh
      RkpGTVdFMlVXSkVVVmREV1U5aWFpOXBUbEJ6T0VFME0yeHVSa1kwUWxWRlUzcEJTMEZFUzFaNUsx
      bEtURTVJSzA1UU4xVTBDbmd5WmpoM1ZGTnFaVWxhY2psUFptSXZiazFvUmxGbGNFbzFkMHMzWnpG
      RFZIbDBaV2x0Um1WbWRtdFFSWG96Vm1wcU1HRmpWRFpsVlZndllrY3JhMndLYVhWck9UTTJNbUpE
      YUZRM05TdGFOemx0TVdrNFVsaFpNV0ZIVG5KamVYRnVaWHBQUkVaTFNqZDJSMEpaTHpoWVYwNURa
      MWM1VlVaQlMwdFZTSGhMWmdwNE9ISXJjRVEzU1cxbkszZExTbU5XVUROUFQwWnpjelpCVHpkTGMy
      d3lWVE5wTnpoWmNVSmtWVzFqV0VzcldYQkJjMVl4V25oWWQzSmFibUZtZEV4UUNuaEplbGxKUVM5
      VFNFczBOa1pzUjA1M2NVNXNjVmsxZWxORWVXUmtOV2hPYlc4NVJYcENTVWwwVVdwNFprTlBXa1ZR
      WTFwVFdsWm9WRGhuTDBablFUWUtWQzlWZDNSQk5YaHRkMHd2Vkc5WVJIWldVV05tYkc5dFdrSm9M
      MmRQZUdadWRVbHdNMXBOVjA5emVETktRekZ0TVhCVFVGWjFSemRNU0ZkS056RjFLd28yYmtKalNY
      cFFXVVZOUTA5UFZ6TnFOVkE0WWdvOVFtcEROQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Update grub defaults and the bootloader menu
      command: /sbin/grubby --update-kernel=ALL --args="audit_backlog_limit=8192"
      when:
        - '"kernel" in ansible_facts.packages'
        - '"grub2-common" in ansible_facts.packages'


# Ensure journald is configured to compress large log files
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_journald_compress,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure journald is configured to compress large log files
  hosts: all
  become: true
  tags:
    - CCE-85931-4
    - journald_compress
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      VmtkMUF2TXpWcVZYcEpNWEU1Y1hjMU5WbDRPSHBwT1daeVJuSUtSek41V1hKdldtUnpUWGN3VkZK
      S1VUbHZTbVUxYWtKekszVkRVa0p4ZHpkWFRXOHJOR3hOUlZwRWRVTjFaMWd2TlRoM2JDdDFjMWhr
      TDNaalJGYzNPUXBYWW5nMmIxRllhREp4TVRKcGVWTlBOM3ByYUhsdlVYWTBlamRUU0U1a05FODBR
      V1UxU2tveU1sUlVhM2w2VVZGdmFFTnliR3htT1RJM056ZDBiR2RIQ25OdU1sSnVUSEF3VGxnMFYz
      QnFhV1ZpY21OdFJWbFdOa3MyZGxsT09EZERMMUJOWW00eFEybEhZakFyWjBGb1ZHTTVWbWR1T0RG
      NGQyODRkemcxTmxrS1EzQldkbkp1V0RKTlNFNXlaRWw2ZEZJdlNHNDRXRFF3T0RobE1FWTFSM1ZD
      SzJOUU1sRlVSV0ZGVm01NFlqYzVMM0pKYTNSVmExaDZZbmh3ZEVsbVlRcFZNbTlwYjBwdVprNUhj
      RE5FTHpCTlRYVlljRE5PYm14dE1XcDVRek51VG0wM2NGZ3JUSFJOU1VSSk5VOHJabm92YXpGS1RH
      NWxTM1ZhWVhkSWNFUk1Da05JTTJodVpXRjZlbHB1TUZkVFNVRjNNWFJXUkhVM2RGUnFNR0ZUYUVs
      aWVrMVZTR2hEVWxGT2F5OUVhV2szYkV4cE1tcFpZbXBPVDAxcFptaGhXSG9LYVhOM01uQXhTR1ps
      UVdSMk1tTlhlWE5DVFdwbVRITnRRbnB6VkcwMlRERktVa0ZzU1hWT2JucExSWGhoZFZSVVpEVnlU
      akZHUW00NVFWWkNXVkp3Y3dwd2NGRnZVRVp0VmxOcFpVRlZiM2xMYms5bFMyUk9iSFpUZGtkWlFq
      WkdhM1pYYkZFeWFucDJWVTB4YUc5eFZrbEVNRmxCVDB0TFIwSnllRU5HTWpCaENsQlNaR1ZHWlda
      Q1J6SkVVRUpKUVZKdFptSTNUMDUwV0ZsSGQwMXNURTV3Vlhoa1dIaGpiM2haSzBORVZtNVpaMjFH
      UVdFdlozUlBOR1paVGxsT1FpOEtabmt2WXl0Vk5tMWlhbEoxSzBwTlVIaDZSRFl2U0hKdk4xZERa
      ak5LTVhGR0sxRnpSSEZJTVVScGJHSlNjRWt6TjNkeGJEYzVSVWRSYTNoaVdIRnpXUXBoV25wWlZH
      eHRRbFUzWjFCWU9GaEVkVGhETkFvOU5sRkZlQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure journald is configured to compress large log files - Search for a section in files
      ansible.builtin.find:
        paths: '{{item.path}}'
        patterns: '{{item.pattern}}'
        contains: ^\s*\[Journal\]
        read_whole_file: true
        use_regex: true
      register: systemd_dropin_files_with_section
      loop:
        - path: '{{ ''/etc/systemd/journald.conf'' | dirname }}'
          pattern: '{{ ''/etc/systemd/journald.conf'' | basename | regex_escape }}'
        - path: /etc/systemd/journald.conf.d
          pattern: .*\.conf
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure journald is configured to compress large log files - Count number of files which contain the correct section
      ansible.builtin.set_fact:
        count_of_systemd_dropin_files_with_section: '{{systemd_dropin_files_with_section.results | map(attribute=''matched'') | list | map(''int'') | sum}}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure journald is configured to compress large log files - Add missing configuration to correct section
      community.general.ini_file:
        path: '{{item}}'
        section: Journal
        option: Compress
        value: 'yes'
        state: present
        no_extra_spaces: true
      when:
        - '"kernel" in ansible_facts.packages'
        - count_of_systemd_dropin_files_with_section | int > 0
      loop: '{{systemd_dropin_files_with_section.results | sum(attribute=''files'', start=[]) | map(attribute=''path'') | list }}'

    - name: Ensure journald is configured to compress large log files - Add configuration to new remediation file
      community.general.ini_file:
        path: /etc/systemd/journald.conf.d/complianceascode_hardening.conf
        section: Journal
        option: Compress
        value: 'yes'
        state: present
        no_extra_spaces: true
        create: true
      when:
        - '"kernel" in ansible_facts.packages'
        - count_of_systemd_dropin_files_with_section | int == 0


# Ensure journald is configured to write log files to persistent disk
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_journald_storage,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure journald is configured to write log files to persistent disk
  hosts: all
  become: true
  tags:
    - CCE-86046-0
    - journald_storage
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      QjVTVkF2TTBKcGN5OUtORnAwVjFCV1VGZExTbFIyVjNaa1l6SUtNSEZpWkdrNVJsQkJVbXBxV2tN
      clZVaENRblpVVjBWUldWbHVWRE5XU0ZoRFIwSlhMM3A1U20xVlVYRlJNVU5MT0ZGdGFGcEpSMEYw
      TVdObVRtWlBjQW80T0VKYVFUSkpaVmRsVkZKb2JVTktNVTFyVkhJM1dVUTNRbUYxT0d0dFluTkpW
      blpDYVVzNFlYRTBSRlUxYzJoWWMyOVNSMHAwUVdSQ1dUaFFXR2c1Q21abmVqZEJhMDVFUjNVM1lt
      Tk9WRk5QVFhobWEyRnRUMDVGWjJwTlVHRnlWa3hEUWl0MFdGZERMekkyYTBNM1dIUlNjWEI0VG5K
      VFZYcHVZVkV6Y25nS09UUTBNRTVWZFhjNVIxY3JVVTB5TlhwYUwzWjVlV1J3T0VGa1lXSldhR3RT
      Y0ZBNVpFaHhTbmhYTm5oSFNpOVZaREp0VUU1WlZtVktSVVZaTW14UVpRcGFOVmxOYWtsQ1MwNUxV
      RkV3T0V0VGRtZEhiV3BIVkc5dU1ISXlZblZDVmpocVYycFRMMUV4WVVRd1NsRTBhR2hsVVhweE1E
      aDNlbTlCWkROMVkwMXNDblJXTkc5a2VVNXZNMmwzVFRKb2VXUXhZMk0yZG14MlpuQjVLMEpVUW1G
      MWJXTkVUbVZwT0daclRVRkVUMUk1TTA1M1FuZDZWM0Z1T1ZOalpGRlNSRkVLY1ZSdEswaEZRM2xp
      TnprMFkzZzFUWGx6U1U5TlNtZEVjVFpTTUdoV1lsbEpjVU5yYUhGRVZUZFBOeTk0UVZKNGQyVjRO
      SFZGTTI5SlNrcGhVMmxKUlFwWmNtdE5hM3BZS3pGd1RrUkphWFpLYVVaNmFtWkdVVGxHTXpWa1RW
      bGxhazEwVW5SU1dVVjJUVEpGY0hWcFkyZFpTRmhVYUhCSVp6aHFXWEJuU1ZOdkNrSTFNbmxITTJn
      eUsxbzNhWGhDWlN0RWQxZ3hTbk5pYjNNelRFY3lia2hNYjJVMFNFWjVlbmxuU1hKbGJFaGlkM1Zz
      VW5CVE1YWkVhRkl2V1ZCRGVYUUtiRWMyZHpsV2FGbE9aMEpVYm1kRVUyOTRPRXg0TkVwWWRteFBN
      R1ZVVlVaSlNHWmFPVTFuUzJkVll6WjVUWFZoTlZoUVdtb3dXWG94ZGxoeFltNWtZUXBLVFdOeFNu
      cHpOSE5aVHl0UmFreFRUMU5EYkFvOU1HSTBVZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure journald is configured to write log files to persistent disk - Search for a section in files
      ansible.builtin.find:
        paths: '{{item.path}}'
        patterns: '{{item.pattern}}'
        contains: ^\s*\[Journal\]
        read_whole_file: true
        use_regex: true
      register: systemd_dropin_files_with_section
      loop:
        - path: '{{ ''/etc/systemd/journald.conf'' | dirname }}'
          pattern: '{{ ''/etc/systemd/journald.conf'' | basename | regex_escape }}'
        - path: /etc/systemd/journald.conf.d
          pattern: .*\.conf
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure journald is configured to write log files to persistent disk - Count number of files which contain the correct section
      ansible.builtin.set_fact:
        count_of_systemd_dropin_files_with_section: '{{systemd_dropin_files_with_section.results | map(attribute=''matched'') | list | map(''int'') | sum}}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure journald is configured to write log files to persistent disk - Add missing configuration to correct section
      community.general.ini_file:
        path: '{{item}}'
        section: Journal
        option: Storage
        value: persistent
        state: present
        no_extra_spaces: true
      when:
        - '"kernel" in ansible_facts.packages'
        - count_of_systemd_dropin_files_with_section | int > 0
      loop: '{{systemd_dropin_files_with_section.results | sum(attribute=''files'', start=[]) | map(attribute=''path'') | list }}'

    - name: Ensure journald is configured to write log files to persistent disk - Add configuration to new remediation file
      community.general.ini_file:
        path: /etc/systemd/journald.conf.d/complianceascode_hardening.conf
        section: Journal
        option: Storage
        value: persistent
        state: present
        no_extra_spaces: true
        create: true
      when:
        - '"kernel" in ansible_facts.packages'
        - count_of_systemd_dropin_files_with_section | int == 0


# Disable Mounting of cramfs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_cramfs_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of cramfs
  hosts: all
  become: true
  tags:
    - CCE-83853-2
    - DISA-STIG-RHEL-09-231195
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_cramfs_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      RlpiMUF2TWtaNkswTXhiSGRoSzJOU2FFZEZTMnBDVnpWM09VTUtjME5HTlhsd05tZDZOM2MxYW14
      TUwwSnJlVVF5YVRaU1RuZFFOV0l6VFRoNGEwNDJORTlpYlVONFVHUkVVM0F6VjNOUFpEZGtSMnhV
      VVRGemQzUkROd3A1UTNrNU5rbFNabWhJZWl0VFRtRjFiRkZMUlhkblpHTmpUa3RQVVRWMVMwZzNj
      WFpWU1RWQlRGTnlURWRQYWpWS0t6Um1aeTlYYzJkTFpVUllVVkJJQ2pGWWVuTXJjWEpJU1dvMWVW
      aEhjSFZJTkhsUlEwUnNVMkp1TlVneVdtSnNkbTFQYzBvMFZEUlJiVGRNVkVWdmNUbE9WMUF4Wnl0
      NmFrRlVPRlUzVDI4S1VURndRa2xMSzJWVFUyZENhV3hUWmpaR1JWbE5iVGxWYjNVNU5HSm5WMkUz
      Y1hOTFV6QkNOMmRSY0N0VFZqSlVOMEp1WjB4VmRVbEphVEJvYmtSSVpncHpaVmhEVFRKM1NraElN
      bkZHUjFsUGRUVkRVVE51SzNCeGNYVnBXSE5vTm1jM2IyTmhkVEp3Wnpaa1NWbEZZVVpaUzFwTVYw
      VlJUamt3TlZkWmMyRlZDbE5yYmpoR2EwZGFRbGR1VkhaU1FUUk5jRkpoZEd0V2ExUmtRMWszU0VG
      aFFXbG9SVVJWVDBWeFJGazRWM3BsUmpRNVZWSXpUa3QwVlRsbGEzVkhjMWdLYnpGSmMzZHBMMDFH
      WTFjMVNHOUdVelp3YVhwWGQwSk9RMVYzYUdFemJYTkdOR3hXZWxGaE9DOW1aR2huT0N0M1JYTlJk
      VTlYVnpRM2FYQk9iV2hCU2dwNU9XOTBkSEJCUWtod05FdDZaVXhCTXpWMWJWQllNSFZMUkhkMFQw
      Uk5NSGhrZDNWWGFFbGtlRzVWYVZKWVpEaGtOV1paY1VSWmFuVk5aa1ZaU1dkSENrbGhSRlJhUnps
      T1QyWmhibk5MZWxsVVNHbG9OMU5JZG1zNE5tcElVbU51U0VaT00xSnlNbTlzWVc5QmFFdEhURVZZ
      VG14dlRrTk5aaTlJVHpOWllWa0tWalExUnpaSFdGaGllRUZRWTNGa04xY3pVSFZGYUZkTFZ6QlZk
      VXRyVGtadFZtbHNUR0ZMTm0xclZWRnJNekJYV1hWeFkxWmllVk5QVFhZeVZFSkNVZ3BXTDJ0WVdX
      OUdWRVIzVHpObWRGTjJabEJtV1FvOU9GSnhNZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'cramfs' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/cramfs.conf
        regexp: install\s+cramfs
        line: install cramfs /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'cramfs' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/cramfs.conf
        regexp: ^blacklist cramfs$
        line: blacklist cramfs
      when: '"kernel" in ansible_facts.packages'


# Disable DCCP Support
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_dccp_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable DCCP Support
  hosts: all
  become: true
  tags:
    - CCE-84136-1
    - CJIS-5.10.1
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSS-Req-1.4.2
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.2
    - disable_strategy
    - kernel_module_dccp_disabled
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      RkVSVkZCU1dJeGJEZDBLMUphSzBoQ1JXZDBjbEpFYzNkeFZHUUtaRTVaTVRkTWJITmtWVXR2TTNo
      UlZXY3liamRoY0ZsVlZtUXdSblphZFV0bGNWQklWa1JTUkZCb2QydFRjMWRvV2psQmVsaEdZa0kw
      V0ZZeWRYQXdiUXBWUTNsVE9GRTJjMlZqYkdkTWNXWnhPVGxqUzBsVk1Ga3dSVkl3V1VGaFJsQXlO
      MUZFWmpCYU5FMUNiblV4UzJGb2FIaFRkakUxWVRNMVNqVkpNakZOQ2xCR01tdzFWV1p0UTIxVFdY
      SlFWM05CUm05c2NFZDVaaTlyTlRsd01HSjZXRE00TlRCR1l6VkhSMGN6Um1Gd0syZ3ZZemxYTmtW
      a01VRXJZVmwwVEVRS1dFWkdlQzlRVGxaVmEwZEJPVmRuTTNFeWN5czJhMjl1VG0xQ1ZqbFFPVlpH
      ZEZab1prRnBOR1ZLTTBkcGRHbFhabU56VGpCb1lUTk5iVXRtY1c1aU1RcEtkR1JRV1hreVQwbDBS
      RWhuZEU0MFdqRkhWWFZ2T0RBemJWZElRVkZyY1M5MGFrcFhjbTU1TW1OU2VUQXhjMnROYVROMllt
      MUVkVVJQYW1ZcldpODJDbFZUTlZZNFVIb3ZNbXRoU0N0eFkycFhkV2xPWW05dVNWWXpiVlZKYkVs
      d1R6aHBSblkxZDFkNVRFOW9kalpEWWxrM05sZFViV0pqYURWR09GQnRLMFFLZVZaaVNYaEVkbEZx
      VVcxb0szZHpVRFJKTlZKU2VEVXdXWFZvWlVWbmJtcE1VRUY2TldGak1FNURVMk5oUm5wTldISllh
      R2s0WXpGM09GZHljMHRWVmdwTFRHOTBPSFZEYlhrdlRWRkxPVnBJUlVSTlRtY3hVR1F4VUVwT01T
      dENRbGhuYTJJeVVXRm1TMVpHU0VOelYxaHVNbkUxYlU5S00yTkZXRVZzTTBsaENsQlZOV2xWYTFO
      MWVFSlZZWG9yVWxGVGRWVXhlbFpKWWxCc01XbEtVMEZxV1UweU1sRkRPSHA2U20xS1ZIZ3dZVTA1
      WjFoSmJURlZaVlJJY1haVk1sQUtUMUYzZWtsVlZIbHhhaTlLV0hoWlZtTk9XbEJPTjA1bk4yVm9P
      V3hpZVM4d1QwVmpWbXBFWjAxUU55c3ZZVmxUYjA5R1pWUTRUamx3VTFveFMydExVZ3BtYVVwdE9W
      SmpUQ3R2YVRoeFJtNUxWUzg0T0FvOWJrOURlQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'dccp' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/dccp.conf
        regexp: install\s+dccp
        line: install dccp /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'dccp' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/dccp.conf
        regexp: ^blacklist dccp$
        line: blacklist dccp
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of freevxfs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_freevxfs_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of freevxfs
  hosts: all
  become: true
  tags:
    - CCE-86763-0
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_freevxfs_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      dFJjMUF2UVRKYVdUZDBURWxZWW1OWk9HZDFjV0ZqWjBoWmJqQUtkWFJvYjJ0c1pHaEplRlEwYVRo
      YVFuaEJUV1pOVWtWcFZGaHlPVEZzWkRWMU1XMTZORFpaY1dKSlRVcEljbHBSYzBSUFVEQnBPQzlM
      VEN0dFYwMDVZUW93ZVROMlRFSnlRekJ3VFdWbFVVTTBjbGxtVGtVdlExbFRhVGxCVFZsMldGUjFj
      bGxDVEZNck1UaDBRVzlFWlhOV1preHBTSFZsUW1WTGJGWjNlbVZpQ2pCdWFYVllWU3RhTUVONFdV
      aDBiek4yTm5keWJUVlJjbHBRV0ZaS2VrcHhOa0p5WTNwNGFFSndWbWwyWTBkVU9YWnVjREpETkhG
      T1ZVdFlTbnAxUW5rS1NYSkNkVWd6TVdvNFpFMVhkbFZGVGs5TlpuaFlNa1ZUV21GclVFMDJSeTlq
      TkZkelVVTm9VVEphYlN0WWVYRXplVFpoU1ZJMVkxTXlORGRXWXpCRmJBcEhjRGxsY1ZSTWVsVnRS
      a292ZUdkbVFXMHlUakJCTVdVdlJsSnFNVWRJUzBoSFJ6SkZReXRMY1VWc1ptVlhRM1kxTWxRMWVI
      RmFiVTlSTlZwQ2VWcHNDakZ5VWpJeWNUbHFkVUpuZFVvck5tWXZObWt6UkRFM1JWaElkR3d6WjJv
      clltVm1TbnB0V1RkMVJsbzNSbWx1ZEVKelVqTnVZMWxWV0dGeGVsSm9Lek1LY3k5bWRXeFRUMmRu
      TTJJcmJreHFVa1Z4U0dWR1JuZEJkVU5oSzNFNFJpdFZVV3BzUTB4c1YzQk9ZbXhIWXpreVNHWnda
      SEZZY1doT1lXeFVWazF6VEFwM1pFVm5WakJqVlhCWWFuaFNVRGR5WVVsSVNuVndWSHB6Ym5KblEz
      SlBhRGRGUkhoU1ZsWXplV2hoY2pSVlNUTjFaelZyU2tWYWNHaG1VRGN3TVdGUUNtbEVZM1ZDYUVJ
      MFRsRnFiVTlqVXpWT1ZVOU9ja2RDVFdWR1REUlZVbEpSTDJkb2NFSmhhMmc0ZERNNVFUQnpRMVl2
      ZUZBelIyUk1lRmcwUkhsT1RGWUtUbWw0ZUZKM01ETTBUMFFyUkhRMGIzRm1hbVZ2WmtOa05rcDBU
      MlJHUVZaUlRYQlNNVU5FVDFNMVRFZDRRbmx2WnpOV1YzQkphams1WmtrMUsyMVdSUXBSTDBWVVRH
      RnRlakpIZEZVdksxUjVOamc1VVFvOVRVbEhOQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'freevxfs' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/freevxfs.conf
        regexp: install\s+freevxfs
        line: install freevxfs /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'freevxfs' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/freevxfs.conf
        regexp: ^blacklist freevxfs$
        line: blacklist freevxfs
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of hfs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_hfs_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of hfs
  hosts: all
  become: true
  tags:
    - CCE-86764-8
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_hfs_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEWXZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      bFdORkF2YWtwdFVrZDRWVkE1U210eGNFeHhXRTVLZEdZNVFuQUtjRTluVm5ST04xUm9PV1EyVm14
      cVVtSnhTVW9yVGl0SVZrdHdWbnBZUkM5M1IyaGFhVFJFTTJSaWNtOUdWbU5EVm5KTk1sVlhkVEJ3
      VldNNWVEVm5jd3AyT1Zac1NrVTBUbGt6UzBnd09GTk1URGRoUVVaSlRHbGxTbTFGTmpGTlNIVm5k
      ekp2Wm1keGMwSkdVMWhSY3pObVJTdDZiM2xpWjJwbFl6RmpOMkZLQ21SaWRsWktSMHBqVlRGT1pU
      VjBSMjg1ZUhWU1JtZDFSa1ZMVUd4alpYWkpVVEZQTjBWb0sxQlNUV2RGZERRemFYbHBWamt5ZFc1
      T2VtZHJNVWhvYWtVS1ZrdFphVTFsV2xvelMzRXhTME42YXprclUxZERlRzV1TVZkWVNWUmtNVU5I
      TDBoRVkzSnZUSGx1V1d3eGFtdHVTakVyTWxsUEx6QjJXalExVFZJNE5ncDJaM295YVZwYWFrczNT
      VmxJVTFvM1YzbE1NbGRuUTFNeWJXaDFUV0ZZU25scGVVRmpSMUV6Y1hsUVYzcE9ZVFJIZEVsWVFV
      MHhkbTA1V2xSRk1VaFpDa3BuTVM5NU9GZEZOM0J2WjAxUVZqWkpiMUF2WW1GcmRrVk9jVk42ZG1S
      dmFuWjJkRmhUVEd0clVrSkdUM05CVERGV05rWlJXbmwwYWpjMWRIZHlZbWNLYW5kdVRuZFpSV3hx
      YWxrMEwzRk1ZVlJZWWpOelVHRm9OV2RhU1d0dVR6aHlOMkpCYkhFdlJqVmtXa0ZMVFhwTmRXZFdl
      RVp3THpkV1MySlZPSEp5ZWdwdlNrUkNSeTk0WlVGRFMxSkdTbVZWYzNoNlNGZFNMMlZQU1dSRE5F
      OTNiR292U20xMU1ucFFNbHBzVW5Sd1FuZFZNVE50Ym5SRFdEaFllbkJwU0ZGcUNrVm1ZMmRrVEd4
      NGRTdGhiekYyTVdoNVdtOXJXRW93VHk5RWNqUTFWR0ppYjNjNFNFZFNZbTh6Y1hsTmRVbFVkbTVa
      VDJ0SlJXOUxTbVZ6TlhaRkswMEtVRFZGYTNSUmVWQnVWRTFGUlZCWFRrMXVPR2RGWkZSdGRUVjNa
      VGRrVUdSRFRrSTRWVlpXTWtoYWRIWkNhV2MxVVVvMlFsQlBVQ3R4VmpOcmVWRkxSd3BQWkZoRVVq
      ZFVUV05XVGpWb01UVkpjbFZwYUFvOWRVcHVOUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'hfs' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/hfs.conf
        regexp: install\s+hfs
        line: install hfs /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'hfs' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/hfs.conf
        regexp: ^blacklist hfs$
        line: blacklist hfs
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of hfsplus
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_hfsplus_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of hfsplus
  hosts: all
  become: true
  tags:
    - CCE-86765-5
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_hfsplus_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZEJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      VmFUVkF2TUZNek5rYzRNSEZTTUVoRlpXZHVUVmtyYTJJNVIza0tOMGRzZG14SmRFOTVNMHBVUVZO
      T2VFNUlWRWsyTDBod0wweGpWRTh2YVVaWlduWnpXWFJIYUZOU1dGZEJhMVEwY2xSTFNTODNXVmNy
      UkVKd2NFaE1VQXBoU2tsTFNTdEhPRzE0VUdkWWR6WXpOV3hhYmxoMk9WVTJhV2R2VUhSU2JEYzNl
      VGM0VlM5aWFucDRlV2x0VTFobk1EVjBSMnh2VkRjNU1URnJPVmhOQ2tkNVN6Um1ValJ4WVZsUWEw
      NDFMelpMYXpKc1NuZFZZV2s1UkdoV1REaE5aSEJqZDBnMmFWa3hUSFpyUXpCV1YyRndjM0ZvTUhV
      eFMyVmplbWxIUW13S1ExUjVRVEF6YmpWTk5FaFpTMjVJVFM5aVREaHZZbkV3ZEdwaU9FVlVOVVpp
      YjNscGFFTnlORUY1ZUUxMGRESnBkVGRhVEZjdmNHZGlaSHBMTUVoNFlnbzJWVmgzWW1oUlEzRmFP
      RVlyZEhWekwzbHlXVFpNWm5ReGMxZHBWSGt4WW5KMVQyTlROM0J6TTI1YU1IVjRNa1ZYT1hCcFky
      SnBVRVU1Tnk5T1NHOHhDbWxKVVhOUVZHMTFhR050ZFVab2IycEdkbkU0YUdKRGJWRldkbEZ4UW5o
      TVEwWXJiek5EUWpGeU1ucFVSaXRzYkRCSmNFdFZTMVIyZERWR2NrRm9kbXNLVW0xVVpuWTRSMWhC
      WjFWbFRsQk9UbVkzYmt3M1pTczNiMWgwY0c5emFtRm1iVEZVZFRVeFNGQTFaWGRzV0V4VU5rTnBZ
      VVZXY0N0aWFWZHliakZKZFFwVmRtdEZPV3BaY2pWaWVFODRTMDFLV1dsclVraEtlVEZuUm5OTkww
      NXlRemRsY1ZaNVJrWmhRa2huTmsxeFZuTjBVbGRUU1ZKS01rVTJMMkZoZVVkRkNqRklkR2tyYzFk
      dVREbHhhSEJZWWpsUVdXNXRSV2xyZFRGQlRVMXliMDFuVFc5clUyWjFXakpTYjJsdGNqbDZlbXBW
      TTFoM2VXbDJVM3BrYUZORVZVRUtXRkZxVkVrdlVERjRjbkZ4ZUdwMU1VZFdVRmt3VkU5Q1FYZ3pN
      ekExWW1seVJuTm9ZazUzY0VwdlRtNU5kMU5JY1doRk5XWnVaREkzV0dObGIxUkxZUXB6V0cxUlVp
      c3lkbWtyVHpGQ1EycFdRM3BwUlFvOVYwTnNjd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'hfsplus' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/hfsplus.conf
        regexp: install\s+hfsplus
        line: install hfsplus /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'hfsplus' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/hfsplus.conf
        regexp: ^blacklist hfsplus$
        line: blacklist hfsplus
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of jffs2
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_jffs2_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of jffs2
  hosts: all
  become: true
  tags:
    - CCE-86766-3
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_jffs2_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZEJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      cEJXVkF2TXpGaGVXRTVlazFsT0VOb1UzbDZVeXRsVG5CV2QxZ0taMVJrU2t0YVNqQjBTRGgwVm5C
      NWEySjJXR1p2TVc1UmFEVm1iMjVSTW04NE0ySm1XR05JT1RGa2VWWjFiSGR1Ylc1NGNrdHNPRkZN
      UldGMVpGZzBWZ3BWV21SWE5XSnBMeTl6VjFWM1pFUndZekJrYTJWeWJsWkJaRzlRU3paUk9ERllP
      SHB4Vlc5cGVXZEhMMlpLVFcxMVMxWmxNVlV5WjJ0bWR6TmFNVFZSQ2xoVlMxaFJRV3hFU0c1clky
      ZFdVQzh3Y0RaM1VWbFVTMUp6ZVhJeU56SXhjMjFWUWxsUU55OUVWWFJOY1hWTFlsVTBhblJTZDFK
      VE1XdEtaekZVYWtNS1NIZFZhaTkzZUhOWFJtcGFNMEZCWlVNeE9WTk5ObGtyWVZGWmVsWmhjRVkw
      YmpaeGRrVnVUU3RVVTBGVFEwTklUREZPZVRkd1J6aDNWekZzUzJZeGVRcFNOa0Z1V2tGRlRIUnRW
      MjB4TDJoUFZtVlBla2szYnpaVVFXWjROamw0YTNCdWFrNHlabVl4ZDA1c2FUaE5hakl2UjI1SFpF
      cHdUREpVYjBGMk1rSjVDa2hZZEcxVmJEVkhZMVZLYkVaWmQwNDJNbms1VUVRdk5sRlFUWE5RUm14
      SWNFMHlSbVJHS3paSFRIRlJTVXhKVWxoSVNtaHRXa2t2VGpWM1pEVk5ZMUlLYXpObFJGRlZiWFp4
      V0d4U1Z6Rm5iRzl2VEVkU2JHSXdRbWhuT1dKcGF6QnZkRlZSTm5ndlpHdDFia1UwY3paQlNHc3pa
      bFIwWkdKTFRTdDZVWE5RVEFwUGFreE9TU3M1VWk5ck1XOW9OWFYwY1hCQ01EZHpaMjFNYW1Sc1My
      cHdURkpqUTBwUmREQnBjV2RHU21STGVtSnplRTgzT0VGcmFUTXpVVGhSUm1WdENuVXJSbnBxTWpa
      dWVITmtRVmR4VTBSellrMW9XSEZhUXpVeFFTOWplbElyTVhSelJqa3JkMEpVVEdaU2VEaDRaRmxO
      Y2tZMFdTdGFZV2czYTFwSWFuZ0tSV293TTBJdlVuaEhiV2gyWWtrcmVsWnBLMlpvTjNoTVdIQkZX
      bFpQVFdoUVRXaFBXREEzTnpWVGNGWnFiVmMyZG1odVUybGtWalpWUmpsclpVTnJlQXAyVmtoTWQw
      TkpOaXRwU21KcFdtTTJNbUp2Y3dvOVFYSldLd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'jffs2' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/jffs2.conf
        regexp: install\s+jffs2
        line: install jffs2 /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'jffs2' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/jffs2.conf
        regexp: ^blacklist jffs2$
        line: blacklist jffs2
      when: '"kernel" in ansible_facts.packages'


# Disable RDS Support
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_rds_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable RDS Support
  hosts: all
  become: true
  tags:
    - CCE-84064-5
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_rds_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZEJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      ZE5SVkF2TUdONE1HOVZUR0ZxVUVJeE9HNDFUMVJuVDFwbGNrNEtTakpXTjBWVVQyTXhSRXROYVU5
      U2MxcEJSMFZIT1ZwUFRqTkRSRFZvV0N0aFptNVVjbVF2VjBZdk5FNVZOemxVWkVGdVRWRnlkVTVI
      YTBsVGF5dFFMd3BwTW5GRWREZFFSMEV3WWtKaU5ubExhVFIyV2s1RVoyWnNUMWwzZWpjMFEyVlRT
      a3hCWjJkc1MwTktPV3h5VGtWRlMxaHFkVXBMTlZKcE5sWTFaVFpMQ25jcldqRkRkbnAzSzJKaE9F
      ZEVTRFZaTlhwc1JFbDNjVTltWlhvMFF6ZzBUa2szV2k4eE4wSlhkWHBGYVdWUFNHWTBZVlJrWkdS
      SGJDdEJjbXhCVG0wS1JpOTZMM2RyVFRaNWQxQXliMWhTZFZZdlVWbGtOMDVhTjNGaFluVkliMFJJ
      YW0xaVpIWldkMkZ1V25aT1kyTk1TMmhXYzBoNU5HWTJXbFJZWlhGeVR3cExjVEpwZFhWTk9YZE9N
      VWhVY0V0NFNVWnVUVWQwTDJGSGJpOU1SR2RSVFRkSk1tSTVZMFpoUlhaV2VHbzBVbVJ1TTFkMFIy
      cDJZazVZVVV3eWFtRkxDbXhXTlU1YU1sUnBVblZ3VDJvdmIwOUVkbEp5U0ZsMmQyeHFhVk5xVnpG
      bFVEQkRWek5qYVcxVFdraHNNRFJPYjB0QmRtUkRlVkZrZFhONmQxSlVkRzhLYVcxdWJFcFljblpH
      ZFc1RmN6SjNVSFZRZFRoRVFVdFlhVk5oY1RWR2VXbHRUemNyVFhKdmNVSnpOa1Y0VFhSWWRsYzJP
      RXB6YlU1TFowSk5TMFY1WlFwRVJtUmxhMmhNY2tkWk1WTm9OV2R0U2pSQ1dqVjZWSEo0TURsM1VH
      bDZNVXRtTkRRdmVqaFlOREp3Tm1Zck9FUkJXbXRpUkRRMFZHeHpkRzVJZWxrNUNrMXFlWEIwZURo
      UU5pODBUR1JMZHlzdk9FcEZjSHBsWlRneGVWaFhSSFp4WVhObVdubG5hMlpoVjJ0eWRWSjNSWEZW
      ZG1kdmJuWjFWVWxJT1RaWFNqa0tZMjlhYTBzMk9UaEdjMHhoT1Rsc2EwbEpXR2cyYkhSclpURjRS
      elEzVFhwVWFIcGlPR2RTY2xKMGVWWktURTF2WjFoc1dtMVFNbTR3WVVVME0wMWFMd3AxWm1WaFEx
      Tk5NR3d2Ym5weGJVbFdVM2RWVVFvOVpHUXJjUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'rds' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/rds.conf
        regexp: install\s+rds
        line: install rds /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'rds' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/rds.conf
        regexp: ^blacklist rds$
        line: blacklist rds
      when: '"kernel" in ansible_facts.packages'


# Disable SCTP Support
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_sctp_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable SCTP Support
  hosts: all
  become: true
  tags:
    - CCE-84139-5
    - CJIS-5.10.1
    - DISA-STIG-RHEL-09-213060
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSS-Req-1.4.2
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.2
    - disable_strategy
    - kernel_module_sctp_disabled
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZENRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WXpXVkZCUzA1MWFuRklVVUpGUkc1cU5XNXhLMGxqVkc5SE1rVUtSMHBFVmxOWmNWQldTWEJaZHpG
      NFQxa3pZa1JMUmtGQlMwTnNTMFoxZVRJcmFsZDBVbmcxVTBGRFEyZFdTM2swYlVObVFXNUZZbEpq
      Y25OWWVuQmhRZ3BWTnpCeE1tODVhR0pyT1hoek0wMTVNMWxETDFwWFNqaDVibk14TUd0VVpGWTBi
      VlV4U2xkMFZUWlBVV05DTlZaWlNUVm9RVGhpUlROaVQwTjZiak56Q21odVJVb3JaM0pZUWtkQ01t
      SjZXR2hCVVZBNFFrSkdaSEZqVUVVMWFGSTBSVTFFZWxsSFVWQjJNRk5CUVhKVGNIQm1RVXRPTlU1
      VlkxUXZUemRFUmprS2IyZDBhbEpVVlhFMFFqVk5TSEJHVXpGWGEwUTJTR041TkRkSWVWbE9hVWg1
      TWt4MmEySkVlbEkySzJSNFJuQkdaUzgxWmpCRlEzbEZkbXN5TjNCdmNBbzJaak5FU0hCNE9GWmtV
      MjlJVURFemFua3ZUVWh1V21KWFNFNDRlVUZ6TkVwbFRrNXJUVmhhTkZkbVJubEtSRWRtYmxKMU9E
      QXlZekZMY1dSRGEyVmpDbWxTUVdZclJWVlRZVkE1ZHpoc1ZuZDNZa2xRZDNaV1IwSnpTV1ppVTJa
      b2NXdFNORTkyYzBsdldXWnJNVzlsVDNoTGNVWm1ORll3V1ZsYVYwdHZZMlVLUm0xUmFVOWhUV3hs
      YmtaRVpqaE5aRWhtUmxSMmEyRTNSbEoyVDFaRlVteHNPVFpFY2tOUFpUQTFiSGRwYmxVM1FVSXlL
      MkZsU0VaNk1DczVSMGRTUmdwcGJHbEpWRE42TkZZdk5rdHRXbTFuSzBwUlJ6aG5VelYzYjJkb2Rr
      UnlNMDlFZDBGTWNsSkVNakJuVWpWelFUZDZXUzh6VVZoUWFWVjNUMGxtYVM5TkNrMW5UMGQyYW5W
      Q1pXcEpaV3M1WjFCRlkyZDRVMmhUY2xKWWIzRTNjbEJGV25rMk4wOHJhSGxzYUdkNlZGZHdhblJK
      VWxoaVpVRklVbGhqWlROWU5VY0tNRXB5TWtOeFJIcGxMMUYzTVdJNWRFUm5hVmRpY2xkdWVGSmpU
      bnBsUzBnNWVXVkpMek5NYWpReFVERnVPVEo0VUZSemFqVjVVRlF3VWtzekswazFlZ3BXVTNobWNF
      bGlXRlYzT1RReVRHZE5iekpvVFFvOVdXNVJaUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'sctp' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/sctp.conf
        regexp: install\s+sctp
        line: install sctp /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'sctp' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/sctp.conf
        regexp: ^blacklist sctp$
        line: blacklist sctp
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of squashfs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_squashfs_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of squashfs
  hosts: all
  become: true
  tags:
    - CCE-83855-7
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_squashfs_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZENRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      ZzBaMUZCUzBGMFJXZzJVM05ETm5oalF6Y3ZaVFpSU1RScGIzb0tkbGhrUkZSRWFIQnNOVTh2Y0d3
      NGIzUkVlVGRFVjFkdVRrMTRVemx0ZGt4SVowUkNZM0pxZEhaamFscDVhMmRCWTBKNE5tZG1jVlZU
      VVRoV2NFUlhPQXBSVGxwV1YyZzFNa3Q2SzBWVGJXODNVR2x3T0ZKV1lsZFFWbFpqWnpWclozVk9h
      a0Z1WTNBMFNYZERTeTg1YWl0VWNtWmFZMHQwV0hwaVZYaFhPRnB4Q2pkTVpXcE5UV04yZFZkVlkz
      bHpXazVUYkRGeWNHNUplV3RVYTJKTFdsY3pNMmR1ZFVKaE0zWlZXbFpKY0dWUFRrRnRNeTlzYkU1
      RmNqUlZaMWx1VFVRS1VIQmFWbEJtYUVwbmQyRlhSbmhyWm5SRWNVWk5Ra0ZuUmpZelIzZElhR3Bs
      Y25NNWVYZG9ieTkyVm1SdVRXMHlOREp0Y21oWFNrMVViMGg1VmpSck1RcFBWSFp2ZDAxNFVIVlRj
      eTl3TWpCSk5YWkpkbmxSSzNRNGRtRXJXa042YjFWdk0yUkZNRXRaZVVSelZ6SkhkM05QWTJjd1ls
      aHBVR0pqSzBJdlNITmlDaTh3YmxaelFUWlRTM3AwYm05b1VuaFdORVZ6Y1VGamRWbHRNVXhzVURs
      NE1WaE5WMUJLV214WVJEWjBVa3RRVDJWSVFtSjViekUwU0dabVJGZFFRVmtLUm05Q0wxSnJUSGhX
      ZDFSV09IRndNalowVFVSUVl5dGtMMHhZWTAxTGQyd3JSMDF6ZDJKaGRHWlhkVE4wYzFWNU5VRTBO
      a0pvU1ROblNGQlhhelo0WlFwUFNrUkJTRUozV214NVVISTFUVkI2Vnk5dldUYzFOR1pOWlZCWGNW
      TldPVTVJVjJablRtUnFkR2d2UVhaQlVsQllaMmMxVmxGSGJVUmxXblJHUlRoSENuVXZTQzlxU1dK
      TUwyWjNjelJLUXpCeE0zZE1OMWhTVUUxc09IZFpkVGxhTUhac1JHdEZRWEl6UVdaUk9HcG9iV2w2
      TURscWJqY3dTSEExV0VKNVZYa0taazF1Y0dOd2RFaEJkRFJoWm1kTmJteENUVGRIV1c5a1JucFdS
      M1VyY0V4S05ERmpaelZOUzNkVll6RkxSbmRIVTBjM1MxVkhSSFZTV2s4elR6bHNWQXAwSzBSNVNV
      SkRjM2Q1TXpOSVQwTnBTRmh0WndvOVdIQXZXQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'squashfs' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/squashfs.conf
        regexp: install\s+squashfs
        line: install squashfs /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'squashfs' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/squashfs.conf
        regexp: ^blacklist squashfs$
        line: blacklist squashfs
      when: '"kernel" in ansible_facts.packages'


# Disable TIPC Support
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_tipc_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable TIPC Support
  hosts: all
  become: true
  tags:
    - CCE-84065-2
    - DISA-STIG-RHEL-09-213065
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_tipc_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV0pDUVVGQ1EwRkJSMEpSU205aVNEZENRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      VjBUVkE1TWpoWFVqRkxaRTAwZFRsdlVVcFVWbWRCUlhCd09Wb0tWbWN4ZURSd2JsRTJaRWxzVHpo
      VmRGY3hMMWhQTVZGWmFGUlpVRU5pYmpKcFYxRjVSVEZDUkdsbEx6WlplWEpGVFN0M1JHRkdVVWN6
      Ym1sdGVWUXlRUXBoUzNwamVVTkJiMnhpYmxST1dXbHZSbkp6TVZGYVlUZGhhalYxUmxsaFRYUldR
      MmxDZGxvclVtSkdPRmRrTjNwT1dHNUtSelptWkZoak15dEJNamRqQ2xkMEt6WkdkVXhDVkVGMVNV
      VTRUM3BhTkdGd05rOHJWaTkzTjNCUVVuSTVZMFZoWmtGS2VtdGlUV3h5U25kU2EyeEVXbXBJVDBs
      UVRIWjJWRTFEZDBrS2FpOTFjbGxHWTNabmIyOTNUV054YUV0ak5FRlROR3B6U2tsS05GTXZWREZK
      YTNOdE5DOVdVRU5uUmpsUE5WWktRbFJ6UlN0dFpGRlVPRFJtZFhOelRncExWbW81U20xWU9HNVlU
      ME5FZUZsaFJVNTBlWEV4U1hOVmMxTkxhVFZ1WmxkeVUxTTVhR05pUzJsakx6VkJVVWRLU0VodFdH
      RlpkREJKYUM4NWEwRmlDbmhpVFVwcmQzVXhSak5QZGpsVlYxRlFSM2cwYUdGSlVGZFJZblJDVW14
      a2RVUkJaSFpsYW5CbGNucEZVblZFUWtWT1NVNHZSbGxSZGpGV1YyNTNPQzhLZFRsUFRubGFaVTVQ
      T1VoRFdtMTNUbU5YT0hOM1FtbEJUVGRtVW5wSlRXZHZUVlZVVlZNclQzb3JNMjR2Y25KRllVdHdW
      M1JTVWtsRVVFd3Zla1JhY0FwS1ptOUhLMnROVVhJelF6WjVUSEZ4U1hobWFYSk5jVlJQYVZvd1lV
      NU5UV0VyWjJzNFZsaGplWGxuT1hsbk5EVlJOVXh5V2xoQk1GY3JMMlF4UVhOMkNtZDRUa0ZRUVRk
      aFJYVk9lbGhuZEdGVVNqTldha1IyYlVsWlVWWTJiV05ZTVdNd2NrTTVVVXhsWlVWS0syTkVVamRz
      YjJ0MVZWQTNhSEU0ZFU5b2NWTUtORkpaYjFoaUsxRnJXRlJUVkdsWVQzUjVTMGxuV1ZrNFRHUnJV
      R0p3ZDBZMWQzcHJSRWhrYlZoT2FrTXhkMXB3VGxOQlpITm5VWE40YWpGNmVubElVZ3BXUnpnMVZU
      ZGtTbWRHZWpsRE9XZENNRGxuUFFvOWQwdDNiUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'tipc' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/tipc.conf
        regexp: install\s+tipc
        line: install tipc /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'tipc' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/tipc.conf
        regexp: ^blacklist tipc$
        line: blacklist tipc
      when: '"kernel" in ansible_facts.packages'


# Disable Mounting of udf
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_udf_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Mounting of udf
  hosts: all
  become: true
  tags:
    - CCE-83852-4
    - NIST-800-171-3.4.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - kernel_module_udf_disabled
    - low_complexity
    - low_severity
    - medium_disruption
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZENRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      QkJSVkF2YVhwWUsyazRkVGRYTTA5VlNFc3hXU3MwSzJsSlFra0tjMWRpVTJKSFdVVXZlbUZ4ZFdG
      WFpuVTJZVlVyVVc5RE5HZ3dPSGxZYWtSQlFYSkJlV0owYW5NMVlpdEZOWEpoUkhWMlVTc3JiSE5u
      UzJGcmVFeFZVd3A2TTJWdVowMXVhVFV4WVZoU1JYQmpUa2h2VmpGTFprNTFWMU5QTDNaelNrOTVT
      REZ0WWpBcldXTjBNVlJ5VnpNNUsyNXVTRU5hWkRoQ00ydE5Na2xUQ25SNFNGQTFhV1ZoUXpCb1dG
      Vk1lall4T1dFeFMxSkRORGx5ZVVkMmVsUmhZVVpOVGpFdmEyZFNOV05HYUdkTmVXY3pRMHhKVVdW
      MlpHazBZbmRtZDFNS2NVTlpiR1ZTTTJoUUwzQlpjRTl1ZEdkSVoyZGFTV05PTXpoTGFGVnFTREpw
      Y0dsS1VuUldaalV5VmxRMFQwcHdlamcwVW1OcmJWZHJTVnB6WVdOTVNBcEdNemd6ZVcxUk5FeHlS
      VVZIZUc1VFZrUXJObFZNYVc5MFYyUlJRbW8zVUZsT2FuVXlMMFJYWmxaa1RqRlpSVGRPT0ZCeE9W
      aDFTMmhKTW0xU09VazVDazVYVUVaekt6QlROR3gwTHpSeGVEaHlWVzVyVlZvdk1tZzRPR2htY0ha
      M1pXTlRZak5sU2tWYWEyVlBSa1V2UVZOamVtSkRhRWxqVUU5U2NuaDBTakFLTWtOeE9HVkRiMVZh
      WTJkWGJsRmxiVkF5U3pFd00ydDRjMGxrVkN0eWEzVjJieTlRUzNjME9WRnhjMGMwTVZOSWNsQTVh
      emh4WTBFNU1GbzRVa2Q2ZWdwVldEZEhhMVJPTWpWbEwybEpaRVJrU210Tk1IbENhSGNyYmxSSVJY
      QTNTbUZ6ZFZSd1NpODBNRE5XTmpWbGJHaHVSRVpFYmtKcU5FWnVkelpGYzNSekNtVnVLMUZaYkVG
      TlFUVmlla3hoYkU5elMxSXZiM1k0VUZSU056RTBWRkkwZFV0VVFrVkRZVlUxYW1oMU9DOW1UMmQx
      YVc1R09UTTRTbTFRYmtZMGJWQUtjR1JKZW5CdVpXdzBaMEZaU0VSNVRrNW5TR3hVSzJSQ0wzWTRa
      bEpxWVVKQlJGVlJkV3hRTm0xTGVqUXhURGgxYmlzNVF6bDNaVUozUm5nNWRrWjFZZ292VkhkVmVH
      dzFXVEp1WTI1QlVVVjRRMUJyYkFvOVJVMTBZUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'udf' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/udf.conf
        regexp: install\s+udf
        line: install udf /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'udf' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/udf.conf
        regexp: ^blacklist udf$
        line: blacklist udf
      when: '"kernel" in ansible_facts.packages'


# Disable Modprobe Loading of USB Storage Driver
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_almalinux,multi_platform_rhv,multi_platform_ubuntu,multi_platform_sle,multi_platform_slmicro
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Modprobe Loading of USB Storage Driver
  hosts: all
  become: true
  tags:
    - CCE-83851-6
    - DISA-STIG-RHEL-09-291010
    - NIST-800-171-3.1.21
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-MP-7
    - PCI-DSSv4-3.4
    - PCI-DSSv4-3.4.2
    - disable_strategy
    - kernel_module_usb-storage_disabled
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZERRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      TXpPRkZCU1VWWlZVSkRRMDlaV2xSVVNIWTJZbVoxUWk5Uk4zQUtNMlYyUm5kVlVEbHdkVTlZYmxK
      Q2FGWnVhemxuWTFOWU4yZHVUbFF5WkdwSkwzbFRVMWhUT0RWT2MzVnNkbkJ4TW1Nd1pEZHFRMUl2
      VDB4a1kyeHZSZ3A2TW5GSE1GSXpiRFZXY1hJeGNFSnFURVp6WkhKbWJuTm5kRWxNU1ZwWlIzUlRP
      V0Z1YmpWcUswWkdWbWx1T0RGaGJtMUNPVEpLWjB3d05uUmhSMEZFQ2xkelkzQlZjM053UjFGSk1r
      eHBTMWcxUXpZMmVWRmhValY1UldORmMwcEtTVmRNYzNCNVEyUjVXVGd4ZVRNMGFGbHhjbEo2TVVS
      a05ITmFaM1V5VUZJS1FrTjVUMWRhZUROUWMwOVFTMko0VWk5emJqVnVSWGRqU3pKdU1IWlZOa0ow
      WlhsNEx6SmxZMUJWT0RkdU4xUTFZbU5wTkdvcldYSldXVlF2Y1ZFeVZ3cFlOVXBPY1NzNFIzTlBS
      ekl4ZDJKS1pXOTFaVk4xYTNNMVNWYzBUbUpXYTFnelJVODViVmx1WkZST1RrZzRRMVJMU0hsb1ZX
      SnNWMHRsU20xWlRqQlFDbFZsWjFsTWRqaDVLM1ZoTHpoWFJIWnViakZCY0hrdlVYSkVlbTFXY3pR
      ck1UazFVMFUwWlRVeU0xaDJVM2hXWkhJclExTnVOMGhUYUN0S2VITkRaMmNLV21ndlFpdDZaVmwz
      WTNaRGRtTjRhSFJWUlVWcGVrcHZVRm8wUlhGNWEwRktaV3RFYkhsTlJIazBUSEZrZGtKQ1FVSkla
      MU5OT0dKd1lrc3lZMHRTVXdvMFFYTjFjRzl0UmxoNmJ5dFJlVzVvYm10WkwyUnJUa1psTmpka2Vq
      ZFdSR0l6V0ZSQ09ISXlSVkp0V2tOUlpWRk9kVnB1WnpZeVNrOU5PRTVTUWsxWkNrMVZiSEE1TDBw
      SE1qVnZSbk5LYWxaWFdVNXhiMFp2WmxwUVYxbGlPWEZsZFhJMWQzQTJZMVpsTkc0emRYWlFNRFV4
      U1ZOMlpuTTFObVJ2Y25OTFVFOEtTVlZISzBadVNESm9kMnhNUmtwbU4wRnVPWFp3V2k4dmIzbHZh
      MkpxYW1SV1RIbGFhblZtV1c5VmNtUkNWV3d3TVhCck5XeEtWRWhJUmtZM1NGbGplZ3BXZWt4b1VT
      dHVaVlJvVW5sSk1taHlRMnRLUVFvOWVXcFVWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure kernel module 'usb-storage' is disabled
      lineinfile:
        create: true
        dest: /etc/modprobe.d/usb-storage.conf
        regexp: install\s+usb-storage
        line: install usb-storage /bin/false
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure kernel module 'usb-storage' is blacklisted
      lineinfile:
        create: true
        dest: /etc/modprobe.d/usb-storage.conf
        regexp: ^blacklist usb-storage$
        line: blacklist usb-storage
      when: '"kernel" in ansible_facts.packages'


# Add nodev Option to /dev/shm
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nodev,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = high
- name: Add nodev Option to /dev/shm
  hosts: all
  become: true
  tags:
    - CCE-83881-3
    - DISA-STIG-RHEL-09-231110
    - NIST-800-53-AC-6
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-MP-7
    - configure_strategy
    - high_disruption
    - low_complexity
    - medium_severity
    - mount_option_dev_shm_nodev
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZERRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      ZFFNRkF2TVRKbVEwWTBSRVl6Wm5sd05FazViM0pTTW5aWlZFd0tPV2h5Vm5wNFluUXhRa1ZNVFZO
      U1dXeFZNa1VyYjFvNFUycERTSGt5VjFaVk9HUTBLMDB2U1dSQ1dsUm9ka0pyWVdWMWVtSkpia3Rz
      YURGVVFtUjFkQXBMWjBwUVVuRk1aVEZpVGtFNFdGTkpVVE5LVVVjdlpIWjRabkJPY3pjMlpGZDBW
      bTVYZEVoNVMxaDJXWEZrSzIxdEwzQTRjVmxXUkUxTE1Fb3dhRGx6Q21rd2R5OTJRMFZQYVZkUFpW
      STRhMlI0U1hGbVpFNURZbkJSYVdNeE1HcEtlWE42TDB0dGNrdG9RWEJhU2tGQ1VsY3ZRelVyV1VS
      WmJ6WjVjV0ZDWjFVS1QybFdNRU5RVmpKbVJVVjJRVWMzUzAxT1kxaHVhVzVHYjBZeWRYSnNhbFZh
      U1ZZNFNtZElXVmdyWjBSTVNpOXZVRmwxTVVsMmNEQkpaRzlUZUVWd1RncERheXRaV1dGT0t6aDJP
      VGg0WlM4MGJsUjVSMUZxZDJkb1Vsa3lUbEZSYzJNeWJqTmlhME5xVVVaVFNuUXlWaXRaVFVwTGIz
      Tm1lalZtWW05cmVFcGtDa3BOVjA4NWNVcHlXbXBVZVhORmNtNWhZM2x3T1hNelUybElZblJoT0ZN
      M1NtZE1NRkkyUkdJcmFsQlpSM3BHYlhJMFVGRkNZM2xNZFdneVExbGlZMW9LYmxOeE5sbG5hRkIx
      TlV4UWVGaEdZVGRUUWs5VFVVeG1kblUwTW5OVFRFRXJTVVJpY0Raa2FVZDFhVE5CWlNzMVJsY3hS
      MGhKTW1OdWMycFZkR2Q2VUFwV00zSXJVM1ZYSzBWTk1GVkNUR2d3U2poelRVTlJTelpEZVhaM2Ru
      Rm9NVTFIZDFWUlVXUmtSbXBCVldGemQwUjBRMVIzWkhGdVZXUk5iM3BpVlZabENtcDBWRU5JVHpW
      aFZ6aHZhM0UyZGxKbFpsazBiMWRrYlRJemVYcFdVV1o1WlUxM1VEbEVSazk1ZG01MmJtMDJPVWx0
      VUZka1dHVlNkMWd6ZWtsNE1XY0thRnBSY2tabmJETnNSMlp5ZGs1SWVUTnFVRlI2TlV4UldWTlBR
      ek5FSzJZeWRGWjJXRTlqYVhkS1NFaDBMMlJKTDBSTU9UVlJNemxuS3pSSEx6RmxlUXBsV2tJNWFH
      bG1kamxVU3poVGFXVTRTV1ZyUmdvOVRGSklhZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: 'Add nodev Option to /dev/shm: Check information associated to mountpoint'
      command: findmnt  '/dev/shm'
      register: device_name
      failed_when: device_name.rc > 1
      changed_when: false
      when: ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not
        ( ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )

    - name: 'Add nodev Option to /dev/shm: Create mount_info dictionary variable'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        - '{{ device_name.stdout_lines[0].split() | list | lower }}'
        - '{{ device_name.stdout_lines[1].split() | list }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length > 0)

    - name: 'Add nodev Option to /dev/shm: If /dev/shm not mounted, craft mount_info manually'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        -   - target
            - source
            - fstype
            - options
        -   - /dev/shm
            - tmpfs
            - tmpfs
            - defaults
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - ("" | length == 0)
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length == 0)

    - name: 'Add nodev Option to /dev/shm: Make sure nodev option is part of the to /dev/shm options'
      set_fact:
        mount_info: '{{ mount_info | combine( {''options'':''''~mount_info.options~'',nodev'' }) }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined and "nodev" not in mount_info.options

    - name: 'Add nodev Option to /dev/shm: Ensure /dev/shm is mounted with nodev option'
      mount:
        path: /dev/shm
        src: '{{ mount_info.source }}'
        opts: '{{ mount_info.options }}'
        state: mounted
        fstype: '{{ mount_info.fstype }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined
        - (device_name.stdout is defined and (device_name.stdout | length > 0)) or ("" | length == 0)


# Add noexec Option to /dev/shm
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_mount_option_dev_shm_noexec,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = high
- name: Add noexec Option to /dev/shm
  hosts: all
  become: true
  tags:
    - CCE-83857-3
    - DISA-STIG-RHEL-09-231115
    - NIST-800-53-AC-6
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-MP-7
    - configure_strategy
    - high_disruption
    - low_complexity
    - medium_severity
    - mount_option_dev_shm_noexec
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZERRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      NHpPRkF2YVdFeVYzZFNPSGRqZG1oV04yaFpMekYzWkdab0swOEtWWGhUYnk5ek9VVkNNbFJsWWpO
      RFdYWlZZMHRJYW0xVlVtNWpaM295VnpBeUwyWnRhVEZqVjJKUlJIZFlWbnBVU1hZelVEWmpaR2h1
      U1UxVGJHcFNVQXBvVmpCTU9FVnlVMG92YmpKek0wUnVZMHRXVERkbVZEWkVjalZ5TUZKU2VHZE5P
      RWR4VlU1RGVGSnpVRTlLU0RjckwwaDJVVlZGVUhKU1JXTjVPWGdyQ2xsNmVVWTJUblFyYUVWU2Jt
      dFVXVEV4WkV3eVdXMVhPRzFCWVU1clNrOWxaWFpPY1VSelExaGtVbWh5Vm1OVGNYUm5RVzFpYlZJ
      eUsweFpTbVpZZGtnS2VtVmxkbHBJTXpWc2EzcE1iRWxGYTBsTVpHUk1TR1ZXWTFnMWMyTXJaVEJK
      TDFoSlJVZFdORWxCWTNjeVVEa3dhM3BQTDJwTFEyY3dObkZLY0d0TGJRcFZTRFJWZDJsVFVrWmFa
      M1kxZWxGVFpEbFFObVkxVmtRd1VVWXJPWGRCVXpnM2VqaFJRVEZ2TVZGaGFqaFNPVWhEZGxwelZH
      WXZUMjVTV0cxdmEwRXJDbFY2UjFnek1USjViMnQzV1N0NWNVUkZRMWRtVEdRMldHWktjbFZhY1Va
      blltNXZOSEF2WjJndlVrZGxiMmh3YlVsWWNrTjRaVGR5WXpWa2NuQXlRMGNLTjNocVpqaFFiMnRS
      U0VoWGFWcEZSblV6VVZRNWVHVTFUVWhZZW1wc1dHdDRUbXRSYms5Q1UwSnlZa2w1YkhWMGRtVlhW
      bkp5TjFjNE1raGxlWGxqUlFwalRrWndkM2RuWjFVd2NsWnBLemRWZGpkU2VtWnVPSEZPWVVoR1NF
      WkxaMDlFTUc5YVNpdEhRalYyU25NeWRIRnFaWFZVY1V0YU5EZDZZMUJVVkhwbkNrUllXbkpxZG5C
      dE0weGxRelJQVFc5dGNFWktkVFFyV2xGelpYSjNhM2hzWkV4MVRUSk9TbWxoZUV0S2Qyd3JPRVE1
      V1dSS0wxbE9ielJHT0ZObWJqa0tiR05NU2t4Qk9XVk1WREJGTm5KaFZURnJlRE12UmxWQlJtMWlP
      RTVsUkZoclUzUmljbXhYTkRGV1RraEZia3BKYkVrMk4wNU5NR2t3SzFGRVpuUmxid281TXpCRU5t
      OVNNRVZPTHpkQ1NIWnZOelpHY1FvOWJWTm9UUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: 'Add noexec Option to /dev/shm: Check information associated to mountpoint'
      command: findmnt  '/dev/shm'
      register: device_name
      failed_when: device_name.rc > 1
      changed_when: false
      when: ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not
        ( ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )

    - name: 'Add noexec Option to /dev/shm: Create mount_info dictionary variable'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        - '{{ device_name.stdout_lines[0].split() | list | lower }}'
        - '{{ device_name.stdout_lines[1].split() | list }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length > 0)

    - name: 'Add noexec Option to /dev/shm: If /dev/shm not mounted, craft mount_info manually'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        -   - target
            - source
            - fstype
            - options
        -   - /dev/shm
            - tmpfs
            - tmpfs
            - defaults
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - ("" | length == 0)
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length == 0)

    - name: 'Add noexec Option to /dev/shm: Make sure noexec option is part of the to /dev/shm options'
      set_fact:
        mount_info: '{{ mount_info | combine( {''options'':''''~mount_info.options~'',noexec'' }) }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined and "noexec" not in mount_info.options

    - name: 'Add noexec Option to /dev/shm: Ensure /dev/shm is mounted with noexec option'
      mount:
        path: /dev/shm
        src: '{{ mount_info.source }}'
        opts: '{{ mount_info.options }}'
        state: mounted
        fstype: '{{ mount_info.fstype }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined
        - (device_name.stdout is defined and (device_name.stdout | length > 0)) or ("" | length == 0)


# Add nosuid Option to /dev/shm
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nosuid,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = high
- name: Add nosuid Option to /dev/shm
  hosts: all
  become: true
  tags:
    - CCE-83891-2
    - DISA-STIG-RHEL-09-231120
    - NIST-800-53-AC-6
    - NIST-800-53-AC-6(1)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-MP-7
    - configure_strategy
    - high_disruption
    - low_complexity
    - medium_severity
    - mount_option_dev_shm_nosuid
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZERRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      OUlORkF2TTBkaFpFc3JXVFZsVUVKYVFUaDJhakpZUmxWSlMwWUtWSFJtTlRZelVtaENWVkZpUVVo
      U1dHUklSR0ZHVjBoVmMyWTJjakkxZDBOUFRXcDVja0puY25SVlpFNUhTVmQ1V0hwQlNIcHZSVUZS
      VFV0Mk1XWXhhd3BETkU5d2FrZE5ObEZ2VlZkVVZWWjVSVlV5TkVReWFUSlJNbGxqZFVwNmQzZFVV
      MlZFYVZwVEwxRlZhWFlyY205TmEybHJlVVJsYTBWUVRubE9Xak5zQ20xSE4xRlFWWGN3T0RGcVFX
      Vk9jbTV2T1dkaFJEVllRMU41TkUxaGQxQndkWGxpTTBOd09HOXBjbmw0U21SYVpHSlFUalJ6VW05
      Qk9HcFFTR1YzVWpBS1YxZHBVbmt3YzBGWldGTlNOMEZxVWtrMFZqaDRXVmc1YzJGYU1WSkdhMW8w
      YTNZMVExTlFhbXAxYWtFMFdWYzFNVkpqTjJsWGJtVnlXWEpTZEdFMWRRb3pXWGhLT0ZsbmNESk9O
      bWhITTJoamFucHlTRlEyU205bFJrVlpWMHhuYVdkMFlqVk1NME5vVGpBelNWbHBkVkJNVjJGU1NI
      bFdabTVOTkhOVGJXOUxDa2tyUkcxNGQwMVVkamd5VkVObU4wMWFaM1JaVUhwSVJIVXZXRk5zUkRs
      SGF6VTVURmQ0UzJKclRIaHBZakJsTmxSc1RWYzJRMlZoUkd3d1ZqWjNjRFVLVTI5WFVtODVkMnB1
      WmtkTGJHNTBMMVZZT0ZvMVN6Rk1kMk53ZFd0VVpFeDBURU16VldGc2FHcGhXbUpsZFRWaFNYcDRW
      a3AzUW5WS1ZFczVla1JETlFwblduZFhTMVJYU0U1SlUwVXZTV2xGYlhSdVFqbGhXa0pHTjJodFMy
      NXpiazFRUzNKQ2RGRTVhRmxwY2poNlVYbzFTbUZaYkZsTGFWSlFTemR1YTBkbENrcDFRMDEyTmtk
      MFNISXdZVEpqVm5SUVZsbzRlRWczWW5aNVNsRnJPVVI2WVdSbkswRm9NUzh3VjAxT1dWVnNWMGRT
      Y0U1RlVqZzNja1pJZEhCS1JXb0tVR1ZaSzNweGNqZzRRV1pwYjJsNFVFRTBVR0Z4ZVdoVmR5dEph
      VUpTV2pKUlVXZHlVazVQYWl0aE9HTnBhUzlYUVdvd2JIUlRaWFI0TjJaV2NGcDZXZ3B4YkV4M1RG
      QTVUR0ptYlhCcWEzWjBjRFoxVGdvOWVDdE1VZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: 'Add nosuid Option to /dev/shm: Check information associated to mountpoint'
      command: findmnt  '/dev/shm'
      register: device_name
      failed_when: device_name.rc > 1
      changed_when: false
      when: ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not
        ( ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )

    - name: 'Add nosuid Option to /dev/shm: Create mount_info dictionary variable'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        - '{{ device_name.stdout_lines[0].split() | list | lower }}'
        - '{{ device_name.stdout_lines[1].split() | list }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length > 0)

    - name: 'Add nosuid Option to /dev/shm: If /dev/shm not mounted, craft mount_info manually'
      set_fact:
        mount_info: '{{ mount_info|default({})|combine({item.0: item.1}) }}'
      with_together:
        -   - target
            - source
            - fstype
            - options
        -   - /dev/shm
            - tmpfs
            - tmpfs
            - defaults
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - ("" | length == 0)
        - device_name.stdout is defined and device_name.stdout_lines is defined
        - (device_name.stdout | length == 0)

    - name: 'Add nosuid Option to /dev/shm: Make sure nosuid option is part of the to /dev/shm options'
      set_fact:
        mount_info: '{{ mount_info | combine( {''options'':''''~mount_info.options~'',nosuid'' }) }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined and "nosuid" not in mount_info.options

    - name: 'Add nosuid Option to /dev/shm: Ensure /dev/shm is mounted with nosuid option'
      mount:
        path: /dev/shm
        src: '{{ mount_info.source }}'
        opts: '{{ mount_info.options }}'
        state: mounted
        fstype: '{{ mount_info.fstype }}'
      when:
        - ( not ( "kernel" in ansible_facts.packages and "rpm-ostree" in ansible_facts.packages and "bootc" in ansible_facts.packages and not "openshift-kubelet" in ansible_facts.packages ) and not (
          ansible_virtualization_type in ["docker", "lxc", "openvz", "podman", "container"] ) )
        - mount_info is defined
        - (device_name.stdout is defined and (device_name.stdout | length > 0)) or ("" | length == 0)


# Prevent Login to Accounts With Empty Password
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_no_empty_passwords,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_ubuntu,multi_platform_almalinux
# reboot = false
# strategy = configure
# complexity = low
# disruption = medium
- name: Prevent Login to Accounts With Empty Password
  hosts: all
  become: true
  tags:
    - CCE-83611-4
    - CJIS-5.5.2
    - DISA-STIG-RHEL-09-611025
    - NIST-800-171-3.1.1
    - NIST-800-171-3.1.5
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - PCI-DSSv4-8.3
    - PCI-DSSv4-8.3.1
    - configure_strategy
    - high_severity
    - low_complexity
    - medium_disruption
    - no_empty_passwords
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZEpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      UllZMUF2TWxGaE5UWkZVelZNY0dGSU9YUTVkM1J3Y1dnME9FUUtkRlpoWWtoWlVuTTRWME5SVkZa
      U2RtRjZhR2RtZUU1b1NuRldLM1pLZWl0NU5qQk1NRms1UzNsQlptbExRMjg1VFRaT2JtOXJURVpG
      VnpaVVkzWm5Nd3BTVHpObVp6ZDBiMmd5Y21wYVRXOHlUM0pFVUZZNFJEaDRiWEIxV0dWM1ZsRjZX
      a05rU0VsaloxazVhR3QwYnpkTVdFSnhUMjlVZVc1SlUxcFlXRXcwQ2t0Wk5HSlBNMDFhY1cxVk5E
      WnpNR2hRUjJKeFpqSXpPRGRWZUdsbFNHVjRRbmN3UVN0cGFXRXlaVEZMU25seVlrRklNMk54VUVG
      U2MxZGlVMlJsYW04S01FOTVlV0l3ZEVGTlVrVTVPVE5TVUVOQlFsYzBRV2hhVldaYWRrRjZVRWc1
      VHpsc1NIZHBNME5FT0hKWlIxUm1ZbE5FYVRCdk1qVk1OSEp4WWtOcVlncE1lVU5zVlM5dGIxbEVa
      RkpuY0RoSGFWcGxhbU5CZFZKRE1uaHdhRE5SUjJRMlNGQnlhbmx1Vm10aVRrcHJlbFJSU0RjcmJG
      SllkM0Z1VTBKNldYSkxDa0pIWkRsYVEyUlZNR2gwU210dlNsZHZPVzQ1UVZwSmNWZ3lNelEyWkZa
      UVppOTNLM1pRTUdGMVZXNVphRkV5TlVKTmQwUlNlbWg0YkhOM0wwUTRhREFLU1RaUmMyMXpNREEy
      VDBSclFtVlhWR2hrZEM5TVRVRldOaTlRZW00cllrd3JaM05CWWpJdk1ETmlkRVZNZERKeFpVMWlj
      RVo1YUdkd2FUTmhORFJMWVFwbVIzZHpPRmx5Y1dOU1FuUlFVbUUxUTI5Q1V5dElWM1VyTTB4Sldr
      RnpWM1JyYlhWSFZUZ3dZVkEyTnpReFRGZFhRMGRNYmt0aFJVczRlVTlLWVd0NkNsQXZUSFJYY1M5
      Q1ozcE5jVklyZFc5T05VcFFVbVJrY0VKNFV6RnFka2RCVVRSMmVTOXNZa3B3UTNodWNGRkRXR0Uy
      Vm01SGNYWXJTbWxWV0ZkcFdrTUtlWEFyVTNaM09XTm9WbWxQVTFsdGNXNDVPV2hPTldRcldqVllS
      MVZ0TDFkbVkxTTRiVVpKWTBrdk5TOUxRa2RSZVVaU1kyTmljWEJHVFhsMVRYaEtRd3A2UjFCNGJW
      RkZMMUZtTUU4eFQzTkRUV1V2VHdvOWNYVXZNQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Prevent Login to Accounts With Empty Password - Check if system relies on authselect
      ansible.builtin.stat:
        path: /usr/bin/authselect
      register: result_authselect_present
      when: '"kernel" in ansible_facts.packages'

    - name: Prevent Login to Accounts With Empty Password - Remediate using authselect
      block:

        - name: Prevent Login to Accounts With Empty Password - Check integrity of authselect current profile
          ansible.builtin.command:
            cmd: authselect check
          register: result_authselect_check_cmd
          changed_when: false
          failed_when: false

        - name: Prevent Login to Accounts With Empty Password - Informative message based on the authselect integrity check result
          ansible.builtin.assert:
            that:
              - result_authselect_check_cmd.rc == 0
            fail_msg:
              - authselect integrity check failed. Remediation aborted!
              - This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.
              - It is not recommended to manually edit the PAM files when authselect tool is available.
              - In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.
            success_msg:
              - authselect integrity check passed

        - name: Prevent Login to Accounts With Empty Password - Get authselect current features
          ansible.builtin.shell:
            cmd: authselect current | tail -n+3 | awk '{ print $2 }'
          register: result_authselect_features
          changed_when: false
          when:
            - result_authselect_check_cmd is success

        - name: Prevent Login to Accounts With Empty Password - Ensure "without-nullok" feature is enabled using authselect tool
          ansible.builtin.command:
            cmd: authselect enable-feature without-nullok
          register: result_authselect_enable_feature_cmd
          when:
            - result_authselect_check_cmd is success
            - result_authselect_features.stdout is not search("without-nullok")

        - name: Prevent Login to Accounts With Empty Password - Ensure authselect changes are applied
          ansible.builtin.command:
            cmd: authselect apply-changes -b
          when:
            - result_authselect_enable_feature_cmd is not skipped
            - result_authselect_enable_feature_cmd is success
      when:
        - '"kernel" in ansible_facts.packages'
        - result_authselect_present.stat.exists

    - name: Prevent Login to Accounts With Empty Password - Remediate directly editing PAM files
      ansible.builtin.replace:
        dest: '{{ item }}'
        regexp: nullok
      loop:
        - /etc/pam.d/system-auth
        - /etc/pam.d/password-auth
      when:
        - '"kernel" in ansible_facts.packages'
        - not result_authselect_present.stat.exists


# Install AIDE
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_package_aide_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install AIDE
  hosts: all
  become: true
  tags:
    - CCE-90843-4
    - CJIS-5.10.1.3
    - DISA-STIG-RHEL-09-651010
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-11.5
    - PCI-DSSv4-11.5.2
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_aide_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZEtRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      OHJSVkZCU1dWclNtRjRPWEpMTWtoaVUzZFlMMDVCZDBSU04yVUtPREJWVDFobVptVnFPVVpWUlVr
      ck1HbElTbUkwUkV0SllXRm9ia0pyWlRkeVZteE9iVzR2UW5KUmJDOVhOMlV2Y21aSWMwZzVlbEpC
      Y0ZST1JVeGtZd3BRTTNOVFlXaGhkSEJSV0VoeFIzbzBVakJRY25semJsWXdjMjF5VUVnemFtSkVS
      ems0Y3pVMlVYQlVObFZDTmpoRlIzaGxLekIwVFRKSFlsSlFOa2xLQ2tWUFNFOTVkRXBJTURkd1NG
      QkZWV0pxYTBoelpuWjVSbnB3YkdJemNVeHpWMWx2TDJ4VVIyeFFNekpqTkVkbFNFNTViakpxYlVz
      d1VWVTFTbU5EVldZS1JXNXJSRlpDZFdweVRUQkdTazlFUzA5NlN6bGFRWEZWVHpodWVrVmllVmQy
      U2paNGNYWlhlak5XVVdONlZURTVNazFuWmxaNGNscFFkRmRJYkV0SlNRcDJiekJPUlVweVlXUnhN
      SGgwY21ad2N6ZFZiMVZPYjBOSWJWTnlURm80V1ZwRkszbHZhemhxYzBGSllXbDVVek5NYW5GMVQz
      cHNVMnBSU0RaeFlYSm1Da2MwZEdKQ1JIZ3JkalZRUjNSUGVGQTRhVE5wVWpKcFIwcDNTSHBzTVVR
      eFUxRmxSakZSU3pkbVJYRlJVVEZRTjFOMk5YRjBPWHA2UzJGRVQyRnROR2tLYzI5SFNFcFFlRnBI
      ZVNzNVNFY3daVWQ0T0daWU9EQnpRM1J5VkZka1VqTnhiR2xLUms1V04xSmpRMU5KV1doNGEydDJT
      MVkyUjNwSVRGcHRORWhUVEFwMlVtaFRZWHBWZERCWFJYcHphbXAyVlV3MlowTmhXRk5pUXpkRFJF
      OXJSVUZFT1ZGbVFraGtLMnBCTnl0bVMwRnFNemhDUkV0YVdHeDFXVlY2UWk5UkNuVjJNVU4xWmtO
      MGVHZHNhM2g2Tm5kME9IQjZOM1Z1VURoUk5HUjZNRFZFU3k5TWRFZGpaRTVLU25SWVFqUTVWR2hI
      UzBKcFNWaG9TbE40TTBGaVYzVUtUemhuWldaalZWUk1NVUp2WWsxa1ZFZGpPR2xZYzJvd01IVlVR
      MW92U3pKVVNuSllNQzlSVjBvNVpXbHdTWFJWYmpkVE1GYzFNR2xUT1ZackswbE1hZ3BIUWtWNmRt
      TlZjREJUVUhCdVVsbEdNa3ByV2dvOVFXRk5SUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure aide is installed
      package:
        name: aide
        state: present
      when: '"kernel" in ansible_facts.packages'


# Install firewalld Package
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_package_firewalld_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install firewalld Package
  hosts: all
  become: true
  tags:
    - CCE-84021-5
    - DISA-STIG-RHEL-09-251010
    - NIST-800-53-CM-6(a)
    - PCI-DSSv4-1.2
    - PCI-DSSv4-1.2.1
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_firewalld_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZE5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      eGtjMUF2VWxjMWRVbGxiVFpDY0ZKT2QwcHZla1I1ZWpKRFVsWUtkVEUwTDNCeFdXY3ZWRzlvU0Ra
      M2N6WmxTSGxPUkVSVk1uUk5SMVJYTnlzM1NrWjNjbXRuY201WWNVTnVlRGRwVFZsSUsycGpkRlZ1
      TkVoSmVrWlZWd3BZUmtwM1oySlZUVFpaU0V4MlZVOVJXbHBwYVZwb2FWaFhVbmRRVTJ0emNIVjBP
      R3hPWVV0blJXWktkV3BLVG5kT2JsZFpUSEZwWW1rd09EZ3JjbTgzQ2psd1N6TlRTMEpwTTBVM1FV
      SnliVTFTV0VOMmJVUjFjMVpMYnpFd2EweE1iRWQ1U0hCNGEyOWFhRkpOZW1OTVJtVlhjVVp2Vmxw
      c0wzQnphRWxPTUVJS1lsVnRaek01U1c1bGREaHlkRnBUVFhGR2F5OVNlSEZ5WkhZeGIwODRhMVIz
      TTJwbFRFRmlOM05HYUZZM1ZUWmpXV0Z2WnpOMk1sbG9LMVpQWTFabFVnbzFTa0ZuWkhFck1GQlRl
      V1F6TUVzM1JHaHNlVVJNTWxkUlNIWkxieTlOYUdoblNHZEtlRkJhU0VSUFNUaHBZMjVCY2xjclRq
      UTNhR3hKUVV4UGEySm9DbFJ1V1dOV1dWbHRaemt2YzJOUWFpODFNekpIWlZacVJtdE5hM2c1U2xk
      VWJIQnRTMGMwSzNabEsyTlNjMGRzSzJOdlUyaHBabWhVT1VnNFNGZEdhVVVLVTNCM2RXaFhMM00y
      YkZSQ1drTTNZM3BtTDJWUE5sRjFOVWN2YkhrMU1XbG1kblk0ZEVWalRXOXRWRkU1YmxSa1REVnNS
      akY2VUcxR01qSXdZWEZVZUFwbVpVcDRUM2R0V1VOTU9IUjJhV052TjI1UVpHaE9TM2hZWlVGT1Nt
      Tm5XbWxLVUdKNFZ5dFhabUZ4WkdaT1NERlFMM05OVEZWdU5IbDBLemxYZVZwcUNuZElNR2N2UmtO
      RWNqbE5VWFp1U0U5dGJsUm9PR2RNY1dWM09XRnNZakZPVlV4TldqUkZWMmN5UkZOSlVXOWpjbTVw
      VldWYU9VdExRMkZhWmpsT09EWUtLM2xsZG04d1lVWm9aRTVLZWs5eFRUZFFjRnB0ZW1OemNsbzNN
      a1pzTVVGck1VbEhXVTFPYjJJck9GZDNXU3RVYzB0eVlYcDFiMFZpUlN0VFl6UkNVQXB1YTBnd1kx
      VmpWR3gwWTNobmFteFlTRWRpZWdvOU5tWTBjd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure firewalld is installed
      package:
        name: firewalld
        state: present
      when: '"kernel" in ansible_facts.packages'


# Install nftables Package
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_package_nftables_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install nftables Package
  hosts: all
  become: true
  tags:
    - CCE-86378-7
    - PCI-DSSv4-1.2
    - PCI-DSSv4-1.2.1
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_nftables_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZFBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      SjRUVkZCU2tVeVluVjJRaTlFTWtSaGIyNWlXak4yZFRCYWMyTUthVTQ0U2pKNmJrNU9TVmcyV0RK
      T1lsQllUbVpDTUdGNloyNHZlVGxSUjBRNWIyTmlhMU51TmpSdWFXOHlZV0ZuV2tWbFNsTkZkRmhG
      SzNKbE1VTjRTQXBNU2taNVlVUkRXbXgwU0U1SFFWUjBNVTFwUVdwRGJGTXZVMlJSVmtGeGMzTnlN
      WGQwYzIxMlIwWk1VMFoyVFhGUmF6TTFjMkZ4TURGWWMwNVVaRGxJQ2s1NldsSnJablJ3V2tORlZV
      aGphV05ZYjFoRE9Vb3JTMll6V0Zac0sxWTVZVU0wUkVkb1dtVmFTWGgzUzJkU2RqTlhXRVpPTlhO
      eU1tZEhRWFUzVmtFS2VIQjBNVEpzVWxOWlJqbENZbFIwUTJkbldFZDFhMHBqWkVWT2RVRm5hR1Vy
      UjFscllXOWpkSEJrVUhCeVZIQlpZVmR2Um5sbVRFUm5URlJSU0haUFlRcG9aR3RJVWprcmRHNWpk
      VFU0YVROQ2VGRkpUamxEV214ck5YTnlXa0p6YlcxMGMyazJlbUprUkdGck1WUlJMemRIVlRGalZs
      Vm5kRWcxYWxaaWJYQjZDa2xCVEVwSFptTldNMU5aY1VGalRXVmFiSEp4U1dkRmVVczJlRVpWVFU5
      UmIxUklhbE5HYzAxWlVuQnJkbWh1UVVWSFYyUnVVMUpOWm10WldUQnNOamtLVUd3NFUwcDRWVU5o
      YjNSaGJGcERRVXgxT0V4dUwwRTJaa05qV2tKQlVqaE1ZbFJRYTNKclRsQnVVRTQyTUhOcWRHbEpS
      VlZCY0VSc1V6SnBOV2hSTWdwc2FUUlVSRlkwV2tkMUwwVndUMVFyYXprelVtMUxUSEpYYVRrd2Fu
      TnFZVkpIUkVoRk9IUmpVWGd4ZGxkdWFFb3hWbE53TTJZeFpscHBaMlJ6ZVhkVkNsQjZOMWhvU1hK
      bGNEQk9aMDgyT1ZkbWQxWm5kbEJWUjFSWVRETkpOMHBEYTBkMWNWUlhZMmRJYVdaNmJHeEpiMmh2
      TTFSdWFVcEVhM2xRWVdsV1lsZ0tZVm8zVVdnM2FEUk9aMVpWUlRsaFRURlRXWFJwWjJsemJsVllW
      Vk1yT0U1SVpVdHpMMDQzY1VoM2VrRklTblZIZFhGalZHOXdPRzFLZFV3MWVuaGpkQXB5WlZaMmVH
      SkZTV2QxU0dkUVZDOTFXblJSYkFvOVFsb3pPUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure nftables is installed
      package:
        name: nftables
        state: present
      when: ( "kernel" in ansible_facts.packages )


# Disable SSH Access via Empty Passwords
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable SSH Access via Empty Passwords
  hosts: all
  become: true
  tags:
    - CCE-90799-8
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255040
    - NIST-800-171-3.1.1
    - NIST-800-171-3.1.5
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSS-Req-2.2.4
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - high_severity
    - low_complexity
    - low_disruption
    - no_reboot_needed
    - restrict_strategy
    - sshd_disable_empty_passwords
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGhRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      VnhaMUZCU2l0QmFXMXlOVVJ6SzFkcE1IcFNNV1ZYVWxaM1JWTUtZMmRJVDIxTlMwZHdLM2xFWTNk
      a2VubFdNVlJOZGtwd2VuWlZjekIxYWpWVFZqSkZVMnhNSzJ0VVdFZzBaV1JZV2toSWRWWXhkRmRq
      U21ORVZGRkVlZ3BXVjI4MFNtbFVWVE1yV2tKdFFrbzRlVmxqWjBRelNXZFNPWFJwV2pRM1NtTnZS
      bkZXWjNGdFRFTTViakk0VkRWV1RXbEpUMGg1YzJKU1ZUWklOREF2Q20wMmJVb3JjVmRaTTNSVldt
      cE1UV1ZCY2pjMVZYZGlOWGhuWjFodFdIWm5WVTFQVXpaR2VqbEJVMjV3YUdWelowUlVURUUyVkc5
      R1dDdDNVSFk0Wlc0S2ExaHZORlJ6U1VsbGVIcDNVa3RYU0d0MlZVMXphVXd4YzNFNFJtb3ZaRXhM
      Y2pWWlJFbE9NbFJoZEZSSVRGVnVSVE42Y201SFNFbFJNVWcyWTFoUUt3cGhZMUpoVWl0TWJrSkxk
      a3RYVkVwcFkzZ3ljRmxsTUdwVU9XRkNRMGR5T0c4d2RUWlpURFo2VHk5S1dFUkZkREozV1hGSVow
      TTBWekZSZDJ4WWFEVmxDbkphY2twM01rbFhlVmhMYkZrellsVlZhbGhFTlZaU1FsQkpZa28zYUhw
      dFpWWlBTV2MxTUhwMWVIZ3pZemxVVFU5a1VFcGhNSHA2VEdWc1dIQlliMjRLTVRBeVFVTnlVbk5z
      ZVRaTFNVNTVaakJSZWxobGFUWmlNRm9yVUc1aWNVeGthVWd6VmxKQ2MzbFdWbEY1TWk5MWRrZG5N
      ME5QYVZSSmQyeGpkbTE2TUFweFZYTlFWVkJTVkVkTVMxUlBjM0IwYlZJeFRWWTJkVmx5VkhKdVMw
      eDBPRGg1VkZSVWVrOW5MMHQ0YUZBclNWTjRSR012UW5kMVpsQk1VbTVQV1hvM0NrVlRRVU5QUlVs
      SmIzaG1SM2hPTUd0SFpYTnlUVzV3Y2tkQ01FdE5TVEl4UVROTGVFRmpZVmtyTW1kQlpFaHZlREZN
      ZGtSdVZFUkhVVGwzUW10VVZVSUtjbWxOYW5CVWRFRjFaVlZUT1dnelVXSjFLekZ4V2xwVU1qaFFl
      V3RpVGtaM1NqUkxURU5RYlUxRFJXOTBOMGQxVG01MmFXUmtTVU5JZFVSbVV6WXpSZ292ZEU1amFE
      RjJkSEpZY2s0emNua3hlaTlJWmdvOWExQkxkUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Disable SSH Access via Empty Passwords
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitEmptyPasswords"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter PermitEmptyPasswords is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "PermitEmptyPasswords"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitEmptyPasswords"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "PermitEmptyPasswords"| regex_escape }}\s+
            line: PermitEmptyPasswords no
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Disable SSH Access via Empty Passwords - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Disable GSSAPI Authentication
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_disable_gssapi_auth,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable GSSAPI Authentication
  hosts: all
  become: true
  tags:
    - CCE-90808-7
    - DISA-STIG-RHEL-09-255135
    - NIST-800-171-3.1.12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_disable_gssapi_auth
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      VkVORkF2YVVFMVlsTXhLMkpuV0Zab1ZISmtRMDUxWmtoVU5tOEtlamd5Y0VsdWRXRnJRa29yUW1G
      SloxRlROa2xxYjJoMVlqTmhSV3N2SzFKSFJIZFVjMHgxWXl0clRHeHpaVWRtYjNCRE1VNXlkWFY0
      WmxZdk1GazJUZ3BMWkhWTmFEbHhURlkyTm1nME1uQXJaa2h2UkhwaWJITjNkRkJVUmk5VVowMU9R
      bkZ0ZDNsSFlWZHRibU53WlVOdk9XNVRVQ3RFWkRWV1NuTmlTVkpyQ2pkV2JqazJhVzVuZFhSWFRr
      RjZUVzh2WVZKak9UUlNNbTl2TTNoVGR6RmFiMVprUjNsQ1dUY3dWblJDSzNGYU1YbFJaakJ3ZVhS
      YU1ubE9OMEp2TTAwS01VUjRPR2hXV0dKS2VWcEpkSE5HWkRkb01UbHhXRUZoZHpWbFNESnZkV0pO
      T1V0WU9YTkhRM2RVUmpoR1lrSTVRMUpKUjA1U1lrNXNNRmhLWnpZeldBcHNjamhxY0dzMFdVZGxa
      MnhzZEZNMmREVlFlVzl4T0ZGc2JteHZka0pvVFhKUVpWWllTbWRKT1V4VmNqRm1UVTk0ZUV4UFJY
      WXlTR3gwUzNjelIxbG9Dak0zWVdoTFlXOXFRamxxUkU1UllVczBiamMwSzJka1NrdzJOVmhPU1U1
      Wk16ZGFjMUZHTjJOd0swVmtUMnh0Y0RoVlkwcHpjVkEwUjB4dFdtWXhjRWtLUTJsWFZIRXplV296
      VkdkelRGSklXako0YTJKNGJIRm1UbTFDVmsxU2JUTm1TV3hJWkVKV2NrNUxiRzF6Y1VwVVVrWnlj
      RGQ2TDNodlRGSnFjekZ1Y1FwVWFXRnZibEZsZUdablFqQlRaakJ5UmtVeVRrMVlaRTQ1Y1dkelVU
      ZzVRVWhSTUVsMGEzZFhhbWRaYjFOdlRsbHNaRkV2YjBab01HOUZiaXRuV0ZoNENteG9jM05IZURS
      dk9HNHdNM0ZIUkdkcFJHVnZaelYwU1ZOVWRGQkVWbFk1WmtnMFMwSkhjRkF5Vm5CdVpqZFpiRXBp
      TWtaNGIzVnBaM1JoZVhFMFdIUUtTSFF3VW0xUE5IQkdTM2cwY0RGeWFXbEdRVXhYTVRGVWJUSXpa
      bXA0VW1vck0wSkJWMmxvUm1seU9FdG5la1I0TTFwRVUydzVNamxXVEZoR2JEUlFZUXBIYm1WM1pV
      Tk1la0poVjJWd1ZXUk5OVGx6WlFvOVVtMVRPQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Disable GSSAPI Authentication
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "GSSAPIAuthentication"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter GSSAPIAuthentication is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "GSSAPIAuthentication"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "GSSAPIAuthentication"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "GSSAPIAuthentication"| regex_escape }}\s+
            line: GSSAPIAuthentication no
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Disable GSSAPI Authentication - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Disable SSH Support for .rhosts Files
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_disable_rhosts,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable SSH Support for .rhosts Files
  hosts: all
  become: true
  tags:
    - CCE-90797-2
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255145
    - NIST-800-171-3.1.12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_disable_rhosts
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      ZHVUVkF2UVhGSVdUUlJjRXBWZGpOTVprMHJibFZwUlZaUGJpOEtUR05TWnpNek4zUTRObFYxYWxn
      M05XbGxOVzVvTUZOTU9XTjFRVXhrVkZvM1ZXUnNWVTFuWjJWRWFUa3hXbW96YjI1b1RuZHRUbE5h
      YTNsdmVFTXlRZ280T0ZWQ1pYWlZWMmg1Y1drMFJsTlpXRlJITDJwR1dFdHpOWGRMT0ZsNk5sWklZ
      bVJNZFRWQ2VYZHJkV1JKUTJaU2JHMWlVek0xUkhWdGNuTmtXbXhoQ2pSYUt5dHZkM1ZGYUc5V1Nu
      SllNM0kyVmpGV1prMW5aMWt6YWxoQ1VGSnVSbEUyTTNjclptVjBXWHBsZW0xUGEyVnhOM2xaZEU4
      MlozVjZSVkUxZERZS1JrYzVXV3BLVFVsV1kxVm9VSFYxYlZsWlpFcGlNSEZOVTJKalNWVnpORkpE
      YlROcE4wcHdRbkJEY1M4elQwaGxNVzVtYVhsSVRVVnpWMk5NU1VVemR3cElSV2xCVm1VMFJ6VjFU
      bGRUU213eWJFRlRlR2RHYVZoMWNGTmpjSEYxY0Vaa0t6TjJZVWRYZWxCeGRUZFBSVGRqZGpOdFdX
      MVJjV2xKTlhaWmIxUTFDbGROUWxOMFoyRkZkQzhyVUVreVVHWjNaRXcwYnpCYVpIaEJWRFZvTkdK
      cFJYZ3djMWw2V0ZOalJHTktLek5NYkhjM2RuSnpaa0ptYlV3eGFWUnVhVGNLZDFOUVZUSkhkemhH
      ZFVFck1saDBXWFJsUzJkTlR6ZG5XbVJUZDBOR1RsRnZXWEZNVlVScVYzcFplVGc0VFdaWFNYVjZL
      M3B1WkRjemJEaHlWazV1VFFwd2RrSTVPV3R6TkVOV1NXTk1NelJrZW5CMlUxTXpVSFp0TWpkNmFH
      ZEVZMDVUTHpGSVJrMWxRWFpMY0dOMFZtTm5SblpMVDBWTGVYWkVXVWhHVjNjdkNtWjFPWGQzY3ps
      RU56VnZVVXhKWms5UVJuSkNaelZIZFhBelIwRklhbVpIWjIxVlFVRlJUMDVMYjFSdlF5dGFTVW81
      U0VkUE9EZDJWRzFoWjJ0bU16Z0tlbmhvWkVaT1ZFNXNTa05PUzB3MlNDdGphRlptVkZabE5HNVFX
      a05IT1dOUldtRnJVbVJ4VVZaaFNtdzFVek5ST0ZjNVNuWm9VakZQWTNSMk5VOHJVUXBqTUVFMk5V
      VkZSM2x3VkdFNU1URlhRM3B2UXdvOVJEQjZZUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Disable SSH Support for .rhosts Files
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "IgnoreRhosts"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter IgnoreRhosts is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "IgnoreRhosts"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "IgnoreRhosts"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "IgnoreRhosts"| regex_escape }}\s+
            line: IgnoreRhosts yes
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Disable SSH Support for .rhosts Files - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Disable SSH Root Login
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_disable_root_login,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Disable SSH Root Login
  hosts: all
  become: true
  tags:
    - CCE-90800-4
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255045
    - NIST-800-171-3.1.1
    - NIST-800-171-3.1.5
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-6(2)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-IA-2
    - NIST-800-53-IA-2(5)
    - PCI-DSS-Req-2.2.4
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_disable_root_login
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      ZERVVkF2TXpodFpWWldhWEkzUm1SMGIzWldZMXBFSzJjeFJYVUtlSFJRYVhsUWIzaDZkWFJ1UWxG
      TWNFOVJTMHRVVjNGeldYSkVTVlZFU0ROMFNHUnVlRWxWVDBkd1YzaFdlVEZxTVRGRFRVYzJkaTlZ
      ZVRCVVNqUlVRd3BVYkRaNldUWmpReTk2VHpCQlQwRlJaREZZUWpoRVdXNWhSRFZVWTNwWU9EUTFU
      bWMzV0hGYWJIYzJhVzF2ZEVsUGFHWlJVbEV3VVVWVlZUSlpRak40Q2pKclp6SjNaRk5oSzBGa2VW
      QjBXVEZFY0RObFN6WkRlWGMyTld0c2J6Y3JWM2N5WlV0aVR6aFVaVVZaVkd0eFRGQm9WbEpPTTA4
      NFNHOUZjamxYV0hNS2VEaEpVbFJrZVhGVFVHUmpTekIwYkhSalltaG9RMGRGTjA5TGMwZFRiVEJU
      VUU0cmF6QXpUVUZxVDB3clNVRmxSSEZzTW10TGNVbFhia3hHVFVoMWVBcHJkVVZOY1V0SmVtSjVW
      RkJDU25OcVJIVlhia0ZhYjFKcmNHOUtZM0JCVHpWbFlrRm5OVE01ZGtRdlluWllZM00wVHpKM1Ey
      cHdUVlpIYURScE56RnZDbnBNYWtGU2N6WlVOWGtyZDFZeWQzTmlOVlYyVTJWcVlVaEpZek5OVlZN
      clZGRlhSVmhKTnpWcWRWQnRWSEEwUjJKRVRUTXlkemd2YmtkblFYQkpXR1lLZWpKU05WSklXREF3
      VjJWd1ZuUjZNMlJUVGsxTWJYZ3ZVVEZuZUhaWGRHdEtRWGd6ZGxsbFNrRTRkMEpSTmtnclJHMW1j
      R1pHVDBkdk1GUk9XRnBPVXdwRGJISnNla0VyUVdRMVR6SnBRVUZLU210MmVYVlFVRTU1ZUc1bk4y
      SXpVSE5IYjNWNlNtUXdSVEpLVkhvclZGbFNPR2xIZDJKSFZXZEZVVVYwYVZWMkNtbFFXRkpaYWtz
      eWVEbExaMDl0TkdSNlVtY3dSblV2UlhWbFUycEJObGRtU3k5MlNXMXJNVFZOTW5acGJsaDFSbXRY
      YTFkM1lWVmtiMlUzT0VsaVZIa0thWEJwUVU4dk5GbGFTMnBUVmpaeVZFZERUMXBaVEUwNU9WcFFS
      VFpuUkZwallVdHJSR0pQUVZOdVVTc3hOakZ3UkdkSUt6SnljRGhFZUZvNGIxbHRVUXBKYkVaa01F
      dEZRME5rWjB4Q1pHbGtVWGxwU1FvOVRWSXlkUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Disable SSH Root Login
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitRootLogin"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter PermitRootLogin is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "PermitRootLogin"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitRootLogin"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "PermitRootLogin"| regex_escape }}\s+
            line: PermitRootLogin no
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Disable SSH Root Login - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Do Not Allow SSH Environment Options
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Do Not Allow SSH Environment Options
  hosts: all
  become: true
  tags:
    - CCE-90803-8
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255085
    - NIST-800-171-3.1.12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSS-Req-2.2.4
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_do_not_permit_user_env
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      SXhNRkF2UVhSNlExSlJhRE4zZHlzeVZIcEhjVlJMYm1OSFpEWUtlbk41YW5VeGVVMTNlVWRaVGtj
      NVJIZzBWVTAxVkdacVUwTnlWVTFSUW5JeVpqaFBZVTVSVmtNd1QwY3JXWGxMZWpFclYydENOVlpK
      TWpVcmRtMW5Ld294VjIweldtUkdlRVkzUkZoMWVsZExUV2hOYTJzNVRraFhkVzVaUW05TlNIRjVZ
      VWd6TkVFM2VqUXdXV2xTYkU5VmMxUmhaVWN5UlZSS1JHZzFSbkI0Q2tGQmIwSXljR2hNVEc5c1Ew
      NDVSVWQ0ZUhRd2NFTkdaV3hEVjBkdlpHVnpZazF1ZEhOSFZVUnZSV2hyVEZkMVF5dDFiRll3WVdw
      MGFtUjNXbmN2TWk4S1QwdG5UamR3WlVKVU1DOU5iRXBOYm5OaWVrMVNXREZZVDFGdlZtcHZUVE54
      TDFaRk5YcFVkSFk1Y2xsdWVUQTNZeTlQT0dSSFdUUnVTRUZhZVZNdlRRcG1kbFJTYkZKR05FVnBl
      VkpCVUdkWlpGaEhhVFF2TURoTlNXaEpSRFZCTDNCcUszTlpaMUpITVV0bE9IQlVNM2hoWjFSRVFU
      WnpXa1prVURsRVZIRlJDakZrYlRVMGFtMVJTbFJ6YjNwVVRqZDBUSFJ6WmtsRVZ6UnNNbUZtYlRo
      T1FYRjRibFp4YkRGak1GTndORGxtYkdGWlozcHZMM3B0V1VaV2VVTkdURWdLTUZGSU9WcG9Wa1Zt
      VFVGWmFFaHhhRlZFUm5SRWR6UlhaelZpZDIwNVp6UjZXbFp3TkRSdlEzWm1MMFpZUkhoWWRGSXli
      bWRtSzB4VlIzQnVTSG8zUVFvNVltbElVVk0yTjJaNVVqQXhjM0psVlRaS1VXeGxOa3RCUVhacGIx
      UjBZVnBzUTIxTlNEbEtTVXhPVHpaUGEyRjBORzlCZUV0TWExY3pUa0UxTUdoc0NubEdTMjA0VkV0
      TFRWUXdlWEUxZDJ3M01FcEJSREppYTJGT1FXYzBTSGxzU25aQ2JHOXVUQ3RUU0VGS05VY3hhMEZ4
      ZVU5MVdVOUxRMHhDVkdaSGVTOEtRWFZWV2trMmREYzJZVmxZZHpKUUwzaDJMMm8zWTFZNGFsTkJU
      WGxUUVdkMFptbEdSRFZrUzNGRlUxTlZXR1ZhY0VNNFpuRktVR2RaUTNOa1VFUkJZZ3BHYkdoRlkz
      WjNRblVyYVVkc1NGbzJhVzgxVGdvOVExTXJaQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Do Not Allow SSH Environment Options
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitUserEnvironment"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter PermitUserEnvironment is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "PermitUserEnvironment"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "PermitUserEnvironment"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "PermitUserEnvironment"| regex_escape }}\s+
            line: PermitUserEnvironment no
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Do Not Allow SSH Environment Options - set file mode for /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Enable SSH Warning Banner
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner_net,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Enable SSH Warning Banner
  hosts: all
  become: true
  tags:
    - CCE-87979-1
    - CJIS-5.5.6
    - NIST-800-171-3.1.9
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-8(a)
    - NIST-800-53-AC-8(c)
    - NIST-800-53-CM-6(a)
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_enable_warning_banner_net
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGpRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      bEtUVkF2YWxKeGJuVlNkVlEzZGtkaVVHSTRVbmc1VTJwaEwwMEtTMnRPZEZkeFdEQkpjbE5PUWpO
      dVUxTnZOM2d5YXpkMVVWWXJVbU5QTTNveGIwWlNTMHgyYmxrM1NXWnVZVUpDTm10clFXUlhUbEF3
      WjNaR1NtcHdWUXB0TkVkcFdVeFhkMGRSVGtNMVVqaG5aVkJzWm1aVFEzUnNTM296UW14bWQwUjFl
      REZGVGpBNE1qZGtjMmd6SzNWSmRGcHFTRmRVUzJRMFFVWnZXRmh0Q25saVREWjBaWFEzZVZWVFZt
      dzRRakZyS3paaWVEVXphbmxzUmpkamNsWjVibWRPZUVWMWVIaFpVMmt4S3pKb1JGUnZLMnhLTWxS
      Q2QydG1WVnBzYlhRS1pYZExla280V2xCVVR6UnplVXMyUldkMmJFd3hTWGhoTVZkbVRtcEZWbE41
      ZEVaSVprRkZSM0YyYVRnMU9HWkxXSE5QU1dGMVVHZHdlSE5PWVVGUk5RcHFaVWd2WWtGS01rUTRX
      VXN5TUdjMVpuQkphazFxY0ZoT1dESjZWMkowVGxCUVNrdGhjVUpoVjFwRFVtVllWbFJzVFROMVJV
      ZFVNSGRLWTBkWVZVOUxDbGM1Wkc5MWFqWnpSMk1yZGpONFIxRnZiekZ5VEVzemFtOUtOekJJUlZO
      UllWWmlkVE41UmxGeVJWTkhhMnAyWjFRM1J6bDRUV0pKUW05NU9YQlViRVFLZEdwdU9UTmxXVkp1
      V0dGTlZXRm5kWFZJYmk5UU5VUnFjbk5WZDJSMWRVODJRV3hHVkVjMWJVNWpUMUpZTlZCVE9WWlZi
      bGwxV1c0Mk1WVTRkRmcyU1FwaFpXVlRNVTlyYkVGQlJXaE5hVGhWWmtkbGFEUlVlVWxYWTJSSWVE
      RkNUbXhwVFhFeVJYcGxNbXRIYURWblpIY3hRblZhZGtKYWNFaHFjek5wUzBONENuSnZMekozVm0x
      UmVIYzRVMWcwWTBSMFpHSnFSWEJuVmpVMmJITXpSa3BEWW1oUFNGVlVWWEZCV2tKVVdUbHVZMUoy
      ZGxKeVRrNXhjVkpLUWxrMk1VUUthamhCVlhWMGVXcERZbkExVVRWVFZ6QTFVRUU0V1cxTFVEUnla
      RTVxUTI1VVFYRTBOVFpFUlVwQlRFTTJaa1o1YXpGR1IyRmhNV1pyT0VGRFJYTmtPUXBFYW05cVZt
      cExhbWRrTjBOalpYbFJRbXB6ZGdvOWFqSXhWUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Enable SSH Warning Banner
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "Banner"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter Banner is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "Banner"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "Banner"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "Banner"| regex_escape }}\s+
            line: Banner /etc/issue.net
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Enable SSH Warning Banner - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Set SSH Idle Timeout Interval
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH Client Alive Interval
  hosts: all
  become: true
  vars:
    sshd_idle_timeout_value: '300'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGtRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      SXZORkF2UVhOdVlsRjZlVEJyY25aTE1FdzVZazlMV0RCWVIzSUtZbWxKUkZka0sybHJVVVZWTVda
      eU4wUjVSMEY2UmxSV2ExVTFhbll3VUZCRVJtMDBUVzVvTWpONU5tVTFUMUZxY21aNWRTOWlORzlo
      Ykd4Tk9UWnpRd3BTTjNKQ09DdDFVWE00ZUhGSlVWTTBkekpRY1hsa1ZHUk9Ua2sxUVdOTVZXeDZl
      azFHYTNaSFRtcDJlV2hxY2xKa1YzUXhLM1V2Y1VRMU5VTnJSa3QzQ2paNkwycGFZUzlGTm01RWVs
      VlRPR3h4YkVSeVVsZzRSRFJGTjNkS2RVMTFNVlZSYUhSSlRGVTJRakZ5VUdJeE9FbHVTRVJJVWpV
      elFXSkVjeTlPWmtzS1UySlhPRFp1TUVGeVFrMDBUblkzUW1rNVRGQmhNVTgxVDFrd05GWjNOMHBs
      YkRCeE0ybFNUQ3RQVDJVM1NDOWliVFEwWlhKQ1QwOXdWemt6VW1aMmJ3cHVSMjh3Umsxc1RYYzRh
      bXRHY1hkM05uTm9WRWMxWTI4eVYzQm1UbGhzU1daT1dIQnRlRVJHSzNaSkszZHlTbE4xTm5KdVUy
      eDRWbEJIVFdWR1JFZzFDbXhwZFRCRmQyZG9OWFJCTDNJM1VHbGpSR0ZFTVVReWJFNVBXSE5hV25Z
      NEwxVlBiVGRSWWxsNlUzaG1OakU1TTNjNU1saHFVa3dyT1hWdFNtc3paM1VLY1dkUFVUSnljRXhH
      WkRoTFZUazNlV1ZxYkVFMlIwTnBkVXQ2ZWtKamNrRjRORVZFT0cxa1pXd3dNWEpIYW05bEsySnBR
      bU5GY0hodk5rVkdPRk5ETUFwR016VlRRWFI2Y25wTEwyUkVXVEV6VG5FdlNpOUlTRWhaV1VOUlIw
      bFBlV1pPY0c0MVdWZG9hVE0yVGpoWGNHdHBVMlprUVZNcmRsZGlNQ3RCVVZKQ0NuZzVNRVZUVGxo
      NlVHMU1SWGdyUVhvdmFHRk9XakJXVmpsRlprcEVRME5xWjJjM04zaFJOVUZrWWxOM1RWWTNkVGxJ
      VWpOa1ZXbG5PRmQ1T0RGb1QwSUtOblZDV1c4MWFVZFBRWEJaU0VzclQxTjZRMDE0VG5OVlltSndU
      MjVKYUc5clNUTmhSa05vTVRCUlUyWkViR3hwWW1vNWRHTlZjazVLYW1KTGVVRk5XZ3BNYjAxbU5u
      cEpUUzlMUVVWd1YxQlhZbWx1UWdvOVFXSm5kUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-90811-1
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255100
    - NIST-800-171-3.1.11
    - NIST-800-53-AC-12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-2(5)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-10
    - PCI-DSS-Req-8.1.8
    - PCI-DSSv4-8.2
    - PCI-DSSv4-8.2.8
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_idle_timeout
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set SSH Client Alive Interval
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "ClientAliveInterval"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter ClientAliveInterval is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "ClientAliveInterval"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "ClientAliveInterval"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "ClientAliveInterval"| regex_escape }}\s+
            line: ClientAliveInterval {{ sshd_idle_timeout_value }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Set SSH Client Alive Interval - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Set SSH Client Alive Count Max
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_keepalive,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH Client Alive Count Max
  hosts: all
  become: true
  vars:
    var_sshd_set_keepalive: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGtRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      VnFkMUF2TTIxUFJHbFRRbko0ZUZGUVJUZGtaMUJpUnpOQ1FYVUtaMFo2Y3pGUWMyVkNUMDB2UldS
      bFJXOXlObGxMZGt4dU0wbHFRblpoWnpsd2VsbDVPSFZMY0VGRFlXaHZjSGwxZHl0TU9FUmpaV2cy
      VmxvM2FEWTJUd3BSVXpGRE1VTk5SM3ByTURkcFNHd3JjSFZNTjFSWFpWUjZRa04xUzBkSE5VSndX
      SEJ1ZW10d1VFeEVVV2x6TUU1eFIzSTVWRmR4ZUVFcmJuaEZSVXhhQ2tvelFUZEVkRFI0TTBOelQy
      TjZORkJvVFVGMk9Wb3hla1F5VlhCc1RURjJSVmhJVEc1RE5WZFdXamQ0YjBaMFFVaFZXSGR5YjJs
      dVEyeHBTM2xNYlZRS2IxRlBTM2cwVDNKclExbFdkbTl2ZG1wd1ZFeHVkRTFpVVRBclYyTmthRGxa
      UTB0YWFFMXNjRTVZWVhOSWFEaExSM0ZuWW5KWGVtbEpPREZ2V1V0U1ZncFFUVk0xVlU5YWRVTTFL
      MnhuYWpGd2RsUkhNMmM0YUhkWVdHNTNaVE5ZY3psNVlWcHpWWEZVTTJsa2ExWXdaekpaZURoVkwy
      OUlkMHRDTWxSV01URlFDa1p3VDJvek4xTkRlVFV3WWpCS05uSjFUVEZoUWpCdWNrRlRhV3BZUjNK
      d01HVndaVXBtZFZOV2VVcDVXRTgxUlRoVmIySnRLMXBJTTBFM0wzZFJOV3NLWlRkWlMzWmpSbFZN
      WjFodldtUlFVblZMVTBWYVdscGlWMkZzVUd4R2RtTllSRUV5WW1wWFFsSk5SRkJxU0RCRFYwMUxj
      MDRyY2tZNVRtbGlkMHBhYWdvM2JUWm5TMFp0UlVsSVVtVnNNMDR2VldGSGJXRkZMMVF5U1dkNGVV
      RTFTVmRXYm5oTFlsSmpRekF6VEZOd1pHbHpjRXhTU1hkdmExTmlkRVpJTW5scUNtUTVaR1JEVG5o
      UlVrRXhkV3BYVEVsRFZWaHJkbEptVkd0bVRteFpOVmQ0VGxScldXUmhUV1J4YTJaRWJUQnFaR2hN
      TUVsb2RFZFJhR2N3UmtaRVNUVUtVVFpYV2tGaEx6WjZXRW81WVc1NU5GTjBVMmt6TlcxNmVHMXhi
      MmRRYm5sRlVHeDZLMUpXSzJkVVdpOW5WbFpNUmxwRFRUSmpUbm95U1RGNlVHWkxSd3BqV2todFIw
      eExVVGxoUzJ4bk4zSndORUpTZWdvOVNXTTNSZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-90805-3
    - CJIS-5.5.6
    - DISA-STIG-RHEL-09-255095
    - NIST-800-171-3.1.11
    - NIST-800-53-AC-12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-2(5)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-10
    - PCI-DSS-Req-8.1.8
    - PCI-DSSv4-8.2
    - PCI-DSSv4-8.2.8
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_keepalive
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set SSH Client Alive Count Max
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "ClientAliveCountMax"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter ClientAliveCountMax is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "ClientAliveCountMax"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "ClientAliveCountMax"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "ClientAliveCountMax"| regex_escape }}\s+
            line: ClientAliveCountMax {{ var_sshd_set_keepalive }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Set SSH Client Alive Count Max - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Ensure SSH LoginGraceTime is configured
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_login_grace_time,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure SSH LoginGraceTime is configured
  hosts: all
  become: true
  vars:
    var_sshd_set_login_grace_time: '60'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGtRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      NHZSVkF2YW5WWVZubGxaR05NUlRjMVpEbE5RVVIzZERNMWFFWUtXR3B6ZWtsSVMyWnJiRFIyU0RG
      NlUwRllZVlphWTBaMU5rMVZUVGRJUnpFM2FYTTFhRGczT1VJck1VRjNURTF3TjFwMlQyTnpTRU5H
      U0VWYU5HdGFTd293YmpGVGFpOVRSWE5wWlRCSVZXNDJaSGh0ZUZCa00wdFpUMHhDV201VVQyUlJk
      bFJQT1dsRmFscDNRbXBWZG5CcFRreENWSE5OWTNkb1ZscEthR1ozQ2xaWmVHdDRiMkZSZVc5YWF6
      VTNZVkJ2Vm01TVJtMWlNblZVYWpFNFJDdHRUazF3VjBKd1pHZ3JMMUZWV1VkYWNYbzVUMlE1VkVO
      bWRsWnFiVVY0TDFZS1ptcG9OaXNyUkdsb1kza3ZRakpaYldJNFkyWm9TV3BUVFVacWVsVnplazlD
      U0VoM1l6ZEJXakJrVEdOdVlrZGxiR0ZhU0RGQ1N6aG9NblV4ZVd4cU1ncExValpITVcxTlZFazVi
      amxQVm1obFIxZFZNV05TZERGclVtNXdiSHBwZVc5UFQybzRNMkpQWnlzeGQwMUxUbFpoUWpKUE0w
      TjBVV2xEVGtONWNTOWpDbkEwWkhwSU4xVklWMHRoWTIxNVRrRkVNblZUYlZSRE5EVTBOR3RITVM5
      cFdIUlFhaTlxWlhVdk5VUTNMMk5sUkM5cWJYSnplamRJYmpkdUwwWnJhbUlLY1VOUmQxSXliMmhI
      VFRaYVRWWnpUbmxNYTA4MlIwZzFhVWxGZGpoT1luZEdNRVJQVVVSaE5FMXlUM1paZEV0U1dtdFJS
      a2w2VEVSamRFMVRZVGRRU0FwSWRYTldMM0YyVVVKMmQwazROV2h0Ukc1aWFXWTBOWFl2TDJkTFdY
      TjFObmhTVmsxVEswVndUVUV2T0hSTFZFcDBRMlZxVHpsTmVsVlZTVWN2TkRScUNqbDJkR2RWVFdJ
      eFYydFVVWHBOTUhsNWVFdFhVREl3Y1ZsRVRrSllhRWRvV1c5WFYyVkVSM2RRYzBrM01ETXJhWE15
      VFZSTU9GbFpkR1pHS3pGUmJFOEtTVUowY21GU1VUY3laVmRTU0dkdVYxVlJaa295UjFCYVdIUnhN
      MDFGTVhvd2IzUnNRMVZKWkZFNVEweHdMekJWYW5kTUszbDRWSFU1Y0ZoMVRVVXJlZ293WkZVNFlY
      WlVja3N4U2tFMlRFeERlVlJ0YWdvOVlURXpUd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86552-7
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_login_grace_time
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure SSH LoginGraceTime is configured
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "LoginGraceTime"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter LoginGraceTime is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "LoginGraceTime"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "LoginGraceTime"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "LoginGraceTime"| regex_escape }}\s+
            line: LoginGraceTime {{ var_sshd_set_login_grace_time }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure SSH LoginGraceTime is configured - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Set SSH Daemon LogLevel to VERBOSE
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_loglevel_verbose,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH Daemon LogLevel to VERBOSE
  hosts: all
  become: true
  tags:
    - CCE-86923-0
    - DISA-STIG-RHEL-09-255030
    - NIST-800-53-AC-17(1)
    - NIST-800-53-AC-17(a)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-2.2.4
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_loglevel_verbose
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGtRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      cFRVVkF2TXpGcFUzSTJabkJsYlRSWE5HWkhaMDFLTWt0UWFXWUtjbUpXVEU5bk5rZGpaVFZPV2ta
      SFUxTkxVMnRsT0dKbmExbE5ORmxXTlRkeVdTOTFRVzVGV0V4eFdFSllVbXRJTmxkYVJFUlJTMlZE
      U25CMFozSm5iZ3A0SzNKbVJsaG5Za2w2VTJ4NGVtUXhTRWwyUnpST1IySmliMkY2YkdoTllYQnNT
      RlZvVDFaYU9WVmFZME5pWW0xaFRrUmhVRk5vUjFSM2NURkdLM1JIQ2xJeWFFaE9VVFJRTkhCd1pr
      d3hMMjE2U1djMGQzVlpiaXQ0VG1Wbk4zUnZUVVF2UVVSMmJreDJaMjlOWnpodVJ6ZDZRMGRNYlRK
      SFptZFhlV2Q2VVZvS1VVMDNXRmxTU3k5eVNIZFlZMDlJSzFCdVVUaEdhbnBaZFRVMWQyc3dNMlZq
      VTNRelJHbzVjMjVqU0VoU1RIbFpSbXBUYms0M2NtczVTbWw0WVZCcFRBbzFXVGRzYzI5UU1uVklj
      VmRXTDJsUmFuTnBVbmhLVTIweVVWZHBkREJXYm5JMlVrUjVaSFJVYVc0MWFuTjFMelI2U1Znd1Ew
      WTRhbGs0YUM4NVdtTmpDakppVEZNcmEyZ3dWV0pRYXpKd05WUnVWbTlGYWtKRGNFOU5TbmM1Um1a
      UU9VeG5VbHBQY2k5Nk5YZ3lTM3BhVjNvNWVFcGhjeTlTYlhjeGFtTkVUbGdLVHpoSFJtOVdNemRw
      TXpoVFlYRndXaTlaUm1sUFNtUjRUR3g0U2pZNFNsbGFPRlI2WXk4MlVuTkVNRFI2YlVoeE1VVklk
      M1pZYVdGSE9HMUxORGxDU3dwSmVYbE9TM1J0SzNneE9FOVlZMGcxTTJkNFNtTnZUVXhsYlRaelFY
      VnJRMHhxYm5Sck5qQXhWakZMY1V0d1pDdFNVak0wVWlzMU1qVXZUREZUTUdJMUNsaHhORll3Y0Ra
      cmFWb3JNbTF1VkRaRFJXbHNSbFJLV21STE5sWkdNR3BCTmxsWlozaDRaVUpqZDNKVFdsRlNabTh2
      ZDJOV01FbDZhMmMzTldobWVYZ0tVR0ZCUlRoalJtNDBkbUZFYjJOU2FHZERjbUV2Um0xc2MyaEVh
      MFZFVW0xMFpGRXpialo0UVZGVFVFcHFaa1pQTVZOVGJIZG1lamw0THl0cVpVUllVUXBVYm1KcUww
      eFdWbUpTT1ZCVmFVNHlWVlpRTWdvOU5rbFlid290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set SSH Daemon LogLevel to VERBOSE
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "LogLevel"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter LogLevel is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "LogLevel"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "LogLevel"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "LogLevel"| regex_escape }}\s+
            line: LogLevel VERBOSE
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Set SSH Daemon LogLevel to VERBOSE - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Set SSH authentication attempt limit
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_max_auth_tries,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH authentication attempt limit
  hosts: all
  become: true
  vars:
    sshd_max_auth_tries_value: '4'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      Vk5kMUF2YVVGU1JtNXNWVFIxVDBWMGVHZHpWblpJYUVkTlJIVUtibWh3Unk5dlNIaFBUVE4xWkZR
      ME4xUkRjMHh4T0ZvdlNGSmxkRzFNY21kUFp6ZFdVbWh1ZVZwbVZtNVBWR2hGZFRsUFNWVkxTWHBD
      Tm14dGFsTm1jZ3B3TkRRNWJrVkZjbk5KWm5sRE1DdGtSME15VUZkcWF6VjVZVlUzV1hSR05XcHRW
      elZVVlM5d09GWm5hM1J0Y1VabVdsWldhRUZOVlM5SldYSjNZbG93Q2xSMmNqVTVXa2ROUkdkelVr
      MTFhVzR4TWs1eWNWTmpiMnR2Y2xWS1VuZFJUamRzVmtReU1raEpaVlpKVFRNd2FuVk5XSFpZYkVW
      NVowSmFLelJFU1ZvS1lXcGpNRk53YWsxcE9IZDVXVUZPYm5wV1REQktNMXBuU0cxSGVGVkplVWRS
      YTFVck1rVjBNa2RVUkVGMGIxQnhTMlV6ZW1JMWRtSkZXbXB4TTFsYVdBcE5UMXBDTkU1R01VMDFW
      VTU0Y1ZVMmNYY3lXbFp3Ykc1dlYzUlhOR0ZtTkdaVVQzRnhOVGRHYVV3NWJHRm9NQzlDZUZCV2Ez
      WlRVVmxxWmpsSWVreFJDa05SUTBsaFdHWnpZVVowUVZsRmNXWlFNbEZhU1dkTlZqRklXRUp5WkVk
      MU9IZEtiRkF3SzBGUWFGWk1Wak01VWtRMWVsQmhOMWwxUldkTmNXbEJSMVVLVUdSUmFFbDRLemhI
      T1M5YVJta3JOWFpUTVV3MU1UZG5TMGd5V25BM1NqZEJkUzh2YzBKUmNtOVllVFZXYWpCT2RqRkhW
      M0paWVhrdlNHNXlRM1Z4WlFwNldtbHpaMmRWTUVGNFZTc3JabFZuYTIxcFptSnVibkZ2ZUUxcVlT
      ODVVeTlJWWtGSmRtUmpjemxvY0hOM04yeDVUVmxKYWtWMmJucFFNVkZEUmtoSUNsWmFNMlJuYWtn
      MmRWSmpkV2QyVFhKWlNYWjVRMlZQYURneFEydEhjbU54TXpKd056UlBkVkJWT0UxTGEwNVhha2hx
      VWpSelRteGhkbWhrUkdoVWJFd0tNbmc0Y2t0aFFsWjFMMnRoWkVFMVJtaHVVbVJKUWpGRmJHVnFN
      bTEwU1hvNWJsSjJiRko1VUROMFdubFlMMkp4VERGTE1ETnBLMVUzU1VwNFlVcHRXZ3BOTm5ZelVr
      aG9kbGxtYTBSaFdIa3hablJ4UWdvOVYySklaZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-90810-3
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_max_auth_tries
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set SSH authentication attempt limit
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxAuthTries"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter MaxAuthTries is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "MaxAuthTries"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxAuthTries"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "MaxAuthTries"| regex_escape }}\s+
            line: MaxAuthTries {{ sshd_max_auth_tries_value }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Set SSH authentication attempt limit - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Set SSH MaxSessions limit
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_max_sessions,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH MaxSessions limit
  hosts: all
  become: true
  vars:
    var_sshd_max_sessions: '10'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      UlVZMUF2YVZoSmNFSmpTbFUwTkV4M1kzcFNaMkZvTldKdVZEZ0tWblJ1ZHk4d1RsQkRSMFJwY2k4
      M05XZzJWMDlEUTBoV1NITk5Xazl5YW5OVVZXTklObUpsWlVWVU1sVXdNVkE1WmpWcmVFMW5SWEph
      ZDBSRlFtMHpZZ3AxUVRkSWNURnpUSGxCV1hGNVVEbGxTRWRxYm1STVlVMHZTa05HWjNac1RGSjZR
      ekZrY21seGEwdEtSbmd3WlZvd2QxcDZRV3BoYXk5ak1uZEhUR3RvQ2pSc1JGVkllVlZzWkhJeVdt
      UTFlR3RGZGxaNE0ycDZSMGxVZEVJd2EzVmFUV1ZXT0RWQ2NGTjRMMmRTZWxKUmQzaGxZbU56VUVS
      c1FVSlhVRzl5Ym1rS1JuWlNTV0ZVZDFKc1RITTRWR1F6V0ZwWk1uRXhXaXMwTUVsUFRVSXZkbE4z
      VG1sWFdGSnZaVmh5U1hSelRHbFFUV05YTUU1aWVsRnNXSGRYWkZOR1l3cHFSbEF5YTB4T1VFWlNS
      blZDU21wbFNUWlNWazQ1Ymlzek5YZE1jVFJWYzB0MWNtNUlUSEJVVEVwRGExRm9kbFUyTmtFMloy
      dHlRbEJGTnpkeFlrNXVDbUpHV20wcmVtNXliMWczVWpSWFkzaEtZM05OUWl0bmEwUkhObkpvVFZa
      RlRrZDJVSGRhVDFNelJVVkhNRWhPUTBFeGNIQlZNVlZZY21Fd01GRXdlREVLUVdwNFJWTnJjVFZ5
      WkVwS0sxQkxhbEZLYzNVd2RtMU9RMUpRWkRKU0wwOXJkR3BGWkV3NWVXaEJaREp2U1VJeVdrWmhS
      WEpxU0VaUmVWZFljRXRKVUFwQmRsZFNlRkJRSzJ4TVJubEJRek5SZVhwNFUwSTROM280ZUVFeU4w
      ZFlWMWxUUkU1MVYyeFlZamhXZUdOTlFqZGhjV2RQVVZkYWMwMTZSRFo0VFVkMENrTmFaWE5EV0ZG
      VVVERm1MMEpQYmpsdFRVaHVNV1pITkdSaGNuSkJRVWcyWlRGVFRFdFRjbGxUWWtKUVMwWkZPRzFJ
      UVVsamIzWjFSSFkwTTFSbVNVZ0tVMGswTlRKRGVVeHZaMlkzY25jMGJIZFFNbEUzTlUwNE0yZDJO
      REJzTTAxelpFY3lRMU5qTmpSV055OXdaa2hJVlRscFZHSkhUM280VkdaV1VVZEtlZ3BtWm5od2Ex
      SjVUV2cyYkRBdmVrcFVZMEZVVXdvOVpYaHVWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84103-1
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_max_sessions
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set SSH MaxSessions limit
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxSessions"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter MaxSessions is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "MaxSessions"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxSessions"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "MaxSessions"| regex_escape }}\s+
            line: MaxSessions {{ var_sshd_max_sessions }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Set SSH MaxSessions limit - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Ensure SSH MaxStartups is configured
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_set_maxstartups,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure SSH MaxStartups is configured
  hosts: all
  become: true
  vars:
    var_sshd_set_maxstartups: 10:30:60
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZGxRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      QnJTVkF2VW1oWlExSnROR3RuUlcxaFZUVkhZVzFWVGxCRVMxWUtOMmhoTkZSNWFVMVlZazF2Vm1S
      VmN6Um1abEpVTXpSU2QzbFpRVTl3WmpJdlkzRlVLMEZDV0c5emVuSnpSV3A1TVZOc1RIVXJTbk5y
      VlZoelZVZHlhd3BKT1dSaldDOW9RMnQxY1hsa0sxTjFTbWRWTTA1R05HcGtVbW81VUdKWU5pOVJa
      RzlMT1ZGbWNuZDVTalJFTVdGQlNUSTFaRGt5UkV4SmQwUmhkelpaQ2s1RVlqWTNjMGR6TXpKUGMy
      aHBZbkl3UkhObllTOXNNVlk1VjNCeWEyRkhXRWd6YVdjeU5uVmFSMlpXVTNGdldFdFFNRTF5YjI1
      cVMwUlBiMGh5WWpZS1VXUkZNbTl1YkdwV1MzUjFZMU5vT0V4bVpGSlFVM1E1T0M5VUsydE9NMjUw
      WlhKSGNXaHFlbXhhVkhaYVkzTkJLM2d3ZFUxV2FFRnFSelpDY1VwM09RcG5SVlJ2VmxGRFVsSk1S
      MnRLZGxNMWJ5dDVWVGhETTFNNVZWTXhObk0zTjI0eWQzSjFNVlY1Vm14aU5uZ3lNMDVMZUVSSWFX
      Y3pXRTlHU2pSWmJFeEhDblpXUjFObGNrOHdaME5vTWtsSlNtTjBSVzFEVDJKSloxVjNNMHA2UlVJ
      NWJtMW5hRXc0VUVRNE1FcG5NbmRoWlVwRVZqUXhRWFYwYmt0NVlTOURTamNLVW5CMlVIZGtZV1Z2
      VG1SMldUUjJjMFp6V1dSU01rWnlVR3R4VEhSRFNVZG5Va1J4T1RreVUySnlNVFpsTmxkcVdrcGlX
      bVJuZG1Wb1VYWjJlbFJWYkFwNVZHNHJPR3BCUmxVMk5rODBXazE0VGpJd2FscGtUbGR5T1RZM2FV
      bEliMWN5UVhSYVEyeDVVelpTUjNGS1pDdElNVFJwWnk5RFQzaHZNWEZvZDAxVkNtaEtVV3MzZVdk
      NVlrRlJhMVV2VVdvd1lqUlVPV0Z3SzJSTU9HTXpURkFyVm1Sc05rZHNla0l2TUVSVWJFcDNRMDB5
      U1VOcVRqRkNRbUUwYjJJMFRYUUtZMGh2Wm1Wd1QwRXZTV05FZEdkcVpDOXFkbk54ZDJ0dlozbFla
      VGRaVEVrMmJHZGlOVTlLUzNoMlVFZzFTVmRuZHpScE56RjFiazVwYjNkQ2RIY3pUQXB6YVdwNU1q
      aE5WR1pxU2xSNVJuQnZSRkJzTVFvOWMyaFBNZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-87872-8
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_maxstartups
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure SSH MaxStartups is configured
      block:

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxStartups"| regex_escape }}\s+
            state: absent

        - name: Check if /etc/ssh/sshd_config.d exists
          stat:
            path: /etc/ssh/sshd_config.d
          register: _etc_ssh_sshd_config_d_exists

        - name: Check if the parameter MaxStartups is present in /etc/ssh/sshd_config.d
          find:
            paths: /etc/ssh/sshd_config.d
            recurse: 'yes'
            follow: 'no'
            contains: (?i)^\s*{{ "MaxStartups"| regex_escape }}\s+
          register: _etc_ssh_sshd_config_d_has_parameter
          when: _etc_ssh_sshd_config_d_exists.stat.isdir is defined and _etc_ssh_sshd_config_d_exists.stat.isdir

        - name: Remove parameter from files in /etc/ssh/sshd_config.d
          lineinfile:
            path: '{{ item.path }}'
            create: false
            regexp: (?i)(?i)^\s*{{ "MaxStartups"| regex_escape }}\s+
            state: absent
          with_items: '{{ _etc_ssh_sshd_config_d_has_parameter.files }}'
          when: _etc_ssh_sshd_config_d_has_parameter.matched

        - name: Insert correct line to /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
          lineinfile:
            path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
            create: true
            regexp: (?i)(?i)^\s*{{ "MaxStartups"| regex_escape }}\s+
            line: MaxStartups {{ var_sshd_set_maxstartups }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure SSH MaxStartups is configured - set file mode for /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
      ansible.builtin.file:
        path: /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf
        mode: '0600'
      when: '"kernel" in ansible_facts.packages'


# Use Only Strong Key Exchange algorithms
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_use_strong_kex,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Use Only Strong Key Exchange algorithms
  hosts: all
  become: true
  vars:
    sshd_strong_kex: -diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      cG1iMUF2TW14aEwyUTNjelpZT1V4TFNGaENMMjQ1ZVhnM2JITUtWRzVJUVUxTFRtaG9Nak15TURV
      MmVGbEZSWFpJUms1alNtZHNaVzh3UkVjMVUxRnZWRVpQVERKQ1NVUmhiWEJxV0daRmRHdzRkMkZQ
      VUhwaE1tcHhUZ281WlVwSGFsUm5MMkkxTDJwaVEwSTRkM00xUnpoWU5sVTRZV05JSzFnNFNFdHhi
      M2hKVmsxSk1qRktiVVJuZGpKclVHRTNSa3hSY0dkQkx6VnNhemMxQ205Vk5UTllZV0ZHVDJoeGFu
      RlZlRFJaUnpaMWRqbENUaTl0TkhWYVIyaElUVEpzUjJOWWExWk5hRGt3VmxaV2VHUm9NR3R3TUZk
      MGRqUjFOVlJ1WjFnS1drSkJURUpqT1RoWWNWSkZaMjV4UzJreFkwTXlaSEpXV0dac1JFeFJZMFpu
      TjNWRVIyZzNXSFF4ZGxwNWMxUXlRakZ3YzFaamVHZDBZa2t6UTNSNVRBbzBNV1p2UkZRNFFXWXhl
      Rk40U1VoNWRUTmpRazF1VWxaaloyTkVOWHBxTmtsWmVrNVNabFprWW1FMGMyVXhUWEZuVFc4M05U
      TTVUV3RyTVZVM1FqY3dDbTVvZUUxelZHNHlPR1pCU3paalptOVVUbkV6TDNaREwweFFTM0U0U1hk
      Nk1tSkxSRFpOYkhoekszaHhWV2tyU0RRMWQwOVpjWE5XVVdGc1VrZzRTa0VLVWxGR0wyZG9OMEY1
      Y1VKM2IzTkxZVUkwWVhWNk9XZENUSEJ0VlVsVVdsZ3dUU3MzVEZWNmFIaHllVVJNV25sTllscHdj
      RkpMT1RJeVp6a3pkbXRhZFFvM05rOW9RMlpaTmxkRUwyNDFVMFpLZFRKcGRXRmlSM2R5VVVwTmNq
      bEhkakl4TDI1a2JUVkJhbWQyZHpobmFUQnFWbnBNV0hablFYZDFWVzlKWTBkdkNtaFdWalp1ZEZw
      b056QXdObFUxTVU5cWJHVXJUbVJ6VFhaRk5sUjFNSFJwZERCVldFSXJWbWhNVVRJellXdHdSek16
      U1hoV2IxQXphR1IyY0ZCc2NFNEtVME0yYVV4RFNFZGtPRXhUVGpCRFNXbEdWR3d6VEc1bFlVaHhk
      M2swVmpsT1VHMUxSbHBKZVhWSVdGVkNhMUJpVGxSM1ptZE1TMHQ0VGpOT2RYVTNUZ3BNUjBwbVls
      cFlUM2RoWmpkT2MwVmxPVFJITmdvOWJ6WlhOUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86768-9
    - PCI-DSS-Req-2.3
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.7
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_use_strong_kex
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Use Only Strong Key Exchange algorithms
      block:

        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*KexAlgorithms\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*KexAlgorithms\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1

        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*KexAlgorithms\s+
            line: KexAlgorithms {{ sshd_strong_kex }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'


# Use Only Strong MACs
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sshd_use_strong_macs,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Use Only Strong MACs
  hosts: all
  become: true
  vars:
    sshd_strong_macs: -hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-sha1-96,umac-64@openssh.com,hmac-md5-etm@openssh.com,hmac-md5-96-etm@openssh.com,hmac-ripemd160-etm@openssh.com,hmac-sha1-96-etm@openssh.com,umac-64-etm@openssh.com
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      OVBVVkF2VWtnNU1tbEZTVFV5VWtwaVpYZGFWVzVsWm1GMlJtRUtjV2hOVEZobU9FRkNWSGx0YzJo
      V1IxRXJlRzFsU0ZJMFltbDNZV05CUVdabVpDczVVWFJVZUVoRVpqTkRjRlZSWnpCcmVpdDRaMDV2
      V1hkYUx6TXhTd3BGVWtwbGJsYzJWMGhOVEVWd1JVOTZhMUp4TkZKTlVYaHBNMmR5WjNWNFFVczBM
      MkpUWmxOS0szZEVNMGRoTHk4dmJWQkpaRmRZUTFrMk1EbENXbXhCQ2s4MU5EQnVaSGR6TTI0MGFI
      SnliemRtVWxOdUt6aG1jR1ZDT1dsMVN6TnZZMGxCU2tGWWRVbFdRbXRwUTJRNVpqVlJaWEJCVjBw
      SVluSnJhakZUY0hjS1NGRlhja2RHUmxGclpqVXpkSFJLUjNkbE1uRnJiMWxHWkVZdk1XNXhWbmRU
      Y3pKR2F6VlFTSFZDZEhGRkwzUmxWVzh2ZUVOelZtZEROV1pLUzNkYVZRcDVNRVJCYWtsRk5IaG1T
      WGgwU0hkbFExQnVlWGRDTWxkRFFtMTVSWEZ6WjNKWVVWUnJNMVZ1UW0xemRITlNiVVpUSzJ3NU5t
      NXJOM2xCVW5Cc01YbERDbEp5ZDNsTloxUkRlR0ZMVW1KWGRYRmpNV3g1TlV4d1JFZDBhbWhuU1Rs
      eFFrY3dWak5wVm5OV1FrMW1OVmcyTVRKek9GbERRa2hTTmtsMWFHNXNia1FLWnpRNVoxYzNObVJE
      ZFRKM1UwSjZlRGsyUW5OTFRtOVBXalpvYVVjM1lqQkViRUZFWlVGR1ZFUm1TMDAxTWtJek1XTkxa
      emM1UW10SGIxTmxTRGdyU0FwQ2MzSlFWMEpQYW1OYU5qaHRWVU5UVnpGS1ZteExWa0o0YVVGMk5E
      ZHZVbTFqUjJvd1YxcHBjMjFhVVd0a1V6QlVhbEFyU1hKMVdtUnZaMmx1WVVkMUNtcEZNa2syYm5W
      V05UVnZURXRJVDJoNWRHY3phMVU1SzBaWlZqTTFWemxaYlRsSEsycG5hMHBNVFc0M05IZ3lZMm96
      YzJ0TE1HeGtZM1ZsTjA1VmVtZ0tMelJxUW1oMGIzTjRVSGRQVFVWdlpYUkdjRXA2VkRNelVXaGtP
      R1ZLTlRWbFEwMXBaRFpZZWl0SVEwRXpUV3hzTTJSWk5IRm9WVGhIUzNwMmR5dEJid28wVlV3d2JX
      OVBaRk5EUjNWaWIyUnhhV1ZNYUFvOVoyUk1OZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86769-7
    - NIST-800-53-AC-17 (2)
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_use_strong_macs
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Use Only Strong MACs
      block:

        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*MACs\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*MACs\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1

        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)(?i)^\s*MACs\s+
            line: MACs {{ sshd_strong_macs }}
            state: present
            insertbefore: BOF
            validate: /usr/sbin/sshd -t -f %s
      when: '"kernel" in ansible_facts.packages'


# Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo use_pty
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sudo_add_use_pty,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo use_pty
  hosts: all
  become: true
  tags:
    - CCE-83538-9
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sudo_add_use_pty
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG1RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      ZHJiMUF2TUU5WldXVkhObTlHVGxWSk1uVkJhSEJUYTJWdmVVRUtNMnBYTVdOV2F6WmtOV04xVTNs
      MVkxbHNXVGxtWkdWV2MxUllRVkV6YkdkcmRuWm1LMnBLYUVkbVpURmpSVk5GVkVScWREVXljMmRM
      VmpseVJVZFliZ3BCVjNGc1N5c3dlVmhLVTJGNE16bDBPREkyUWtwSFZrcHlTREJDWWpGMlZUWlNL
      MGxDU1dNM2RVUnlhVmhIV2poNmNsTnBjWGd6ZWxCM1N6UndNR0pRQ2s1cVRtNVRXRTluYm00NUsy
      RlRRMVF3YTJnNWVXTTJhSEI0U2pKTE5qbHBRa3RZYlZOSE9VWk1ja3RLY3pWaU9GcGlUWFp0ZG5K
      VlVtTjRZVmMzZG1VS1ZERlhjMFpRZFZWTmIwZHFkekZyTlZGd2NVczJjblpSWjIxdVVIcFRhVEZN
      VjBRMVlYSnJaVXRPZFZkWlZTOVpaMGRITkZkdFYwbEJlRTh4VlhwYU1RcERWM3AyT0hWblR6ZE9L
      M2N4ZGtveFUwMVdUMll3VlZjNU1sTjFTU3RTYUd0Mk1FVTNUakIxTWpCRFNUSlJNMmQyY1U0cloz
      UmhSVWx1YTNsVFRHbHJDamRFY0ZkeU9UTjROalpwTldaTmJucHZOVzlzV0doVk4xVk5VaTlZUkVK
      SlNHVmxSalp6VTNOelkwWk1lbkJ1UjJkdFJsTTRZVUpPWjJZNU0yeG9jMUlLTjBwUksyTlZXRFZH
      ZVc1WmJHUklRWFZTYVZkUE1HeFhNMEY2T0RsbFoxaG1SRk5qVERWV05WVTVVblZLZW5JMlJVNUZO
      RmxKYldoUVptUnVRbU53VmdwT01YWnhVemR2TTBKWlJEUlVOR2RZT1dKQ2IwcERSakpXWVUxWFRr
      bHpRVzV2U1VzeUszcHhlSGt6VkRWVk5rSTFUVUZ5VTBoT1ZrOXBVbVJKT1hoRUNsWmhaRlpwZG1s
      S1NETlZOM1prV0RCWVZVc3dWVWRIUlRGSmVWcHlXa0pTUWk5bE56RkRXbXhyV0VGbFIzTnZaVEY2
      WlVZelVEUnJWREpYVmpBMFIzUUtZM280ZDFSTFoxRXJaMnhqVGtGUmExRTBNRnBpWm5Sb2EwTldT
      emh3VWs5S1EyVldNek5NUTJNeFMxQk1TVU0wZFZCcWRYZElkR1pGUWxoNk1HY3ZiZ28yTWxnNE5W
      QjZXbmN4UVhCdlFWbHFlblpUZHdvOWEzSk9lUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure use_pty is enabled in /etc/sudoers
      lineinfile:
        path: /etc/sudoers
        regexp: ^[\s]*Defaults.*\buse_pty\b.*$
        line: Defaults use_pty
        validate: /usr/sbin/visudo -cf %s
      when: '"sudo" in ansible_facts.packages'


# Ensure Sudo Logfile Exists - sudo logfile
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sudo_custom_logfile,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure Sudo Logfile Exists - sudo logfile
  hosts: all
  become: true
  vars:
    var_sudo_logfile: /var/log/sudo.log
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      Um5TVkZCU1ZNclJsWmlUbGM1Y2pKb2NVTnFOWHA2ZWxkcFZGTUtOakZuYmtKU1RVWldVbVkyVGtW
      WVl6bEdka2MzTUhGbFpYbHpVbGxLZEV0UlEyWTVRblFyWmtoQk1GbE1helEzVGxGcFVIRndibTU2
      V1U5RVRWWm1hd3BqWldZNE9VcHlTMGxZYTFOelJWRnpMMFl5VXpoQ1UwbFpSbTV2U0hOcVIwOVNS
      VGhRU0ROc2FqTnJjWHBvTUZwclQxVlVUMU5JWjJ4SEszaDFjSEZ6Q2xOR1oyMXNabFYzWW5aS05F
      MHdaRTVMVTJkdlIzVTFaSEJ1U2xWV05rb3lRbEpYSzNCblpYRjBjM0ZTVkRZNFNYUk1UWEpUVjBj
      MmFtNHdkMFJSUkRRS2RHa3JkRGhvYWtkUU5VSkNNVVZGV0c1VlRTOXJNR1ZJT1dreWVUaDNSVkpo
      U1ZaaFdUZEplR3hqZEdSWlJsZEJlSFZ4THpjMlRIVjFUbk5JYmpGMmN3cFJSWFJKVmxkNFpHbFRZ
      bE5DV2sxTmFHSXdWR1ZOZW1sdmJHOU5iQzlFVUU1bFJVazJhSFkzYmtwU1duWTVkMnhuY1dwelJE
      Uk5jRWhhVDNwa2RWcFlDbkJGTW1KRWVXUTJNVFJXZEZJeUwzWlRZMnhsUm5WeFdrMUxWbXMxYlho
      ek5IcHBWbE0yVVd4dEwwUkJRbTFWTVhKRWRXWnFUbFJTUWtaUWRuaEpjVFVLTTI5YWRGUXlRVTF4
      VkhOVVp6Tllka1ZwT0hKalNHVkphR0p0UlZaNllqUkpWa3cxYjBOU2VUZHdhR0Y2WVhkMWNHa3lk
      azlFZUU1VWFHeHFRMFYzVEFwa1MwVlJTbWh2ZFVaa1NYRlNiWGQyU3l0c1owOWFlSGxLVTJ4S01r
      OVRiRGhLZGl0cmVsRlVaV3g2VUN0YVdtSjJlVFIwVVhkMmRHMUpNRVpCVTBnd0NsZzNkV0phUTI1
      U1YyVmFOVVV6YlRaaWVGSkpPRVZZZVhvd1VXcHNjV1pTWlVjdlF6QkdMMU51U0VWbGFVaElURFpq
      TTNodVkzUkRjbEl3YjJKT1lrOEtaM2gzY0cxTVdIWnBha2RuTmxoTmFGVmlXakJGYlhsNlMxazFN
      RFJpYWxOV2JXZDFUV1V6YkUxUFVXMDJiekJSVmxscVQwWXJSVFpLU0hWM04zbHZZUXBGTmxORGNq
      TmlkVXRYT1ZGd1NqRnVZMWRRTHdvOU5tbDRTUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-83527-2
    - PCI-DSS-Req-10.2.5
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - low_severity
    - no_reboot_needed
    - restrict_strategy
    - sudo_custom_logfile
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure logfile is enabled with the appropriate value in /etc/sudoers
      lineinfile:
        path: /etc/sudoers
        regexp: ^[\s]*Defaults\s(.*)\blogfile=[-]?.+\b(.*)$
        line: Defaults \1logfile={{ var_sudo_logfile }}\2
        validate: /usr/sbin/visudo -cf %s
        backrefs: true
      register: edit_sudoers_logfile_option
      when: '"sudo" in ansible_facts.packages'

    - name: Enable logfile option with appropriate value in /etc/sudoers
      lineinfile:
        path: /etc/sudoers
        line: Defaults logfile={{ var_sudo_logfile }}
        validate: /usr/sbin/visudo -cf %s
      when:
        - '"sudo" in ansible_facts.packages'
        - edit_sudoers_logfile_option is defined and not edit_sudoers_logfile_option.changed


# Ensure Users Re-Authenticate for Privilege Escalation - sudo
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sudo_require_authentication,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure Users Re-Authenticate for Privilege Escalation - sudo
  hosts: all
  become: true
  tags:
    - CCE-83543-9
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-11
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sudo_require_authentication
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      NVdSVkF2UVRoYVNEWkdVakpsZEROVFZtZHdUMFZ2YzJ4U2JISUtTekZqSzNoU1MyNDJOMUJFYTBO
      TEwzVXJRWE5zYjJOVGNsWjVNbWxsY0RsQ2NYVldaek5IVEdGbVRDOW1ja1J6Vm1SNk1FeHdUa2xG
      UzFwdk0yZFVlZ3BNYzFOdlVGaG5XVU5RZFRWeFVuWktNRWROYXpjd016WjJZVVV6ZVZoVmVqUTFW
      MDh2VERWTVVreHlXWE4xYWtOSmVFcDBhRkJOUkZONVkybzRRVklyQ2lzNVJtSnRiems1VUdveU0w
      cExjblZ1VEd0TVl6ZEhVbW95TTB4dllXWkJNVlphVkVoTU5ITXpkazVwY0RkdFNUZHJlbk53YVRk
      SU56Wk5hbXBrU3prS1JsWXJWa1YzTjJwak1ucHNNV2h6VDJwc09WTmpUMmN6VnpaSVlVaFZTV1Jt
      TDA5RlN6WnZlRmhSZHpZellqaHlWMnRGYjA5SFYzcFVlRmsyWVRCc0x3bzFjbHAwUTB4YVRYbHZZ
      azluY1RkRWVUbFVZemhSYlVoNmRqRmlWR0ZxYlRKTFlUWlpORFZHWlhOamJGTkJUV1ZOYzNGTVdr
      NXlhakp2SzFCek1WSnJDbFZSUkdsd05qWmxaM1FyV0ZOQlFYWXpSMFp4VkVWUk0zVnBMelZoTTNa
      WFZUTTNSWGROY1ZkNk5qVldjV1ZZTkVGWFZYSlFSeXRtV25aSE0xRXJjMmNLUzBJeWMwZHJObk5W
      Y1RSeFpEYzVWblJpVVV0amJUbFJOV293VmsxdmJrWjVSVWhvVkZWSVdTODBRamRRTVRoTWJrNUla
      VzFGWjI1bllqQlJSbFYxTkFwT2VscHljVlppYWtGWk5razJVblpaYVZoc05IRm5jekkzV2sweVFW
      aFJXRnBUYlVJelYzZHRUR1k1TkhCRlQyVk1SakoyV2xGSGEwMTJiRGcwT0RSTkNqTktabEJRS3pk
      dmEzSkdVM1pXTDBoNlZ6STNOU3RNY2pKdVNXSjJOR3BWUmtSRVVqaGFUMEpsVkROaVdXUTJTMEZx
      VDBFNGVERnBTVkpVU0dJd2VWWUtPV3A1WTBOVlNrOW5kR3d3YW5kNVVVVmxZbXN6YzAxVGNESTVN
      MmhYVm1GTFUyVk9kV1YwTURObE5rTnFkVmRMVUhNeE0xRjVORk14VGxKVFluZDZlQXBPWjJ0VVRq
      bGpiRFYwUzBWeWVDdE1VMkpMT1FvOVREVjRWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Find /etc/sudoers.d/ files
      ansible.builtin.find:
        paths:
          - /etc/sudoers.d/
      register: sudoers

    - name: Remove lines containing NOPASSWD from sudoers files
      ansible.builtin.replace:
        regexp: (^(?!#).*[\s]+NOPASSWD[\s]*\:.*$)
        replace: '# \g<1>'
        path: '{{ item.path }}'
        validate: /usr/sbin/visudo -cf %s
      with_items:
        - path: /etc/sudoers
        - '{{ sudoers.files }}'

    - name: Find /etc/sudoers.d/ files
      ansible.builtin.find:
        paths:
          - /etc/sudoers.d/
      register: sudoers

    - name: Remove lines containing !authenticate from sudoers files
      ansible.builtin.replace:
        regexp: (^(?!#).*[\s]+\!authenticate.*$)
        replace: '# \g<1>'
        path: '{{ item.path }}'
        validate: /usr/sbin/visudo -cf %s
      with_items:
        - path: /etc/sudoers
        - '{{ sudoers.files }}'


# Require Re-Authentication When Using the sudo Command
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sudo_require_reauthentication,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Require Re-Authentication When Using the sudo Command
  hosts: all
  become: true
  vars:
    var_sudo_timestamp_timeout: '5'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG5RVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      Vm9jMUZCU2toM1pTdEVUMDlCTTJ0MmVIVTNiaTlWTnpKbVNGWUtia1ZhYUVKNFIxRkpVekF6YlRC
      WlF6UlhUMUIzUlRBeFpFeGlNbXBKZG1RMWVVSmhSV28wV2pkUU1sTTJlWGsyVlhSRVNERnhjSEZK
      ZGtKV2VXeDRSd3BNYjJkaFRFNUdZMHBxVkdKaFZXZHdibWc1VlZGUVpFYzNTRU01VUdwU1pIVjFh
      M1EzWWtKTE5IbFhhRXhwYWtGNFJTOHhRbTl0VDFkdmJsYzROM05HQ2t4ek9FSmxVVFYyVW1aS1lU
      RnhaMkZSZDNOdVVVZFlibVZKTlV0Vk1XUlZZVTVpUnpkRlYyUnpORWw2Tmxjck1YbG1PRk12WjJw
      a05XaG1hSFZHVEhZS01tTmFSR1ZEWmsxNlRrdDBkRGRLZFdKUWRFaHBla2swTkRoS05URjRWMEpz
      SzB4SE1XeExlVmsxYzJ0TWREaHVZbXRWTTIxeU5XWjVOVVZTWkVWdFdRcFhZVVYxYUhOR2JHSkhX
      SE00SzBsM1J5OTFSekZsYmxaNU56aGxXRm8zWmk5elNGSkxWVzE2WTJ4bVFuQk9URFZRTVRsRmNr
      OUxLMWQ2VDBKU1YzRndDbEZTTTNCdWMzUXpSRTl5YldKQlNrUm5jMDlOUWxrM1UwMDRNME13ZVVz
      eU5XRk9NR0pQUVM5Tk1sUjZTbTU1YnpnME1EQlJXV3BCYTFaeGVFVnNia1VLU21acldXMVFNM1Uw
      VTAxeFFtMXZSRVphYTB4bVZGbG9ZbGwxZVhFeFVXOU1Na2RPYlN0YVEyaEtkek01UlhGbFkwRXZW
      V0ZDY21SWVZUVlZNRlk0ZEFwVmQyY3piM2gyUkRGbk0zaFlXVmRpZEZwVWVWVTVUbmt4TjJNcldU
      RkpUbWRMUm1VellrVnJSR2RJYUVJMWEyWkhXalJzWVhveldHODVTRkp0UlRoekNsWnZLMEpGY0ha
      a2VGUjNTVWxhUzNJM1J6bE9PRVJyUkd4VlJXNUJablpxV0daS1RHbExaMVppUkVwV1VUQjNlakoz
      TkRacFVVeDBXRTV4T1VaQk4zQUtSbkZrZFhWSEswazFlalZHVG1ZeVFVUkVTM052WkhaM2RVSjJS
      aXRHZDBSS2FGQkpVMUIwVVhRdlVtSnpWR0Y0YVM5dmVuRm9kR0ZIUTNaT1oxWjRid3BVYjB0UFRs
      aElLMVF5YTJodVMxRm1iblJvYWdvOVV6Tnpad290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-90029-0
    - DISA-STIG-RHEL-09-432015
    - NIST-800-53-IA-11
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sudo_require_reauthentication
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Require Re-Authentication When Using the sudo Command - Find /etc/sudoers.d/* files containing 'Defaults timestamp_timeout'
      ansible.builtin.find:
        path: /etc/sudoers.d
        patterns: '*'
        contains: ^[\s]*Defaults\s.*\btimestamp_timeout[\s]*=.*
      register: sudoers_d_defaults_timestamp_timeout
      when: '"sudo" in ansible_facts.packages'

    - name: Require Re-Authentication When Using the sudo Command - Remove 'Defaults timestamp_timeout' from /etc/sudoers.d/* files
      ansible.builtin.lineinfile:
        path: '{{ item.path }}'
        regexp: ^[\s]*Defaults\s.*\btimestamp_timeout[\s]*=.*
        state: absent
      with_items: '{{ sudoers_d_defaults_timestamp_timeout.files }}'
      when: '"sudo" in ansible_facts.packages'

    - name: Require Re-Authentication When Using the sudo Command - Ensure timestamp_timeout has the appropriate value in /etc/sudoers
      ansible.builtin.lineinfile:
        path: /etc/sudoers
        regexp: ^[\s]*Defaults\s(.*)\btimestamp_timeout[\s]*=[\s]*[-]?\w+\b(.*)$
        line: Defaults \1timestamp_timeout={{ var_sudo_timestamp_timeout }}\2
        validate: /usr/sbin/visudo -cf %s
        backrefs: true
      register: edit_sudoers_timestamp_timeout_option
      when: '"sudo" in ansible_facts.packages'

    - name: Require Re-Authentication When Using the sudo Command - Enable timestamp_timeout option with correct value in /etc/sudoers
      ansible.builtin.lineinfile:
        path: /etc/sudoers
        line: Defaults timestamp_timeout={{ var_sudo_timestamp_timeout }}
        validate: /usr/sbin/visudo -cf %s
      when:
        - '"sudo" in ansible_facts.packages'
        - |
          edit_sudoers_timestamp_timeout_option is defined and not edit_sudoers_timestamp_timeout_option.changed

    - name: Require Re-Authentication When Using the sudo Command - Remove timestamp_timeout wrong values in /etc/sudoers
      ansible.builtin.lineinfile:
        path: /etc/sudoers
        regexp: ^[\s]*Defaults\s.*\btimestamp_timeout[\s]*=[\s]*(?!{{ var_sudo_timestamp_timeout }}\b)[-]?\w+\b.*$
        state: absent
        validate: /usr/sbin/visudo -cf %s
      when: '"sudo" in ansible_facts.packages'


# Enable Randomized Layout of Virtual Address Space
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Randomized Layout of Virtual Address Space
  hosts: all
  become: true
  tags:
    - CCE-83971-2
    - DISA-STIG-RHEL-09-213070
    - NIST-800-171-3.1.7
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-30
    - NIST-800-53-SC-30(2)
    - PCI-DSS-Req-2.2.1
    - PCI-DSSv4-3.3
    - PCI-DSSv4-3.3.1
    - PCI-DSSv4-3.3.1.1
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_kernel_randomize_va_space
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      TnRORkZCU1hvd2NVVmxTVzF6TlVNM1F6ZDJUbk15UVU1NFFYUUtiVmxTYjNSSEwwMURVbE42YzBS
      dlNVUjJXSGxqTVhrNE9UbDZaakpNYmt4SFdXNU9kM3BUWlZWVlEyZENOMUZ5WVhCWGFIRTNSbkZw
      WWxCV09USlVTZ28yT1djMVEzWTBlbEZPY2tGVk5sSnBRamhITlhWM1JrRlBjMDl0YUVKT04weEpL
      MnN3VWtaU2JqQmFRMjVNV2todmVUQlRSV2x6VlUxSVRVcFpRbGx2Q21jM1JqbGxRazE1Ym5CdlRu
      bHZRMWh6YUU1MFowaE1ZbUpPWVRkbWNXWldiMkp2YjFCM05YVXZNbEZHZUdwbFpVSnRNalJhWTBn
      MVZsYzNLM2w0UW5VS1NESnpLM2d4YjJaTE9ERXZVWGxRWTNCTWFFcHBkbk5QUTB0eGVuTldiVzV6
      YUhaVGVYRm1jMVZRT1ZwdVZraFNNMnBUTm13MVZtMTNObGh2YW1aNVlRcHpMMEZwWm14c1RWaHVj
      blZHUWpGQlN5dE9NWFJzY3pSVk5WWk1hbVJTVlM5UGRTdFpRMEpCZW5oMlRGTlpOMDVRZUhSdFkx
      aFNNR0ZJU1RWTVRVODFDa1ZxY2s1Mk9UTkhOVXRPV0ZoMkswbHNjbTVwTDJ0S1NXRlBaRU50Um5o
      RWJqWmpLMDF6V0ZSTGNHazRXR1ZrZG1GMmQzSk9RMUZFUmpKSmNERllibklLZGtsT2FXWnFOMjFw
      V1ZVMFZFWnhSMFZDZGtwa2RTOU9Oa3hHTnpSalIzcHBhVWxZTTJ4aU1HcEdhRkZwTm5oUE9VbGxU
      ak5rYzJaWGNtWTVXR2hLWVFwT1kydDVjblJpTUVwVlJsa3hNbmQyUmxKaWMxaHVhbGxNVm5KM2F5
      dHdkbFUyVUZwV2JtTXpWMkl4UjA5U2IxVkxkbWRRUlcxWlJsazBURkJxUVZrekNsTnpNMnRWUjBs
      UmJuUlpibE16VFZvNWRUQTRSbkpuVDI1M2VFTnpLMmd5VDFCMkwwRXJNa1YwYnlzM1VVTjRNV2hP
      VVdSNU4xcEZPVlJGYXpablZFb0tOMmxuT1dwUGFXcERXR1ExVG5kS1lUZzBla1YxTWt4TVZXTlBh
      VGhrTkdKVEwzbHNaRzQyT0hoblUydE5SazUxVTNsTWIycFJZbXR1ZW5sNlNra3pNZ3BwUjFaMlJX
      UkpUalJUUzNaVGVtVlVORXN2ZVFvOWNGcDJhZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*kernel.randomize_va_space.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of kernel.randomize_va_space from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*kernel.randomize_va_space
        replace: '#kernel.randomize_va_space'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl kernel.randomize_va_space is set to 2
      sysctl:
        name: kernel.randomize_va_space
        value: '2'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'


# Restrict usage of ptrace to descendant processes
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_kernel_yama_ptrace_scope,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Restrict usage of ptrace to descendant processes
  hosts: all
  become: true
  tags:
    - CCE-83965-4
    - DISA-STIG-RHEL-09-213080
    - NIST-800-53-SC-7(10)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_kernel_yama_ptrace_scope
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MXFRVkZCU1ZWeWNsZHVlblJqVFdneFRuZzRTMWxRU1M5b1ZWSUtkMmRHWVRGVE1VRkNVVXBIY0dk
      WVpVYzJhVmRpV1U1WU5rdGFPRkU0TkhSUVRrWTFSM0ZrVkRoRlZWZFpSRmRJUm5Ob1IzQTNaMVZD
      UjIxNmMzSlpNQXBxVGxOSWJXZE9VVXhTZEZCQk4xZHpVWEZHZDB0NWMwOTJhRloyWmtJNVlYZGhT
      RzR5ZVhwYVduRmhXR3RPV1ZGcVoxZGxaRTF3VG1wTlZUTldabVIxQ2poT2RHZHpiR1pzZVUxU2F5
      OWlRMGMxY1RoSmFrbGtRakJJWmpsaU1tcDVia2d3VkRWeVlWSlpPVWg1Tld4T2R6RnFTRU5IVUdn
      d1ZrRjFNMGt2YXpFS1MzZzRTMDlLV0ZaSmNtWnZVWHBGVEdjM2F6bE1SMjl3UXpaRldtVkhSbXg1
      Wm1jMFNFOWtabTQ1V0U5emVqUnBSRzUwTW1GeFNFcHRPRFpwUldoV2JRcDZNVVYwUlZRclVERmhV
      SFIzWkU1U1FsRXJhVFZMYldocE9IazVNbHB3TkdSUE5DdEdUR05RVFdaNVQxbHpSMEpUTWxaSlEz
      bDFSSGxaVjJKVGNXMHZDbFF2ZGpKamRrWk9aeTlsY1hOd1FXZEVPV2d6YzAxMmFVaG9NMnhZZW5o
      VWRVUnBPWFozVnpVNU1uUjBXVkJwVGpSRmRGUkdjSEZoY1ZWMFFpdExWRGNLTlZsdVVXaGpjakpq
      WXpKUFVEVnRhakZWYzBoSFRGUkxjazVrUkhKVFVuVjNkR1Y2VTBGMGVGaFZWbFprU0RKS1ltUnZU
      RFpsUTNWS1dFRjVXSGg0YUFwR1NFaHlkM0pFWTFwNVJHUXJVWEYxTm5jdk5GWkpSbGxRYjFoUk5V
      UllPVGRwZVVwMlpYWlZZMUZvSzJ0dlJUVXhORVpJVTNKbmNXVlJNM0ZHVW05bUNqVjFkblpWUkZo
      UEwwWkpZMHhzWTJaR1VtMVBWbXBQTVhSbVpVRjBNSE5hV25Wc2FrOVlla3gwZHpST1QzRnJibVJV
      YzNsdmRYQmlSVUp3Y0VoUmRuSUtWSEZHYTNGM1JXZE5LMHMxVFVsck4yTlhUa0ZoZG5WdVNtZ3hR
      bWxDU0VadFdGTnNkMkpZS3pKdWFGSnhWREpGU0dkSmRuTnFMM1YxVUd3ekswVmFRZ3BFVERKdE5X
      WXdaRnBoZDJkU1QxcFFWa2N3YndvOWIyeFhUUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*kernel.yama.ptrace_scope.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of kernel.yama.ptrace_scope from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*kernel.yama.ptrace_scope
        replace: '#kernel.yama.ptrace_scope'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl kernel.yama.ptrace_scope is set to 1
      sysctl:
        name: kernel.yama.ptrace_scope
        value: '1'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'


# Disable Accepting ICMP Redirects for All IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Accepting ICMP Redirects for All IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_all_accept_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZG9RVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      ZDVRVkF2TURWalExSkplVEZNTVZGTk9VOVlRV05qYmtsc1lXa0tibnBSVERSc1JqRTBSRk5RZGxO
      VEx6YzBaRGR5ZG5CYU56RlhNQ3QzWnpkclRVWjNjbTFLWmxSSWVpc3pXRWgyT1hKMVpqbFBNelpS
      VkRWaGN6SmhkQXBRVUZNd1ZVbENlV3huYzJwMWNXcFZWMlpGUkUxb0swbHBNRlJtU1VwamNWSkhW
      VVp4YlZFNFNFSklVRWxyUkRJM1dIWnVXRzlVVWtsdWJVbEZOR1psQ2tWVmNsRnNabGhTSzBGaGJF
      MUZORVlyVkhNMVRYQklSMnhZYW5Sa1kyWlNibkk0YkVKNmMzazJWV1pyY2tsdlUwUkVLMEl6YVRs
      elYxWnRPSGxXYmtRS2JETjJUbWhQUkdsdVFucFlaWFF3VlZsS1Z6SXdObTR2ZWxoSGN5OTNiSGRO
      TkdWTk9HSTRiMHQ2YVdsUVlpczBjRVZCYVRaeVR6WXpOa0l2UlZWSFZ3bzBZVUkyZGpsbFNsSkZO
      MmhKTkhsalYwaGpiRE5TVG5aalVsTmtaWFZvWkZWSGQxbE1kR1pITTNkT2IxVjBLMVJvTWtGeGNH
      VXZiR1ozU1ZsTlVHTjBDbXBLYkhCeVRqRXhiRnBDY2tJd1pscFRabU56ZVRkcVJHWXJTR1ZYSzI5
      U2VGUTBZMnB1TkRkUGNtTnhLMjVJVkRRek1VUnhabWRoVld4eFIwMUxhbklLTTJ0Sk5rRmxOWEJG
      YzJaTVpGQTJUREprVDJKVWVXTlpZV3g1YW0xYVVHbzBaR3Q0ZEd4U1MwSk5TV28yTW00eE5HOWti
      WFkwWTJGTGIyVTJObTV5ZEFwRlptNVdPRXhDTlhOT1VIUlhPVWxVY2paS01HcDBkMFEzVDJWNFRq
      aG1jR05YUkdWbmJtSmlWRmhxYjA5aFRHOXhVblpNWVZoSWRGZFFkamRTWlZnMENuTXpXakVyTlRW
      eGNGSnFkV1V6VVVKalJVTkpkRTFHY1dkUk5XcHNOMmQ2YkU1RWVVZDJURE5hWTNsVFRuRk1WRTlz
      UldzNGRFMXJaU3RyVlRreGRrRUtPREJNZWl0d09EaFpiR0ZtUVZsNFMzRTROV3hvYTFSNWRVdHRa
      V3RYYkRsbVkwa3JkQ3RCYm1sc1lrWlFXbEpZU1hoQk5tZEVUSFZ5VUZKUU4ySnpkZ3BHVW13eU5u
      UlFVVVV2Y0Vkb1ZIY3lVMnRhWndvOUsycG5WQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84011-6
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253015
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-7(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_all_accept_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.accept_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.accept_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.accept_redirects
        replace: '#net.ipv4.conf.all.accept_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.accept_redirects is set
      sysctl:
        name: net.ipv4.conf.all.accept_redirects
        value: '{{ sysctl_net_ipv4_conf_all_accept_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_source_route,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_all_accept_source_route_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      RkVUVkF2YVRSRlFpdEtjR3g0UzBOd1NWSnhXazFaU0VaclkwUUtNbWxCU2psTFpWVlBhVVIzUmtK
      NFlua3ZOak14TlVoWVRUVjRNVzFUZW5CRU9IQk9XVEIyY0ZkNlpEWm5lR1ZIVTFGTWVsa3JjbTVR
      VEdwTVMzbDBUd3B4UkZKUFIwZ3ZUWGwzTUdWeVJGSktUMGhWTW1SSVNrSkRXVFZGWWpWNWEwcEdW
      a05IVFV3eWVVbExNR1Z5YWs5dFdISlViblozUjBsdFJYcERkakUyQ2poRkszVndaek55THk5blJX
      RkpXVmRwUjB4dldYazNSVXROTlRRM1ZDdFVXVmxLVFRoVVNTdHdXR2MyVldOb2FFRlVRVkEwWW1S
      bE4wbG9TRlJ4UmxFS1RuVklZblZtTDFjeFVVSndWRnBoZEVaSldscFRTRzFTTldnMWExRnFiMlJD
      VjFGcGFWcEJia1pwVkVwaWNreFpVR3hUU0hKc1VXMVlNemNyUjB4dWFBcE5aV0ZaYTFkVmF6bGxO
      bVJVWWxGSFlrUjZkakp6YTIxV0szQjJSMjU1WlU5UFFscExZWGRuZEZkUU1tUm9jbkF2U0NzMFVr
      SnBUakZIV1VwbFVqQjNDbGxwZDA0NVJsQkNTRTh3V1U5R1lVMDNNMkUyY1c1WFdFMVNOV0ZoYkZr
      NWJEZzJlWGRPZEhaM0swSjFlVUZFV1c1c01GVjNkV3Q0U21FNE1IUkRUR1VLT0ZWSGMzbDRPVmMx
      VWpBeFlrZG1hRVp6VVRobVdFYzRNMnQ2YUdORlFrRnJNV1UwT1ZRemJHaFJUMXB3UlZsUWJGZGFa
      alZUYUhKRE1YaEpNamxWUWdvelJqa3dWWHBXV1hGUVREaE9TbE5VY1ZwTWVqZEhXbU5PUkdod00y
      WkZhbmREU2prclFtVlRTVVJtU2s5RWVVcGhUWGt3Ykc5T1JFSTBlVEV5UlVoc0NpOWlOemxwUkU5
      RGRrSjJiVlUwZUc5VFZVbERRbU4wVFU4cmExTTFZMWhsZDNrcmJHY3JVWFpoVGtwREwwTnZkbkp1
      TkVwUlkybFpUM1ZSUlV3M0wySUtZVlV6TUZSVVoydEZTVlZEUlRSelRXZEZhR1YyYm01VlZIRnBT
      bkI1UlZwd1draFhXVmxQWW14TlUzSkRTRFZNWmtkaGNFSkVlSGhETW5sYVluSnFVQW8zV1RZNU5W
      UXhhM1ZTZW1ocVpuUkpSV0ZIYVFvOVExbzNMd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84001-7
    - DISA-STIG-RHEL-09-253020
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - NIST-800-53-SC-7(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_all_accept_source_route
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.accept_source_route.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.accept_source_route from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.accept_source_route
        replace: '#net.ipv4.conf.all.accept_source_route'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.accept_source_route is set
      sysctl:
        name: net.ipv4.conf.all.accept_source_route
        value: '{{ sysctl_net_ipv4_conf_all_accept_source_route_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_log_martians,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_all_log_martians_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      Rm5VVkF2TVVsYVdETlpOM1poUldJNVNsZHNaemwzY0hGNWVuUUtjVzQ0SzNKNWVWSkNjM1JCVG5F
      MVoyY3dSMmxWY1ZaUGRHWkhRamt3TkZWd1pVRmxRakZCTmxsaWJtZ3pjbTlJVjBsRWFUQklaRlpQ
      VDNwa2NWUlZiZ3BtTTJOcE5IVXlOVXRWZFdZdlVUbFFTbUY0TW5wMlNuRnRMMFZGUkd4bFdrUlVl
      blZZYUhwMWMzUkhiVzB3VWxWVlNFUXdVV1JJY0RsclQzQldZV0YyQ2xwRFJUa3liWEZoTlZsSU5r
      TjNaa2hGZWxSMWJUUnhkMkZITWpKdFNrOXJOSEZ6ZVdKNVR6VkdTa3RHWlhkMGJEVk1WRWxQT0ZF
      MGNubFpRbGgyY0dzS0t6QjNLekZ3Y1hWQ2FuazRSMGxNWm5Cd1NETldjV0ozZHpRNE5UWndTbUpP
      YVVRM01ITk1ibmgzYmxCT1JITkdUR1JYWjJFdkt6VnBOV3gyTlRrek5RcFJSRXRIWlV4a1RFc3pZ
      Vmg2TW1OeVYwdDVXV2hrYjBoR1Z6VnVWbUZZYkhkeGEycFBNak5vYjIxaGQybE1WM1ZDYW5wRUww
      OHdhelZTVTJwTU4yc3lDbTVUTlhKVEt6SklSakpxVGt0MGRreGxkM1JLWm1aalVsZG5SVFF5ZERk
      dlpEWkpUbkZRUkVaSlVsRkxZbUU0ZUdkdVp6QlNOR2Q0SzI1dFdHeE5aV01LV2pKU2JHSnVVRWRz
      VW5KS01sSkRZa2RSY3pnek9FRkdNM296YXpSR1FtRTRWMmcyTm1kRFNFZzJVV3R6WnpCQ2NIa3da
      RzVRZDFGcFVubzVWMk5oUmdwYVMwaDNjSFJ5VTNaa2ExSjBUa3hKUkdkeVlYTmpkVnBWYm0xdlR6
      TndTSGh0VGl0YVFtUjBkRTR2VlRaWU5IRk9UbGhSZFM5SGNrSnpVRGxaZHk5TENtZEpaa1kzY0Vn
      NVRreFZkV1p1VTBWNEt6Vm1aemRsWjFoblNtMXllWEpCYlZCeEsyMTJOaXRFV2pGa1NUWXJTMDR2
      UVdObWJFWnRSRlZLTkZaYWRtY0tWalJSUVdsNlVVazRORGRzVEZSUGJEWklUVEowVFVoUE1FWTVV
      REJ1VEZZMVRVbHRibGN4ZW1SRGJWRm9ZUzlWTlUxM1VTdHdXR2hvWmtkMGVURXljZ280TmxReGRq
      ZHBUSFZSUlVrNGFrcEhZVzFRUXdvOWRqSmlid290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84000-9
    - DISA-STIG-RHEL-09-253025
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5(3)(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - reboot_required
    - sysctl_net_ipv4_conf_all_log_martians
    - unknown_severity
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.log_martians.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.log_martians from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.log_martians
        replace: '#net.ipv4.conf.all.log_martians'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.log_martians is set
      sysctl:
        name: net.ipv4.conf.all.log_martians
        value: '{{ sysctl_net_ipv4_conf_all_log_martians_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_rp_filter,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_all_rp_filter_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHBRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      RmhUVkF2YVdSd2JESm5XRzFLV1dsWGFua3dSMnRwYlZCd1FXY0tMMDF6VEZCRk4yTlFSbTVwZGpo
      MFEwcGpkRnBCZUdGV1lVdFBVUzl1YWxweVRqTXpLemxYT1daak1teGlTakYyTW1ScFdteExhM1ZD
      TkRBMk1qTjJPQW8zWjNONlNIbENTVTVqVnpsRFozRXZSSGN6V2tKaVlTdERTVGRhVTNWaWRHMUll
      RkZyTmtOTlVVSm5MM1JGV1d4aFNtWnFVMUZtTVRoU01VY3JNVXcwQ210MVdIaDFVVE5QVmxCUVVU
      Rk9jM3BDZDNkeWRUZGFWbkJUV2t4M2FGcEhRVTQzT1hWQlRGTkZTRkJ5U1hkS05EbG1WMDAzYmt0
      bWJqZEZja3hpTlhjS1YwWjNTbkZET1hjeFJ6aFVaMnQwVG1aWVdqZDNlalJ2V21VclpsaHdhV1Yx
      T0RCWFkyWTFVREExVEM5dlJXWjFaVXcyWW1VdlIxZHpUbWhHYTBFMlN3cHpWWEpGVmxBMk5YaGhT
      ek5KVWsxSmJsazNjbVJhYUhsS05rTnRXVGxHYWxaTFFrVjZWelk0Vm1KUGFpOUtkR2xSV0hkTmMz
      SmlNRzVZWTJGWFRVaFRDazlNYW5Cb1YxUjZNSFV2Y0VkUGRqRnZXSGxXWWtnMGJsRmFRM0E1WkVS
      eVpVSnRObkJoWXk5NmVsa3pUVkY0VUZaNVFtWXpjR1Y0U0VGMmNVOVlhbkVLYVZSUlVsTkNia2Rx
      ZEd3clVEZ3dOVFZaTjJkVlJYazVPWGMyVlVaSlNWRmpVRlZxZDBwVFNVazVPRlkwV0hkUFFuRnBM
      MUpzTVRSTmJIb3JTbXBRY0FwWVZEWjFRbFJPWkRKTGVFNVpTa3RNYWk5T1JIaHljakV3VUZaaFZt
      OXdkVmRCUTJGSVdFeENVVmxGTmtzNVptZEVkVmdyWjNWRFZWbFBVRGg0Vmk4NENuRlBPRW92WVRK
      R2FYTnFWa3RPWVVKbGNFOUpOMFF5YWxGNVIwZzBhMDlrUkU1NlNURnNiVVprVWpjNVozTnJkVTF5
      T0dWalFucFBZVkF5V1RWTFZsRUtSVFpNTmxSQ2QzaDBOWFZIVld0dWNIcExOM1Z6VUZVell6YzFR
      V1JsU1RGbFpXcHhNV0pVVWxwek1tdDJjVUZyUjJJM2NWUjNPV2hvZUZGMVJDdG1Vd3BJT1hWMFZu
      b3hZamxIUXpCUllYazNkR3BsVEFvOU1HOXROZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84008-2
    - DISA-STIG-RHEL-09-253035
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-7(a)
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.3
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_all_rp_filter
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.rp_filter.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.rp_filter from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.rp_filter
        replace: '#net.ipv4.conf.all.rp_filter'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.rp_filter is set
      sysctl:
        name: net.ipv4.conf.all.rp_filter
        value: '{{ sysctl_net_ipv4_conf_all_rp_filter_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Accepting Secure ICMP Redirects on all IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_secure_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting Secure ICMP Redirects on all IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_all_secure_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      dHpVVkF2TTBKcFpXMVNObVJtVUhCTlNXdEpla1ZSTlRRMVUyd0tkMjFVWlZWSVdqVTBlRWhYTDJ4
      bVdYSnFibVpZVjB4M1EzWnBja1JzWjFkVGNVbDBVa2M1VGk4NVpYUlFUMjVJYjJGcFZsVk9XV1F3
      U1RselMybEJhZ3BhV0ZJemJXTXJiR1ZaS3pWMVpGcFZRa1l3WW1aRlZuZHRaVWRvYlVocVlreHhO
      RmhIWlVaa09FTmxZbG9yWkZaTlEwWk9ZVmR5TjNFM1pXdFlWRzluQ25NM1dEWTJaVlJKYUc1UlRI
      cGFWMGRPTlV0V2NESXpOWGRYUlcxWlVTOVJWVnBzYlN0NFJYWmhWazlRWVRocVNHcFJZemQxWjBs
      dmRTOWpTa055TUZnS2JVaFlZM0JWTnpFMGVYbDBWblpHVDNNelMyYzBlRlUwVFc4NE1UbGhkMDlo
      Um1oNVdXTlJSVlUyYjBacGFVRXlTMk4yVVcxVlNUTjNNM1pzTVhsbWVRcEpPVVI2YjBaSFNuSkhV
      VUZPUlZwNmMzTklaRmhYVWtWVUsxTkxjMHBCTmpNdlp5dHRTbFZwZVd0Q2F6TXJURzVWU1RBdmJW
      WlpabTlZY0RVd1RWTXpDbVYzVlRsT01XYzNjamhKVDJKMFpYWlZiR3RaVG0weVVESnJibFZOVW0w
      dlkyaE5SV1l2YWt0cmVuRjJUalZIWjFvcmIzUTVkVW94Um5GbmIyWnpkbVlLVmxsTk1uSnNiSE5C
      YVVzMlNscFRjbEJaVkhaMlVWWmlRakZJUW13MFkwdGlkR2x4ZFdOQ1pGWlhWVzVxV1dsTlptcEVX
      RmRwUmtaVlpWQndSMDlMVFFwMmEzbEJTRVZFVlVzcmExcFJSbWh3TDFOMWVYcEVaM1l5TmtkVldG
      VTJkRzFpZDNFM1NXMWhiVTE1VlV0eWNuSmFPRWhJVmxSdGFGbEhlbXRaVDBkekNrWkVWbmxQY0cx
      S2VIazVlRmR1YVRWNE5VVjJURGRrTlhWTlNsUnhXR2xqTTJOUEwzZE9PVkYzVWs5UFYyb3JWMmxT
      TW5Jd04yUTVPVU4ySzFGVWFIZ0tjV1pRU1c5d2NYRlhlbkJHWVRneFZDOTBRekpvTVZoNVEzUnVX
      R2w2V1hGVWFrUnFWbUU1SzBKRVRtaG1SV3B4YjJWTFIyMW9kRWxpV0dGRE9EZFJVQXBQVG5WNWQw
      Wm1WbGt3VDFOSGJ6SkNObVJrWndvOVdGZFlNd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84016-5
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-7(a)
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.3
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_all_secure_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.secure_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.secure_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.secure_redirects
        replace: '#net.ipv4.conf.all.secure_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.secure_redirects is set
      sysctl:
        name: net.ipv4.conf.all.secure_redirects
        value: '{{ sysctl_net_ipv4_conf_all_secure_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_send_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces
  hosts: all
  become: true
  tags:
    - CCE-83997-7
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253065
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - NIST-800-53-SC-7(a)
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.5
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_all_send_redirects
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WTVhMUF2YVdaWllsbE5iVVo2Ulc5dWF5OTJSa1JOUWxGMmEyb0tNMjQxVm5OV2VEVXhSWG8wTmpC
      cFlreEplbEo1YW5GbkszcERLemt6UTNKYVJtWjBXV1pWZFU5cWIzbFRhekV6UjJJM09ITjBNRlJy
      ZUU5V09IUmxTd3BRVmpST01qQnpaMUZyY1N0Mk5rSnhWVFpIUlVrMlltY3dOV2MzZFUxVFowMHlS
      RU5CYjAxaWMwRXlUbUZEVGpSU1RUbEdTekowYWxWWU9TdFFSMFJvQ2pZMFRXcEpUVTlWTUU5dU1W
      bEJUbGc1UVV0YWREQk5NekJJVG1Wd1R6UTRiMWN4YURKU1ZuUTFWMVZXVGxGMlN6ZEpWMng0UldW
      VWMxUjJRbmx5TDFrS2FHaHVaMVV2UkVrdkt6TjBOMnM0VTAxQlRtdEdXVkpoZWtsTlNXZzFSa3Rx
      VTFOMlExUldhV2hUWmtSS2REZEJjemsxY0dnemJVeE9XRVI2Wmxkc2NBcEJRM2xKUW1SaGQzQnNk
      V2hTU25OdU5UY3Zla2t4VXpBNFdtOVNWV2gzZUVwVVRtMVJTWFJOTW5walVsQnZUSEJzZUN0bmJE
      ZzNPSFJyWkZNd1IyTmtDbkZYUVhoWWFqbGpORFZFVDFGT2RFTjVOMHd6WTBJclNqZG9kalpWZDNC
      SFVYTndjSEJLVWpKaFQyNXJhak5GVVVjdlJtMHdUa1k1UVhReE1sZEtNRWNLZW05eU5uUXhVRTF0
      TWt0R00xZ3ZTWHBCY25VMGVEbERkMDVhWTJzNE9FVlBSVFpqUXpSaE4wWTVWbE4yUTFKRmMxbDFk
      MUZOVTBZNFprNVhORGw0ZEFwbFpWaG1ZWFpsT1RscWRIVktNVXBJT0hGS1R6SXhXRzV6UWtKR1JV
      NHlPVU4yYkhZMU9WQldXRkl5Y0RaMGRsaHhXakJKU2psQmVXaDFURk14VTNnM0NrNXlVbWcyU2xo
      cWRFNXZRbVpTVkVSU2IySlZSekYzWkVnMlFVWmxSbTFSUzFSdllrZE9ZelYwV1ZwNFZIWk1jVE5U
      TkhSNk9VNVNjR2xNZG5aQ1NtNEtSMFZtUkhOTGNHVnFibEV5U2s4cmJYWjVkMU5NV1RKeE1tSkhW
      WHA1WTFGMmQyVkpWemxzVWpCSWVqQTFVamRoVms1RVlpdEZabTB2VnpBeWRHNDJNUXAzTlVWaWQy
      TkZhREpMTkVKRFUzVktlR3gyZGdvOVpqTXpkUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.all.send_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.all.send_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.all.send_redirects
        replace: '#net.ipv4.conf.all.send_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.all.send_redirects is set to 0
      sysctl:
        name: net.ipv4.conf.all.send_redirects
        value: '0'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'


# Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_accept_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_default_accept_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHFRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      aGtZMUF2YWpCUWFXNVpabGxFYzBvNGMyWnNZVE15VEdvd2FsVUtRemROVUdwV1ZtUXhOakptZEZO
      bGNXTlBLMjlKY0RFMmEyaFViRmxCUXpWcGFGSlBSbXRSWldScVdWbE9lWGt3UzNSaVprUk9iVWxu
      TlZaUU5ERlRiQXBpVTBWdE5HNURjMWRtY0N0RUwwZG9NelJtZDFkM2F6RTBaVEpNYlZCWU9XTlZj
      RU12Y2pOQ1lteHBSR2w2TUhnNFpIZzRWakUwWjBGb1RYUmFkREpvQ21KbFdtMUpLMDA1ZG1kU1J6
      RlhaRmhsUW01SVJsVXhURGhsT1Vwd2MzTTBiWGtyVURKTVRsRjNUREExVkd3M1puSmxiR1l2Y25S
      NE0wRmhTRXRoVkdrS1EwaFNRbkF2ZFc5UVdUbE9LM3BoUTNkbGJXYzVXa3gxWkdkRE1raFZURUZ0
      VURBME5YYzBVVEZ0WlZoelpqWnNjR2xuVVRKclZFTldaa0UwY0RkTlRRcHRjRk5FVUhOeGQzcDBV
      RkpSZERJNVEyeHZiRmx5TW13MGFXbHNlakphZVhGM2JrSm1SakI1UldKeVJsUk9UV2RNZWxaWGRU
      QTVkR1JYYzJwcWIycDVDbXN2VmtRemFXdHZTWEJxVTNkbU1ua3hiRkpFTkM5WlpVMXRTbmQwTnpo
      MVVtbHRlRmxGZWtkT1dWcHFTUzlxWlhWV05WZDBlbTFrUkZGd2JFSkRZMklLUlZOWVEzTTRZa2cx
      V2pNdmVsRnVhM2RRUlZKUGVEaFlaVEF5YjB3eU5ERjNTM0JJVDNKM1N6bDVOVVZXV1hWMVFtRlVl
      RGxhZDNGbVMwNVNVVlZCY1FwWlVEVnpiUzlLWTA5VVZuRm5OV0ZJTjJrNFVuVnphbmxXVkVoeGRE
      aHJOR0kzV25ORE9XSXpjVXBPZHpaQ1NpOUhUa29yVVVnMk0zQnRSVzl4Y2s5ckNrWjJUbEZsTjI4
      d1owTXdlVGRGTVZwRFYyRk5ORFZ1TlZOMlVWcDJNVFJXZHpSNEswUTBkV05zTVhwTmFFOWhielpP
      VUhoQlJsWjBhamd4TTBWamJEQUtUMk5pYjFSclpTOVhUa1J1WkdwMWVqTkdUWFYzVEVGSFVFUTBa
      a00yWTFONFpHaFJhMFJUTVZWbk5FNDVOMmRHZGk5TFpuVTVTamRXVkZWaU9EWnlMd3BEYjJZM2RX
      TldkbGgzVDNGTk1rSnlhVk5TUWdvOU1VSk9hUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84003-3
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253040
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-7(a)
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.3
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_default_accept_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.default.accept_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.default.accept_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.default.accept_redirects
        replace: '#net.ipv4.conf.default.accept_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.default.accept_redirects is set
      sysctl:
        name: net.ipv4.conf.default.accept_redirects
        value: '{{ sysctl_net_ipv4_conf_default_accept_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enable Kernel Paremeter to Log Martian Packets on all IPv4 Interfaces by Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_log_martians,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Paremeter to Log Martian Packets on all IPv4 Interfaces by Default
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_default_log_martians_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      SXJTVkZCU2pKemExUmxSMWxzWlUweWFWbFVTRzVHY0RWb1lWTUtjM2R3WXpoUGQxUkhlVEpOUzNW
      aWFFVldaWGR6ZWtveVNYbHRWQ3RpVWtWMVprOXpLek5wTm5ZdldqUndZM0l4THpkUWRXbGhlRVYy
      YVdaTldGQjBUd3BuVFdVMWFXUXhORFVyYldzckswWkxkV0Z1V1hGUk1uVkJSMlpPZW5sR2FWaEph
      VmRFTDJGV1RFUlJhbkYwTlhoaU5uWnVaMGRJYTNWR1YyeHhSblp3Q2xaS04yZFpRM2RYZWk5SVdY
      Rk9PWEpwWVVGUWQxTnVSbFIxVVU1TVIybGpaMDVMYkVoMk4zTnRlbk5xUkZCaGJFRm5lRzFRV0Ra
      a01rSm5lbUZXY3k4S1dIb3hkVk4xYzJsa1FUbDFXRGRuTkdJclJuaENSSE5OUzFkV2QyRmtWMVJN
      TmpsUlJtRjZLM1JtVEVoWFMzbzFRekJFUmtvMlZXVnBlSE0yVERWQ2F3cEVkMDUwUkRKRlRGWm5X
      REZxVUZSTlJVSmlWa1p4WVdndlVFRTBVMGQ1Y21oUVNteHBZalZPYTBSTGJHRlhNM3BuYlZaWlpV
      UXJTMnhsVEZCSU1tUk9DbkprYWpSUk1VcFBZelUxUlZnMGRXZzBOelpvYldWa1VYSnpaM0JRUlU1
      VmR6Tk1NblIwVHpSV1JqSnZRMjVETDFCS2JYWm1lSFY1Y3pGcmQxa3JkbllLZGxGWE9GSlVRVk50
      T0doemNYUllhMHhYU1VGQmFUZE1RVWhoWnpSeE5ISm5ZMmwxVVcxbVdrdzVhMFJoUjNkTVRuaGlX
      VGMzT0hoYWEzazVSV3hUWndwMmN6SmxlamxEWVZBMFZ6SkVaRWRGYWpKSFFVNXNkSGxpZGpObmNu
      cFJPVk5WS3pkbk5WVmpZamN2TldoSU5UVkpUbFJTTmxOT2MzcHJVR0UxT0U5UENuRTRVWGRVVG1k
      UFZqRjNjVUp0UjI5T2VscDBOVUo0T1daaFNVUktkREpQUm1ad1NGY3dhVUpOVFVNNGRHNUNaM0Z3
      VFRSWFZqRjNaMUV4TUN0YVF6a0tZak5zVWxwbFFqWXdZVGhwVERGRGIxVXdObGswZDNRelkyWlJl
      VVpHT1V4eFZsQkhjVE13UVROMlVrMUxkbFpUTnpjdk16ZDVNM2MyVlcxQ0szVTNNZ3BxTjFOVFMw
      ZGxXRXR5TjFWQmRUaG9NVXMxVFFvOWRITmpjQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84014-0
    - DISA-STIG-RHEL-09-253030
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5(3)(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - reboot_required
    - sysctl_net_ipv4_conf_default_log_martians
    - unknown_severity
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.default.log_martians.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.default.log_martians from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.default.log_martians
        replace: '#net.ipv4.conf.default.log_martians'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.default.log_martians is set
      sysctl:
        name: net.ipv4.conf.default.log_martians
        value: '{{ sysctl_net_ipv4_conf_default_log_martians_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces by Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_rp_filter,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces by Default
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_default_rp_filter_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      YzNiMUF2UVRKc1ZWSXpOVmRCYlRSUVJGYzFSbVl5WWxsdlJFd0tWVUZ3V2pFNVRFWXJMMDVYUmpF
      emJ5dFlZelpCTm5SWVZEY3ZiRTVrVVZocGVHSnBVVFZNTms5T1lVZG9PVkJaYTIxaGFtcHZXR3hX
      UWpGUU9VUkNNQXBUTHk5Qk5XeFVVMWR1TmtKTE5EUk1TM1JVZW5ZM2FHNXJTR1o2YkVObFozbEdR
      a3N3TVc1RFlXNURXbGxLV21vNGNqUk1ObUlyUjFkdlJFSlZaVXBPQ2xkcmQyZE1SR0ZOVG1oWU16
      SmxUVlJFVVdOVWNGUm9VMUYyTnl0TmFWTnVUbWhzT1hoWVdUTnlNRGRaUmtreFNXUTVjRkY2SzFs
      blpTOW1lVWhzYW5FS1JUaEZiRzFEVTNSWVVuQkpkMWNyUTAxdWRVNXZUbTlJVVdkdlEzWkJkM1pH
      UVZnMlltbHFUMGQxY3lzMWQzWnRjalZsY1VKM2VGVnVOV3RCWW1KRVRncG9RakJOTlVGTWQxbGxZ
      VGx3UjBzclRITm9ZMk41YVhNdmFqVjJZMFZRUWtSWlVFVXZUVUp0WnpSRVowa3ZXV2hwY1ZabWRt
      SnFOMk5LVEN0M1VEaHFDbEJUWVRkblUzTnpUVTlSVHpGT2RHNTZVV0phVW1zMWQzbDBaMGhDWjI1
      dE9USlpUemhrYm5KbVkydDBVa1pNSzA5aUszZG5TMlpTVVNzNE9GRkxaVVVLYXpFck9Ha3dXSHBs
      YjJGd1VtdFFlbUpFUjJKYWFuWldOa2xyUW1WNFEwUkxTMmx1VW1WVk4ydGpaWE16TUZwR2JHZHhS
      MUJQVlZFd01tSm5NM2hUZWdwNk4yOXVia3hwTUdodVFuTTFjVXRhYTFORlQweEVkRlpTTkhFNU5F
      VlljRnBtYlV0ME4zSnJaVkF4Y0haTFVHVldhREJDUTNSdVltUm5MMUZZVUZaTENtbFhaMlV4WnpO
      S05taDRZamsyZUU5bFNscDZXRFJRTURsNlEyeE5SbnBIZW5WdlJYUTVla1I2TDAxVFFpdHpUVGMy
      VjJObU1EUktSRzUyYUd0NWNsRUtaV0V4Ukd4ellWTkJlRWxIZFdSalVEbFJXVTl0Y1VKemRqWk9N
      VmxIVlZjME1HSk9OVWh0VG5keU1sWk5NemxIU2k5UmJHVlNZMFZ6ZWswMlZteFNSZ3BLY21OQlZT
      c3ZXbXROVG1SUlFXRmtaVGx0THdvOU9UQnpUUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84009-0
    - DISA-STIG-RHEL-09-253050
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-7(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_default_rp_filter
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.default.rp_filter.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.default.rp_filter from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.default.rp_filter
        replace: '#net.ipv4.conf.default.rp_filter'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.default.rp_filter is set
      sysctl:
        name: net.ipv4.conf.default.rp_filter
        value: '{{ sysctl_net_ipv4_conf_default_rp_filter_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Configure Kernel Parameter for Accepting Secure Redirects By Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_secure_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Configure Kernel Parameter for Accepting Secure Redirects By Default
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_conf_default_secure_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHJRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rp
      dFZaMUZCU2sxc2FVNVpVREZxWjI4eVdrRmhMemhaVmpGelZVNEtWVE12U0hjNU4yZFVSbGt6ZG5a
      bGJWZ3pSbTVFVDJ0SlltNTJZazUzYm1rdlpuaFRaM0JUTUROeE1raFlUMlUwUlhZdloxWnFkVWhJ
      Vms0MVYzaGhiZ3A0VlhFM2FYZFRRV0ZqWlROUGRtUXhTRVZDYTJaTmEyRkRSM2x3TWtaQ09EZEVT
      Q3MwTVhRMk1WbHZXVXBUYzBKUVdqa3hjRzFMY2twR1NXRXhVR1J0Q25GSVpsZGlOVFl6UXpWMkt6
      YzVkR0ZqWm1wM2RGZDBaa2haVDBrdmFESnZja0pEWVdKeFZYTTVXamxSZVVWcVdYaElialZXZUVk
      VlNtWjRNMWhRTm1RS05sUnpWemxDWkZwNGRESmpaaXN6UkVaRU4xSlJNVVpoYTNwNU9XdFBTRkJ2
      UkZscWVYVXZhM2xNVEROaVIwUkdhRU5pWXpWWGF5OXNNV29yYW1vNU9BcFpVVmM0U1VGYWJtdHVU
      MVUzT1RkS05XSlJjMGt2U25wU0wycE5hVXhFVlc0eU9UbFVRMmRhSzBoR2QzSk5jRFZhYURFd01I
      ZG9NRXB6T1c5ek1YQTNDazlFV0dWYWFsaHhiazFTVG1WdFVGVmtWRmh5UVZabE0wNVFWMUpuT1Vs
      V1VFSXdZV3BsZEhWUWVHc3JiM2R3T0haT1J6WjFhelZLVHk5SGExQXZhMDhLTVZNMWFEbFBPWFJT
      ZUVVelJtSm9iVFZKWjA4NU5sSnZkMVZTUVRWME15dDJOWGxwYlhGeWNqSlZNelJYSzBrcmRISkVi
      SHBYUjFKU1VFUmlWbEJ6Y1FwU09XTmFWR3hoVTFOU1ZsbFhTRlI2YWpKSlVFMUNUbkJrTjNONlNE
      ZG5lazlxUVVaaFZrTmtaRVZxUWtkYVJUTnJWSHBIUmxGcVdHdDVTbHB4UkRaV0NuZHVVRzlaYTNG
      aWNHVTBORGR2YTJseEx6VnhhbFZNUW0wd05rdFZNbnBrTm0xVlVTOHJZWHBaVGpocVYxcExVRkkw
      TUVkWVpHWXdUV0p4VURKa01WRUtWM0poVERoRWNqWnFObWx3VEdKNkwwMVVZalYwU0dKbU9VZHNl
      bUU0VFc5MVdsWTVXVVZKUkdsa01qbExTbW94Y2xSSmFsZDBkamhOYkhNd1JXOW1UUXBJY21sS1Ux
      bDRkblpKYjFOc1VIVXhUa2w2VkFvOWRtMVJkd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84019-9
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - NIST-800-53-SC-7(a)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_default_secure_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.default.secure_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.default.secure_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.default.secure_redirects
        replace: '#net.ipv4.conf.default.secure_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.default.secure_redirects is set
      sysctl:
        name: net.ipv4.conf.default.secure_redirects
        value: '{{ sysctl_net_ipv4_conf_default_secure_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces by Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_send_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces by Default
  hosts: all
  become: true
  tags:
    - CCE-83999-3
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253070
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - NIST-800-53-SC-7(a)
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.5
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_conf_default_send_redirects
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      ZFdORkF2TTBsd09EZ3hRMU4yTlUwcmNFTkZTeXQ0VW05M1owd0tkU3RrVXpGTk1YZGhUbGgzUTFk
      UU1sZElRek00Ym5Sa2MwNTJaM0kwUm1wdlJFcHdNRUphUld4NGMyWldRazQ0YW1KamJuZEpVbko1
      T1N0d1NVbHRRZ3BKTTJ4bk1VMVFZbk5RYkU1bGFWUnpOMHBDWjJKTUwyNHpWMnByVWtSSVlVVlBU
      VU01TmtaSWJERnVSVEJwU3pKT1pVdDVWRWxUVWsxc1NHZENaRzVOQ25KblYybFVka0pFYjJORE4y
      eHlOM2RWUjJ3eFFVdENjV2RrT0VGMk9XcDBTRnA2ZWpobVVVVnVTR1ZPVGtWemJFWTJTSG9yUWpO
      eGVuQjFUbGwzZDFrS2NUaFVkakUxU2tZelN6VXhZWGwwYTI4ellWSmlORWxNVWtrMmRGRkVRVXRU
      VlhORWFuUlRibU52U1RsM2FXeG1ObVoxVW5Cb1ZsVm9kVFZRUldvM2JBcGxVbGhoTWpad2Rrc3hh
      VU5pV0VGbWQwaE5VVlpDUmpSVlpqUlpVM0k0VEhGVmNqTXJVV2RrYjJaSWJHcHpXbnB6UzNaRGJW
      RmxTell4U2pRMGN6WTFDbE5JU1hKd01FaHlWazV3ZGxnMmMwaDJjblJMWTNKQ2FrRmlMM2hsVVRo
      bVVHNHJkR293YkdKSU0wcFpXbTlFUkZNM1FYTjNkR001U1RGV1RuRnNVbFVLY0UxMUsza3JUbkZZ
      VEU5Qk5HWkpNRFJVTlRWQ2NsaDNVbWgzTXpScFZYQXZiak5hVm14TldVZHFPRkpJTkVKTGIxQnhX
      R3BxVXk4eVZ6Vk1SVVJNZWdwbGMyVmxXVXBKWWpaTWNVNW1OblZVTDBWaFJYVldOelYwZWt0bGNG
      ZFdRbVJZUjBZNEwweDNWMHhXZEVad1NIQjFkVnBvVlRCVWVreG1TSHBoTkhkRkNrWjJWamN5WVRo
      QlNVZFpRMGQzYTJOdk1rMXRkMlpHWWsxalUxQmplR3QxTXpGa0wxVk5WbmxvUVRScmNXVlViWGxU
      VFhsSlpYQXlkbXBtTmxKUWN6TUtWR3R2VVZWbk5pODBXVmhuV1hwMGNWTm9WMVJKZEc1TWFrRlpV
      M0ZFYUhKNWFURklZazVIYW5NeFkzVklVRzFtZFVob05VMUliMGh1TXpOcFRFdEJXZ3B0ZWxGUWFr
      WnRZVEYyTlUxc2NXcEJOR3hvZFFvOUwxQnlUQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.conf.default.send_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.conf.default.send_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.conf.default.send_redirects
        replace: '#net.ipv4.conf.default.send_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.conf.default.send_redirects is set to 0
      sysctl:
        name: net.ipv4.conf.default.send_redirects
        value: '0'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'


# Enable Kernel Parameter to Ignore ICMP Broadcast Echo Requests on IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_echo_ignore_broadcasts,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Ignore ICMP Broadcast Echo Requests on IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      Z3dhMUF2YWpZeVdWWjZiR0pyVFdwSmFVMHZOVlZxYTAxSGRYb0tiM0ZYZDFKaWJXVjZlR2x4YW01
      SE1FNWxTWGN3SzNsVWNsRXZhRlZ5ZFZKcVlrSndiQzhyV2toUVVsZHlZV2d2TlhvemNtVmlhV3hH
      WmxORk0yOTNOUXB4ZEVGa2VFMXlUazFwV25SMGFrVmpPVVpDWlc1SWRXMTJTRnBLVmpGT1RrNXVW
      RUpZUVRCMlpEQlBlbFpZT0VGQmRIWjRhMHBMUVc1UVdEWkxOV2xhQ2tvNVlWbGlaMHRwT0VKc2VG
      QlNaMGRsVW5Sb1NITnlhalF2VGxKR2VVSnZLMGx6YWxWMFMybGtSRlpqWm5GTk9VUjZlaXRSYTFs
      dVNqQkZhVnBsUm1NS1MxWnNjbkJ2WkN0UFNuWjBXa1V3WXpGWVpYRlNVSFZFVTBnMVdDdGxaR2x3
      VUVKTFdXdE1NMXAxUWtKdll6aFpjV1poV0U4ekwwVk9iR3AzWVUxd1JBcHpOazlJY201Sk1UUm9l
      R1FyZWpWQ2MzSXlUa1pWTWpCU09GRnVVbXhsTDBSWVNFcGtSek5vVW14TlUxSjZabnA0ZUdScVJV
      RjVhazlyUWxaVE4ycDVDa1pyVURKT2VuY3JkR0pLV0hSaVpXNU1ha0ZZVFhaaVIxSkVOMkp3S3pN
      eFRrRTFaM2R0Wm5oRVp6Z3dSREF6UWtGalptRk1LM1Z4TldweFRHaFRPREFLWms0clUxVldNM0J0
      TWxCNFpGTkJTMlpCVm05cVJ6WktRa1V6Y1hsV1QxaDFiVm81UkRCck9VOXZhMWx4T1ZKSlMwSkVi
      a0ZXUm5OUWNHdHZRbWt4WlFwVlZFdG9hMjFXTUhONFRGVXlUVmRqYWtwaGVXNDBXRVJrT0hOV05H
      SldMMWhaZVhKb1VVZFdaamxUVEhSR1prcEpjMGhYYm1veGNFZzRVblJPU1V4VUNuVXdRbFkxYjIx
      UVkyVjRUMjkwU25FNFpXVTVUbFF3ZURGM1pGVXlObnBqVUdGUlEwd3pRVVo2WkRCTFdWaEJTRkpq
      U0hOTGNua3ZXbkZ3TTNkd1VVSUtOMDQzV0dORWIxVlpjbXRXU21WR2NVSXJkQzhyTDA1YWMwOXpj
      bEIzVkVaS2RtTktVMHQzV2s1NlZXcGxOMFpHYUZncmRTOXlZVFF4VGxSV2RIaHJWZ28wUmxNcksy
      ZERXR1JNUm5Ga1VtdEdlbTVITmdvOWNDOHhkZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84004-1
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253055
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.2
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_icmp_echo_ignore_broadcasts
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.icmp_echo_ignore_broadcasts.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.icmp_echo_ignore_broadcasts from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.icmp_echo_ignore_broadcasts
        replace: '#net.ipv4.icmp_echo_ignore_broadcasts'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.icmp_echo_ignore_broadcasts is set
      sysctl:
        name: net.ipv4.icmp_echo_ignore_broadcasts
        value: '{{ sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enable Kernel Parameter to Ignore Bogus ICMP Error Responses on IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_ignore_bogus_error_responses,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Ignore Bogus ICMP Error Responses on IPv4 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      QldhMUZCU1daaFowaEtUR2MyV25SS2MwRjRNVFZrUVVwUFptOEtaMmRST0ZwNWNERkxUbkZSVldj
      MVZXeHpVRlpxTnpsa2NrSm1LemRyVmxwU05HVTBObG93UlVkU01rTTBhR2RJYVU1eFVtaDRlSEF6
      VVRGMlpGRTNTUXB2TWpCS05VcG9RbXhvZEZBcmNFMXhiVVo2YUdobldVeE9WekpuTkdOUFlUQmtj
      blpvYkRoWGVtMVVkVXBDV0U1VVptbzFSRFZKUXpaTlpUWnBNRGxzQ21jcmRqUXpVRmd5T1dkRVVF
      MVFZVXd3ZUhkRFNuSmtVbTR6TWk5blpsSmlSREFyUTJFckwydE1SMkZETDBsb1JYbENTbFJVTXpC
      VmRXTmxiRVo0T0RrS2RrNDVlVWMxWkcxR05uRk9VVmxoYVdKNmIxUjNibmQ1U213eE5Xc3JRazFK
      TURrMFQyaElNRkF3U0RKR2VVUnNUSGN2YWpsVVV6SkNOVlJEV21WMGJncFNjRFI2WkhGTlJuaFZT
      WFUyWjJkRVFtUlpSM1ZtTlhCWWNrcFZPRlV4U210dFdVeFJhR2xLT0d4d00yNVpiVFp3VEZoU0x6
      ZEJWa0ZyWmxsblVYaHZDblJ2UTFKclNuZFpjU3QyTkRsQ05VczNPWGhxZGs5WE0wWktUWEkzVjNa
      SVFVcHpSMGxRUjJwRk9GaG9iRmRxUm1JMmExSlVSeXRzWTFJM01uZDVaRThLUTAxVGNUaHdlWFpQ
      UW5CTGQybGtjVnBQT0dkbldGSTRXa3BqZFZSSmRtWlhaVTgzU0V4SE5tWjRZbFpQVjJwMVlVaEJX
      SGRVUldwc2RXVjJXR05rVFFveFRFaE1kRUpJUmpZdlMwbGxlbXBPWjNGalNVUnljMDVSY21jdk5G
      VjFVRzlCTkRZMlZtdG5hbkZEYUhJeGFHeEVNVVZQYVRKMFJVMVhaRTh2ZDJsa0NreHlLMGx5VnpJ
      MWMxSXJjWEpMS3l0dFptSXdUSEJCWjBWUGMyNDFiVXBsTmxSWVVrNVlWbkJDVGxsUGIza3ZSMVpq
      TldsSGRWbFJZblY0ZDFsUlNFUUtabkJJVm5OWVpFdzRka2h4WmtsNlJuSXZjMHBITUVobU9XMTFR
      elV5TUV0MlMyeDZSVlpYZVc4emMzZDBRVGhhTXpFdlJ6QTBRbFZ5ZDJkTU5qTjBSd3BzTVZsNlR5
      dEVNRTg1YURGRU1saExSRXg1Y2dvOU1tOW1id290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84015-7
    - DISA-STIG-RHEL-09-253060
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.2
    - disable_strategy
    - low_complexity
    - medium_disruption
    - reboot_required
    - sysctl_net_ipv4_icmp_ignore_bogus_error_responses
    - unknown_severity
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.icmp_ignore_bogus_error_responses.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.icmp_ignore_bogus_error_responses from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.icmp_ignore_bogus_error_responses
        replace: '#net.ipv4.icmp_ignore_bogus_error_responses'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.icmp_ignore_bogus_error_responses is set
      sysctl:
        name: net.ipv4.icmp_ignore_bogus_error_responses
        value: '{{ sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for IP Forwarding on IPv4 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_ip_forward,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for IP Forwarding on IPv4 Interfaces
  hosts: all
  become: true
  tags:
    - CCE-83998-5
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5
    - NIST-800-53-SC-7(a)
    - PCI-DSS-Req-1.3.1
    - PCI-DSS-Req-1.3.2
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.3
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_ip_forward
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHNRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      aFZSVkZCU20xTFdXRnNOelIxWWpFeFlqUmlkamxYWTIxNWNYb0tZelJrY1RsMWVDdFJXV2s1U1ha
      RmNFbE9SRVpaY0RkRmVYUjVhVXRPTlVaaVJsVnVhemxwYWpSQ2JFUnZVbTF5SzJwblFXSlVVRzlG
      Ym1NNGNYUnJVQXBuTVhwT1FXWXJVbGhqVDNkQmNWUkVhWE5YUlM5eWIzSnRNRGxQTUhoSlVEZExT
      Mmw0T0dwa2FHWTBhRXN2YWtsMWFEQXZabkJ5ZWs5RmFFcFFSMFk0Q2xsMlJqWXZWWFV6VTBKUGRI
      RnRSbUkxU3pobVFtUlpZMWN4T0hvek4weFFPR1Y0TUUxRldYcFNNekZTYURST1RYa3hXa3gzUTBZ
      M1dsQnZVbWxpZGpZS1ZIZEVkblJPZVVkMlR6TnpMMWw2YmtWV00zSlRPWFo2V2pkTFJpdFpaSEF5
      U0hCUE9ITjJUbmt3YUd0VGRFbE9WVXR1ZDBSYU1tY3lhQzk1VkVNMVF3cDNRbGhPV0dSVk9WTnpO
      MkpLTUU5elkzWTVSVFJHYVdSUmF5OHpTWGhWY2k5YWFYWmxVWGRITkRJM1lVTkpTREJTZW01WlZX
      bE9aM2d5TjBNNVJtdzVDbmRpYm5Kb1FtOUlWMHBYTVVGUlpETlhWbFZQUWxwWkwwNDVjemN6VGtG
      dUwyNUVkSGRtZWpKSWQzWjBabE5zY0V3d1RFVTJTbkl6ZURSbWRtSlNURXdLYTNwS2REaHRkMU1y
      TkdOTmJHVmhMM0ZZYmtWQllqUlFMMWR0UkhSemRYUnRUa05NVURoWWNWSjVRM1kxYmtGNE0zZzBS
      bG92WjBOaUt6aHZZV0ZOVVFwTE1sRm9NbTlZWjNoUVMxWkZXbEp2Um5CTWVHVm5URmhIU0dobmFE
      SkVkRUpoT0dSclFraENSMkp2VG1nNU5rSjFUVkYwVEhoT1VIcElUMHhYTkc5MUNuSjNSWFE0T0RK
      R1FtcExVMmh3UVRkemMxTk9OV1kzYWxveU9WVkxUazFrY0M5S05IRXplaTlWVjFoWlNGSTFaa3cx
      YlhSeWVGZEdiR3RSWVZOclFsVUtXSGRoUTFkV2RrODViRGRrYWtwVFRrOVBWRlIyZFdaS2VGcGxV
      bEJ6V1daVldYZEpka0kxTlN0eVZYZENTRFpLVUZOSWVIZDNiVmxHWTFaSEwwMTZOd3BzUzFoMGVr
      azJjRFJYVkRCeVdXRjVZbU5qYUFvOVJFUmhWd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.ip_forward.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.ip_forward from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.ip_forward
        replace: '#net.ipv4.ip_forward'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.ip_forward is set to 0
      sysctl:
        name: net.ipv4.ip_forward
        value: '0'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'


# Enable Kernel Parameter to Use TCP Syncookies on Network Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Enable Kernel Parameter to Use TCP Syncookies on Network Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv4_tcp_syncookies_value: '1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Ru
      RnVUVkF2TXpkbmQyTnJhelpsZUdSWFZGTllXa3RzVmtKWFl6WUtiM2h3ZUV0elpFWXpjekpCU0Zs
      ak5FWnNXVTlWUlZwSWEyZGhOWGhHWmxWSlUyRmlRelJUWlhKVVRUWlFVMkZPVG1nM1lsbFJlVmxO
      TlU1S1RuQkRkZ3B1YW0xdFRUUjNaa05FTjI1T01qbFlRMHN3TjBkYWIwOUpPVkoyY0dkTU5EQkVX
      bmQ0VUcxd1lVRkZkVTlaZFdGM1NtRndibUZESzNwNWFHcFVZVzlJQ2pWQ01tZHJhRk5XT1RaNk1X
      UmFVM051V0VaRGVreFpZM28zV2tFMlJVeEJkbkp2WVZkdVEyWmhXWGhEVDNGWFluSjBhVmcxTVZB
      dlpIcDFTV1pzZUhNS2RVdHZUVU5xZUhWYWJFNU9RVmd4TjJKWk4yOVdTVmxSY0haaldYSnhVbk5C
      TW10NU4yWnJSMmhzVlhVeVpsQkNTR2RRT0RkRVJXcFlVMlp6TlhSUmJBcGpWbnBOT0dSYVlVTnhP
      RTlNWlZwVlVqaEROakZqZUZBNWJVdFJkVEJVVkhOSWJrSnNiM1k1TldZclUwaDRaVTF5U0hWamFt
      MUxZMnQ2VjJOck0wbzRDbFpwYUhKUFFrcGhZMlZWYTBaeGFIaDJLM2g1VGpsS2NFeHdVa1JTUm1W
      cFpHOWlXRkkyYmtOSU16ZHZSMDVUZFdKamNVWklVbkZqYmxCSGREUlNZemNLTDJSQlZHMUljMjFR
      Y1ZGMGVFeEdTbXhEYVZoc2N6ZGpaR3B0TDNaWFZEWlNaa2N6WkZKelRXeGxlVGxGZVhKV2NYRjBO
      VkI2TVhNNVUybG1WM2R0UndwSmJYRkZkVVUwUlVWSVNsVkdZazlRTmxSMmFHTlBabVV2V0ZOUE1U
      Z3JWMnd5VldSdWMyOHdWbkZHWlZjclFVSlZUR1k0ZFU4MlExUmlVWFJwVW1RNENqTjRkV05IVVZO
      WmNFdFhWMWRNVm5wMmVrSlNPVVl5YzBsRU5qQkRUbnBpTVcxUE5XeDFjbEZJWWxKTFYyZ3djMmhQ
      VjIxU2NYazNWbVZ6UzFVNFVVNEtTMmxYVWtwVU5WbFpPVVp4TVN0SWRtaGhhUzl6UlROQk5rOW9a
      bU5GYVZORmEyOVRPVlV6WVU5blRVdHVTRmxOZFdsYVVFcGlPWG80UkRkaVNsQXhWZ3BTU2tKbFJG
      SjJNVlV5ZWtJemJ6ZHNURGhwY1FvOVpsTjJUZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84006-6
    - CJIS-5.10.1.1
    - DISA-STIG-RHEL-09-253010
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - NIST-800-53-SC-5(1)
    - NIST-800-53-SC-5(2)
    - NIST-800-53-SC-5(3)(a)
    - PCI-DSS-Req-1.4.1
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.3
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv4_tcp_syncookies
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv4.tcp_syncookies.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv4.tcp_syncookies from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv4.tcp_syncookies
        replace: '#net.ipv4.tcp_syncookies'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv4.tcp_syncookies is set
      sysctl:
        name: net.ipv4.tcp_syncookies
        value: '{{ sysctl_net_ipv4_tcp_syncookies_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Configure Accepting Router Advertisements on All IPv6 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_ra,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Configure Accepting Router Advertisements on All IPv6 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_all_accept_ra_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      NHlaMUZCU1hRM1RUQnhPVTlOZEZOWlFVaGpPVGR3Y2tveFIyVUtkekozWVVaSldGaG1hRlJNVjJ4
      WU56ZzJkamt5T0dFd05URmtSM3BzVUhOa2JYQnVZM0JsVlhKbVFsRjJjWFZIVkRKNEwyTlNkRXRU
      VUM5MFVpOXdWZ3A2ZDFCcEx6ZHZWVlYxVUhvek9XSk5MME5CUm01cFkxZFVkMUJEYUhSVmIxaFVO
      bXN3Y25NdlowOVRNVXhHUzFvMlpUSXdkV3RoUlZodVRVOVFaWGxGQ2tNcmRuQk1lazFFVUd0cGJ6
      WjFTeTlyY1RsVGMxbFhRMjVIY2xZMmIxVjNlRlpXSzAxYVdsRnpUMG96VkROUFEzbFRjSFJFUzFk
      eUx6bENXVzV6Vnk4S0szaEpWelkwUVVrNGNuUmhjVUV3UWxSNVRXZEZhalJGVFV4blFqVkJUVU5Z
      YWxOelJqTm1Sbk5WZHpGS1FsWkpWVlZyTjJVeWFVZHhOelFyV1VKdkx3bzRRMWxtVFZKWlpFTXdT
      MVpNV0hGeVJGWkNTelZRYzIxUlptNVZiVmt3WkVGNWFtZzRTRVo0UzA0d2J6ZHNTVWhJZURsc1FX
      WTVlblZ5TkRKeEwzZG9DbFZ1T1d0Tk9WUk1hVTF1VTA1Mk1sQm1TbXhMUjNFdlV6VlJabXBrVkdw
      eFVFRnpNV3A0VVVwaFV5OWthalpOVkZSR1FtUnRVMDlyU2xVM2IxQk9ObmtLZFZsRFZFazRhbWs1
      V1VabWVFVlFTbGRaTDJoWlVWQTBURWc0Y0VodWJFOU5aRGRtYTBneFkyUlJiV2g1VlhwTE1GUTBk
      M2R2U3premEwUk1MMmhDYUFwa2FFNXRSWGRGVDFobWJTdDFkVTVVTVM5cmN5dHBXRnBPT1Roc2VV
      ZzBZbTl5U1dwUFJtTkpPWGR3YkZSU1JrczBhSFp2ZVRCbE1GUklabk50VEc5bkNsSlZjVWQ1TTBs
      Uk1qSnZUbEV6ZHpsUlZtbENlV1J1VDIxa2NEYzRWVXh3VjFsUE5sYzRabEIyVkZSbFJYRm9XVXBQ
      V1ZCV1kyYzVNR3hWZHpaWVNYa0tSVWhLV1hNNU0wVlNWMDFsWjJrelVraDROVlZGTWxoeUwwZGFh
      RFpRVUZOT2VtazJhMUV2Unk4dloyNVBVbXBxYzB4bVVTOUxaSFJPZVRsWFFqUXJXZ3A2ZEcxU2VU
      SkJkRTVKU0VGQ0swNWpTRWwwS3dvOWFVOW1TUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84120-5
    - DISA-STIG-RHEL-09-254010
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_all_accept_ra
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.all.accept_ra.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.all.accept_ra from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.all.accept_ra
        replace: '#net.ipv6.conf.all.accept_ra'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.all.accept_ra is set
      sysctl:
        name: net.ipv6.conf.all.accept_ra
        value: '{{ sysctl_net_ipv6_conf_all_accept_ra_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Accepting ICMP Redirects for All IPv6 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Accepting ICMP Redirects for All IPv6 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_all_accept_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHRRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      WnFZMUF2TUZVM2RXNW5ZVUV5WVc1bFZESlRTbU5EVG5SVlowWUtOVk5oWldOSmRVcHJWMjluYUV4
      QlVFa3ljbXAzVDFSWFUya3ZjMWQwTVROWmJtdENSMnh3Y1ZRNFNXMUlWSEZtV0dNdmREUTNOWGRp
      UzB0NGN6RnFWUXBNUmk5V1VtdENlVUpTVUZwYVJrUXZWakJ5ZW5rMFptUTFjbFl3Y0hFNGFqZzFi
      Q3RDUW1oQlQwbGhiRFV6VkV0dE0waEhOMXBSYm05elNXNWFUMUJzQ2pGbFdqRnhNMmROU0RGRU1V
      TTJUazEwTlVoaU9DdHhSalF5YkM5RGJXdHZiMDR2VTBGd2VGSjRVemR0VUM4NU1IVmtVVEI2Wkhv
      d2RHcGlXRFZSV1hFS1dTOUZXalYyVjB0VlpVVjZlamROY3pWNFJVeEZlRlpOUm5wdFlscFZlVzEw
      YTJSSmJtaDZMMDByZDFaRWFrbEVha3RQTmxsdmJtWk5Na2h1Y2pKRGRnb3pVR3BPVUVGaU9WTlVZ
      eXRvZUhseWJHZDJaVzAzZDFsd01rZDVSVGxxUnpSQ05GQlpVVVJ5ZVZWWGQyUjNhVmRPV0hCdlVr
      bzFNUzg1WVdwNVZERnBDblZ1TW0wMmJFZzFSSGRvVUZRdkswTjNRM0Z2UkRoa1praDNWbXRzVlVS
      d1RXSkJia05GUVdaaWVrdDFVVE5HU1hSclNHWlllbE5pTjI1U1VGUnJOWE1LTTI1MFlXd3JTMUJK
      TVd4RGNWRk5VRWxsYjNrck1EVnpjMnN4UzJGQ1ZrbElUMFJWV1ZJMk4wZENaMUl6WXpKdFJrNWhl
      ak0wVURBelJ6QnNjR2RNYlFwalIwMVVSWFZ3VW1oQ2NucHVhbkV5ZWk4M0syWk9ObkpDZVZCcVNY
      Tk1ZV1JOYW1KTFNqZFhSalp4VGpWSmNTOW9aekZtUkVsQ2JqZEJja1JJZFRCaENsaFdia3RtVjFZ
      dlNVMXRRMU5zT0ZaV2F5dE1UM04yVTB0Rk1EWnNlRXBxTDB0UE9VbzBkMmxpVVd0SVFYZERWa3Rq
      SzFaRU9HeEZOalJXVUZKbVJGa0tSVlpwWVZJMWRrVkVNbGhCTHpkU2VrdzJSRUpTVDFnNFdHWXZj
      VUZQUmpaUlJWbG1iVGswVFRWSlZqbDVlVVo2TDB0aGNHcE1ja05MYm5oVlRIWmlSZ3BoTWpsUUsz
      Wm1NRkJsVTI5VGREVjVSMUptYUFvOVlXUlRlQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84125-4
    - DISA-STIG-RHEL-09-254015
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-6(b)
    - NIST-800-53-CM-6.1(iv)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_all_accept_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.all.accept_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.all.accept_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.all.accept_redirects
        replace: '#net.ipv6.conf.all.accept_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.all.accept_redirects is set
      sysctl:
        name: net.ipv6.conf.all.accept_redirects
        value: '{{ sysctl_net_ipv6_conf_all_accept_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv6 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_source_route,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv6 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_all_accept_source_route_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rt
      ZEVkMUZCU1dwcFZsSlpXRXBCV0ZCd2IyRlpVRVpDUlZoUmJub0tSRmxYYkV0blZtc3laWEF6SzNS
      d2VGVkRVV2hSVDJWemEzVlVibk4wYUhaSFlUWXZSRk5EUVRSclNHeEplREYzWkhWalJreHFlR1Uz
      YzA1cU1FdHZOQXAxVURKVkwxQnROSEpqS3psdFdrcHhLMmxwYVdvM1YxWTBaR0p0TXpKelRHbHBS
      elZHZFRCS1JtaHBNMlpJU1RrNVFXNHhWa3hFVnpCVVYxbDRUREIyQ21NNVUzZDVTMkptUWsxdWNT
      c3pjazV0WjJsRVNHZERkM0ZhVlVsUGVqRnNlRXhqZWxCTlF6SkNOWEl5V25GQ05saFRZV3haU2pW
      bWNXZFRLM2hsWW5rS2EycEZVMWRyTUc5SGRFSXJaeTlLYkROVlowTTVTR3h3TDFCWFUybHhSbFpu
      VWtaRVVFOXFORzQ0UmtwWWFYaFNaRGhLYVhCa2IzTlViemxqY25WeU53cDFkbWxTZFdobWNubDFZ
      Mk5GY0Rka1VXMXVVbGhzU1hVMFltczNObU5NTkdNMlRrVlplVnB1U2xKTlNua3pTa2c1TTFCNWJW
      TlROV2wxTVhGclEwazBDbXhEVFZRM01tMWtObm8xV1Zvdk1YazFlVmg2Y2pGNVJtVkNXR2h5YjAw
      ck5qVk1ieXRCTVZaamNrSjFWSFkwWW1abmVXOXJkMjFyVW5rek1IZ3JiWGtLVWsxWlJFeFRjVTl5
      U1VGVlpFRnllR05vZUZOcVJqVnJTR2hvYVVreVVqUjBhV0ZoV1RSa1IwZElWV2RJUTB3NFJUQmFj
      RE55WldGaFQwNXZWbmRIVmdwRU1HeEVlams0Y1RCb2MzVTBZMVY2TW1KNk1XVlRPRTFuY2s1S2VY
      b3pSSHBMWWlzd01FbDNkblpJYlcxUE1EQllTRmhWYnpCS1JVVk5Tak5tVFVSTUNrUmxPV2N4WTNa
      eU1tbDNkM2RHY1RoMlptOU9kRk5JUzFaYUwyeDBlbkpwZG10VVRVWjBOelptZFUxSGFrdEVabTV6
      T0dOdWNEY3ZTalpaY0VOVGIyTUtRazluYldocVlXeDRRbFJzU1d0bGVrWkhRazVYT0VRMGNWcDBa
      V1kyY2xsWVdUZ3ZWbGt2ZFdKYVRFTkVRU3M1ZDNaR2RVOURlR3BKUm1KTWVVUktSd3BoYTB0TGJU
      RlJXbGxVTTNkNFZtVmhMekZZVkFvOVpVNTZkQW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84131-2
    - DISA-STIG-RHEL-09-254020
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_all_accept_source_route
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.all.accept_source_route.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.all.accept_source_route from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.all.accept_source_route
        replace: '#net.ipv6.conf.all.accept_source_route'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.all.accept_source_route is set
      sysctl:
        name: net.ipv6.conf.all.accept_source_route
        value: '{{ sysctl_net_ipv6_conf_all_accept_source_route_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for IPv6 Forwarding
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_forwarding,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for IPv6 Forwarding
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_all_forwarding_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rs
      ZFJUVkZCU2t4aFlXRjRhRVYzVDNGTFpIbDVkbGszYkRCTk1rTUtlV0ZDZEhaaGNHNTNORkY0YzBo
      VWF6VnZibUYzVm5SVFEySTJWRmxFU0hObFNtSllXbGs1VTI5MlVTOVBjMmhMUlN0eFNrRnlUVWhF
      VmxwblFUUjVZUXBSVEdGeWJVTXhOazUwYVVaTmVVWlRVVk5PWkhSS01DOTViRTB4Vld4UU1XUm5X
      WHBWY0c5cGRFdEdPRXhhZDFSWGVWYzNMMnRwWTBSU1dWbG1iMWc0Q21Fd1NXSkVZakU0WTJoUU1E
      RlFjMVl3ZUhKQmJXWjJNa1ZHVXpsVGNrdGxNa0ZEV0ROVlRrZG1SR1JpV1hncmNHWTNWbVpFT0ha
      R2EzUjJNMWxtYVdJS1FrMW9NazU0ZDJocFVWSmFRVFpOYm1GcU5GUkZaMFowU0VWblpuQnVWMnR6
      Y0ZVM05scE5UeTg1VDNKemFWVmxUVmxzY1dWdlNGTkpaRGQ1TWpOVVdBcHZRV2RwYlVaVmNtVnZU
      MkpEUjFCTFYzQTRTbEpSUTBObE5VUk5Talo1ZFVvMlJGcDNaM1JuVmxOQk5XcGFLMk5rZVVOVFQy
      cHdSSE52VjFjMlJFY3JDbk5CZERaNGVYVTRjamx4TmxSWVJsWklVME00VG04NE5WQmpSVkJTVFho
      Nk1YUTJLMWt5UWpjMGVsTXZaVFpTY3psMVVERlpabWxaVEU4clVsWlhiMVVLWlU1WFFVcDRVelZW
      WWtwa1prOUNXRkUyTVdkb1V6VldlRkJ0YkhoWmRtUTVZMnhPTURoaGFHaFZNRlJ2WkN0Nk1rUXhU
      VkJQVVVSRFpYbE1SV2N4VEFwaFlsbEdjR2RrTmtkVVRsVldOR2x5TnpJdk1FMVdXRFZxWmk5dFZV
      cG1WMU5wVkVSRlprUTFkRFl5VFVVeFlrZHZPWGw2T0M5eWNsRktWbEZFYm1sYUNteExWWFJUVmpF
      MVJYWmlaM1V4TUM4MlRuVk1USGh3T1VoU1VHdHlZazFITm1kdloyWkRMM05oV25GdUwzUTNaRWxJ
      TUVsNFptbEhibmx6ZEdOd1dURUtjekIyU2xSSFVTOU5Xa1JsZFVKTkszaHRhV05EZFM5TWFGcERU
      bFZ1TkdKSWJtbHpiMDlpYjJWamJ6WnlOa0VyTkRCdFZDOVVOSG8yT1hnNUwxbGtWQXBoWTBZM1Vt
      czVjbGhqWlZsek4yRmFWMWczZWdvOWVHbEpOd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84114-8
    - DISA-STIG-RHEL-09-254025
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-6(b)
    - NIST-800-53-CM-6.1(iv)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_all_forwarding
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.all.forwarding.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.all.forwarding from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.all.forwarding
        replace: '#net.ipv6.conf.all.forwarding'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.all.forwarding is set
      sysctl:
        name: net.ipv6.conf.all.forwarding
        value: '{{ sysctl_net_ipv6_conf_all_forwarding_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Accepting Router Advertisements on all IPv6 Interfaces by Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_ra,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Accepting Router Advertisements on all IPv6 Interfaces by Default
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_default_accept_ra_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      MUpWVkF2YWxSQmMxTkhZbE5DTjBwc1oyOVVaemRLWkhaUGRqVUtORzQ0YWxOaGJGRXhkWFY1SzFo
      emRuUlRNMFo1TkZWakwxZGtLeTk2UlZOT2QxSk5NbmMyYnpCbGNIUkhhSEZoU0VKTE9YaEZkREZo
      UzB4TWIyUnJTQXB2VmtwcWNGaHlUVWhzV0U5d1ZYWmpPRVZxTTFaUmVqYzBiMGxXUW1kNFkyMU9T
      Vk5aV1dSYUwzRnFOR1ZhSzJWdmFWZEhLMjVPYzNvellrTjZReXRrQ2s5U2NsaFZaamx1UkZscFJV
      MVhiWHBMTUdwaE1sQnpTRmhEVEVSeVpFdGlUbTB6UjBwbGEwUkxVVTVLZWtNMU1VazJhVWRzUWxC
      TGEwTjROekpwZFdZS1NIWTRObFp1U1VwTlluWlVTSEZuVWpRcmNUaEdhbXd2WmpKSGEyRlZZM3Bq
      VVhKaGQweDBZM0V2T1ZWbk1EZHBRa1ZNVW5CcmFXOW9UelkyUzBVeVdBcGlObWRFTldKWkswMXVP
      RTVPV0dkb2J6RmhNRk5UY0dGa1RXaHBSRE41VlVSeWVtZzNVM1F6TlhGUWJVZzRXRVJUVTBKQ0t6
      RXpOemx5YTFWNlowMVhDa3cwY1hCWVNrbzVaR2RoVmxGRk1rWkpjMjVIUWpkQ1drczNZVnA1WkZB
      MFZ6QkNRelJRWVd3MldXMVdWbVpGTW10dldUWlpWRlJUUjFwcWVGY3liMk1LTW10RFRGRndkMWRU
      VVdscFMwTlhWbmhPTWl0RlYyZG5kSGhQVVV0aVZVRnBORWhyTDNoTlNGaHJjSFJTZVhWT1J5OXJT
      R04wTUc5TVVVMHhWM0o2UWdwclptbDVWMDk0TWpKWllYZ3lVbEo0Y1VrclpXOUlOMmhvTWpoVVNu
      aE1TVmRrTjFKNFVuTlhkMWRGWkRoTFpsRkRjV3hRYjFoM1RteEhkRk1yTWpRckNqbFphV2hpUW5B
      eGFIRk1PRzlFY2tnMlJWVTBaV0p1UkRKd1FtMHlNelJHVkdWc2JEVk5RV1ozU2tSUVlWWTBVR29y
      Y3pZd1pIVlVNMmRuTmpOSk9HMEtVMUY2VGxsTE1HNVpjMWRWUVZvM09UUlJMMDVWWlhsVFRrRmlR
      VUV4Tkc0NFEyZGpkRkJQTUZKQ1EzazBLMnR2VWtOaGExZFNaM2RGTVVjNFV6ZE1aQW8yWlhGRlJI
      UlhZMkZhWWtGQ1NWZFBlV0prTWdvOVlVSXpWd290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84124-7
    - DISA-STIG-RHEL-09-254030
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_default_accept_ra
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.default.accept_ra.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.default.accept_ra from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.default.accept_ra
        replace: '#net.ipv6.conf.default.accept_ra'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.default.accept_ra is set
      sysctl:
        name: net.ipv6.conf.default.accept_ra
        value: '{{ sysctl_net_ipv6_conf_default_accept_ra_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_redirects,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_default_accept_redirects_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHVRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      WTNaMUF2TVdGWk4xazNNM05aYUdRemFuZzJaRWQwWVhZek1Ha0tTeklyUm1oMFdVUjBWVWxTT1dS
      alQzVnNXbUZVWnpRNWJ5dDFkQzh6Y2xwM1IzQnlSelY0YWpWR1pYUmpabFV3UzJ4TFNFTm5XVlIx
      Y0dnek9YcEZRZ3A1UlZORldTdERTMHRKUTBsVmNtTXpVR3hJZGxSbFlVODJLekZPYWxwVU1rWmxS
      RXQxYVdwdlVUWnNka2xMVGtJcmFHVXdVMkpUYjFoTFEwVmxMemx2Q25WeFMyRnNjakptYUNzelR6
      UnBUalFyVjBGUWFGZEpVelJRWjNORVNEYzJkM0pzUm1ZeFFuWktOREJVZUdkdU1YWk5aMmRZTkNz
      dlVEQTJWSEpHTW1ZS1VIQlZUa0pKV2tkc01rcERUVFZCVXpkVlpqUnVjaThyV0RCSk0yWkJMMFIx
      ZUZVd01GVk1SSElyZG1SRU5YaFdaRmNyUkUweGJ6WkRTWGQyWjNJMFNRcG9URFpIUVVrMVZsQkli
      bFZKYkd4Rk1uRkJhR2RLYlZaTFFVVk1hMlpyUVRGVWMwOUpPVVJ4YURaQ1VuRmFPVE5sZWxwVUsy
      WmllWHBKTjFsTWJGbGtDbHA0YWtWME1sUm5VVGxSWVVOdlkwWjZZMGcwWm5kbEwxcDFSaXRWY1dW
      WFRrczFaRVJSVjFKbFMwWXZWaTl2U2pnMVZGTjBTakF2T1M5cVQyWkxhVmdLU2xGcFJFUm1TVTBy
      U2xkbmMzUm5Za3RRYkU5bE1FVk5lR2RpZHpoblZHOXlhR0ZwZWtRMU5WRnpSbU5EVlhNd1RWRjNR
      WGRtVTJKdFVFZFJVRWhzZVFwclJFTjVSbTVWTWs1SGVFVlRhaXRqZURoNlVscGxOSEpuVm0xalRW
      cEVMMnM1T0U1aGNrWk1TRGhhU1RRdk9IUmxiVk5rTDNsNWF6RXpVVzV0UzJOTENuSjNWbkp5ZURC
      cFRWWXJibnBNVVVsdVREQlFVMWhWYVZodk0wdzNOakF2VVhOVVQwMXJWUzlGU0VkSmQwdEVTa2Rx
      Y0c5WVQxcFBWVXh0YlZKbFVWVUtjakpDVjFOUGIzQlVXblZ1TlZseWRERlNZVzVoY21sT1IwNW9Z
      amRrVmxOQ1QxQjNWV1ZCUzFwSVdqSTRaRFZJVDNKRmJYY3pSRkpKUkdoWFIwbzJTZ3BHZFZrNFRt
      VldhR2MyVEVVdlZsbGxhMlZTVFFvOU1uRjRUZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84113-0
    - DISA-STIG-RHEL-09-254035
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_default_accept_redirects
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.default.accept_redirects.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.default.accept_redirects from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.default.accept_redirects
        replace: '#net.ipv6.conf.default.accept_redirects'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.default.accept_redirects is set
      sysctl:
        name: net.ipv6.conf.default.accept_redirects
        value: '{{ sysctl_net_ipv6_conf_default_accept_redirects_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Disable Kernel Parameter for Accepting Source-Routed Packets on IPv6 Interfaces by Default
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_source_route,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = disable
# complexity = low
# disruption = medium
- name: Disable Kernel Parameter for Accepting Source-Routed Packets on IPv6 Interfaces by Default
  hosts: all
  become: true
  vars:
    sysctl_net_ipv6_conf_default_accept_source_route_value: '0'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rr
      Sm1ORkF2TW1SSWIzQndTMFZ1SzBobGRtbFZaV0pSUm1wck9Vd0tNMjgyVW5VeU5TczRiWFE0ZVRZ
      dlJVZFZiVlZ6WW5wVFlXMTVTekpHUzNFMFRVZGhWakpDVERScVZrVktRakV2YXpZd05IQmlNRmh3
      Y1hWcGNteEhUUXB6ZFRscGVtdFZaVGNyTmtOYVYwZHhVbFZuTkdWV1VYVklRV3h3Y25kTWVGTlZX
      SGh6UkVkRVZuWTVPV1Z6Y2t4NU5scHlVRzlZWmtSWWQwTktXVEJYQ21OWVNFZGFOeXR4U0RkRE9X
      VkVjRE16VlZrd2FtUlRURFZXU0RVemVHUkdjeTltWTBsSlYweFlXRXhzVEZCeFdIaFBWRXAxYkVa
      WWNIVnlTVWhrTTNBS2VrNU5UbWhoU3paTmVHMVlOa3d6U0d3M2JISjRPVTR4ZVhoRWJVZEpPRlJr
      TW04MVdqWmtUVE5oYldwR00ydEZhWGR4U2xWU2RHaDJlRlp6WkUxRllRcGhiQzlHY1hKQk9ITkxh
      RkY1UzNSUlZIRk1iMjluTjFkVEx6QlJWMjR5TVRsNWJFZDZObkJ0ZDA0M1RuTnFWVVZEWVRBd1RE
      UjFZbWxRTnpVM1VsVnpDa1ZXWVRSek5YSk5UVlF2VkVkTVVrTmtPR0p4UmxsSk9HVkROVzR5Ulc5
      SE9USlNhMXBLTWs5VVJsRlZWMGczTmtsNWVtdFpUVlIyTkhCd09XTXlTV0VLWVhSaGN6WjNhakZ6
      WjA1UFEzSlZhV2hFWW5kVGFuQk5VbVkyZHpNNFpIRjZhVGhDYjJkeGF6SXdhRlF2VTB0MlpETnJL
      emhYVUdaT1VYRkpPVGRKVFFwSU1qUkpXVWxLYVZoNVNDdGphVWxMZEVoTVpEWklhMkpaTmxWTlUy
      NVdaMFJ5YVhSRFJITm1jMmxpUlhJNFlscHNiVEZFYVdoQmIwSkZWRXBYUkV4SkNsRlZVMHRPUzFs
      VmJ6Qk9TM1ZzY1ZOSWFEbEplWFJVYlV0MFJFTmFTVkUwVUVaNFRFSlZTbnB6V1d0eWNUaE9jV2xE
      Wmpac2NXUm5UWFJwTkdkVU1ub0tUMXBaWVdkMVZrNXNlVk5VYUdWNWFsTmhWbmhLVmtnNWQyTjJh
      MGxRVTAwM01EQldTMFp4Vm1SS2VESTJZVXREVVN0R01uUmxUMUZPVDBwSlMyNWFLd3A2UVdJMVlq
      aFlPV3RIUkVvd1lXVmlSVVZQS3dvOWFYVjBWUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-84130-4
    - DISA-STIG-RHEL-09-254040
    - NIST-800-171-3.1.20
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-6(b)
    - NIST-800-53-CM-6.1(iv)
    - NIST-800-53-CM-7(a)
    - NIST-800-53-CM-7(b)
    - PCI-DSS-Req-1.4.3
    - PCI-DSSv4-1.4
    - PCI-DSSv4-1.4.2
    - disable_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - reboot_required
    - sysctl_net_ipv6_conf_default_accept_source_route
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: List /etc/sysctl.d/*.conf files
      find:
        paths:
          - /etc/sysctl.d/
          - /run/sysctl.d/
          - /usr/local/lib/sysctl.d/
        contains: ^[\s]*net.ipv6.conf.default.accept_source_route.*$
        patterns: '*.conf'
        file_type: any
      register: find_sysctl_d
      when: '"kernel" in ansible_facts.packages'

    - name: Comment out any occurrences of net.ipv6.conf.default.accept_source_route from config files
      replace:
        path: '{{ item.path }}'
        regexp: ^[\s]*net.ipv6.conf.default.accept_source_route
        replace: '#net.ipv6.conf.default.accept_source_route'
      loop: '{{ find_sysctl_d.files }}'
      when: '"kernel" in ansible_facts.packages'

    - name: Ensure sysctl net.ipv6.conf.default.accept_source_route is set
      sysctl:
        name: net.ipv6.conf.default.accept_source_route
        value: '{{ sysctl_net_ipv6_conf_default_accept_source_route_value }}'
        sysctl_file: /etc/sysctl.conf
        state: present
        reload: true
      when: '"kernel" in ansible_facts.packages'
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true


# Enforce Usage of pam_wheel with Group Parameter for su Authentication
# Identifier: (ssg:xccdf_org.ssgproject.content_benchmark_RHEL-9|0.1.77|cis|xccdf_org.ssgproject.content_rule_use_pam_wheel_group_for_su,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_sle,multi_platform_slmicro,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Enforce Usage of pam_wheel with Group Parameter for su Authentication
  hosts: all
  become: true
  vars:
    var_pam_wheel_group_for_su: sugroup
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU205aVNEZHZRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      QmhTVkF2TUUxeFl6Uk9UbmRGWTBsMVFqTjJLMmxMU2pGV1FVd0tXakV6VWxabVQyWXhWek5ZVkd0
      Q2QxRklWRlY1Ylhwb1RrdFBORlV5TUVGc1VIazNZeTlNWlVGSWNHUkdPRWgzVUhscFNGbFpZVnAy
      VUZkRFpqUTNlQW95Y1U1d2JDODBaMGRzVm5GTldUSXlSalZ0ZG5SaFF6TnJPVmRwVTNwcmNHc3lT
      VUZEUkRaRlRrMDBkamRxT1ZGdlV6TmpUbFZETjFOQk9XNVRiV2sxQ25WclRFOXViVzlNVmt0dFVW
      TXJURGc1U1U1UFQyVjNMM2x6ZVZSVlJVTm9aV05GVVVScE0wRXZRV3RUVVUxRk0zRnRUV0ppVTJ4
      b1RURTNWMjVGTm00S1ZVcFJNa1UxVTJaUVdEbGpWVlpJY2xwcE9XTXdUM1ZOZWtZemFWWXZlVUZq
      VGtFMU5GZzJUR1pHYWtvdmRHd3hlall4TlZob2VFRndlVTF3U0ZOSGJRcEplREZNYlc1c2NHOVRW
      RVl5UW1kSE15dGplbFZFZDJ0d1NYbFhUR3BJT1hkc1ZrRktUMDlPUVRNeVRUQmFUSFpSVmpKdFpG
      RmFUMkp6TXpCaVpESTNDa1kxUmxWcVdFTnBZbkpLYWpWaWNVOVZSa05pVWtoRWVUSlJhVEZHWVZW
      cmJHaDBOa1paU0ZRMVRuUmFjSFZrYXk5NlFuWlBiRmh4V1dOMUx6QllUVklLVDFsckt6ZHpZMHBz
      ZG5oWVNWQkNkbWRyT1RkUWVsVnZiak5tVUhsR1kxTk9XbUk1V0VsbWVtRktUblZIY2xORGJFVXpW
      bGhYV0U1RE5HVTBPREl5TndwU1ZUbEVWbk13VkM5UGVGRnNiM3B1YTNsWmJHOVlZVWhhTDAxNGNF
      MVhXSE0yTUVoaFFsaFFZMDkxTUdOTGVVTjBiWFJSVUV4M2JuSjNiR3BqWkRaaUNsSXpZa0ZxUVV0
      U2FFaEdSbmxLYzIxYU9HSkZOMWwzV1ZrekwzcERTV2x1YVhCVFRVeEtaVXRHTTJONmNYSTJkbk5x
      ZDJkTFZteFBOV3BNVUZJMFZWVUtSM1JIT0doUlNGVTRNMlZ5U3pWM1VEbGliREY2VTBOS1UwcDFL
      M1ZqWWt4UmFETXdNbUZLWlROTmMyMVhSSGx0Tm5WRE1uRlhlVWhQY0ZSTlR6SlVXZ292VG1ZNVlU
      TmliMFFyWXpRNGMySnlRemh4YWdvOWJrVlFWUW90TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tags:
    - CCE-86065-0
    - PCI-DSSv4-2.2
    - PCI-DSSv4-2.2.6
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - use_pam_wheel_group_for_su
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Enforce Usage of pam_wheel with Group Parameter for su Authentication - Add the group to the /etc/pam.d/su file
      ansible.builtin.lineinfile:
        path: /etc/pam.d/su
        state: present
        regexp: ^[\s]*#[\s]*auth[\s]+required[\s]+pam_wheel\.so[\s]+use_uid group=$
        line: auth             required        pam_wheel.so use_uid group={{ var_pam_wheel_group_for_su }}
      when: '"pam" in ansible_facts.packages'


- name: generate Compliance report
  hosts: "scapdemo1.sambox.aws"
  become: true
  gather_facts: false
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTV05DUVVGQ1EwRkJSMEpSU213elMyZFlRVUZ2U2tWTmRuYzFPRVFyYWpWd1Rq
      a3djMUZCU1dwWVVsWklhUzh5WkdRclFrdzRhRnBCVXlzNGJrd0tjbUp5WkhobWRra3ZhM1p3TWxj
      eGNrMWtNbkJ0YmpsV1owOURXVll6YzI5Nk1FNURjRTVKZUhsUFFuZFpXVmhOYkdwYU5XcGhOSE5F
      TkZVME5HbzFRUXBQUmxWTE1IQmxaR3QwVTJseVVsbDJhbTFsVm1oU1YyRnhURzE0VnpJeFFVdDNN
      bmR5YTBRM1EwNVRjM1JtYmxWMlRtUkJabU5LYjFGV2NHODJOM2RyQ2sxUFNUaFJZMlo2ZFdJMWNu
      aHlTSFV3ZUM5eFZqVnROa3RPZVZORFptaFlLelo0SzFkMWFqQk1ibEZqYTJ4WVYyVkZVM2hQV1N0
      blRrMUJNMFkxYkU4S1dXcHdSMmhVU25oeFkzSXpTRWh0TURsV1RWTk1aeTkwTjNFNGRqaERWMlp1
      Wms1M2VVcDBOazVsYVV0MGFVYzVUa2hKV1d0M1NFZ3lOMFZZTlhORk9Rb3pSakEyWWs5NlpsQkdT
      RWRaUzBzeFlYTmplamhvTDNOMVRtMDRiWFJ4Ym5CQmIycHNkM1JZVDNKWmFVaG1hV1JsTWtSaWEz
      VjNOUzl0ZDBGSFFXZFVDbGhtTWtJMGMybFBVSHBpWWxvMVUzUjJSbFk0YzBaMVVrMTFjWEpHVTJj
      M2FsSkpkbkpQT1ZjeE5YQTBiV04xUnpkSWVDOVJRMVpvUmpkb1FuUkZUMG9LVFhCdmFYVjBOVlpx
      ZGxsVFkwcEJUM05tTUdsYU5FaFlRWEZtVEVWWWVtdzFja1ZzUmtoek1GSnlWRkJsWVZoSmRqTmti
      bkpUV0dkNFNUZFVTVUpUYVFwYWJtTkNZalpMVUdkNWFVSXJibWRQV0ZCbFEyMUhNbmRMVm5CSGVI
      ZDFkV0pXTWtScE5FdGxhWHB0V25KcWNtMVFPRlJLWjJWb2QyRktSMmt5TlZwakNrcFpVMlpGTVU5
      T1pucDVaR2gxVmxscVltSnhabkppZGxKWU4zaExlV1JNTVhWQlRucG9Ua05wY2pSRk0xcHRaRloy
      UlVSd04wNVNhalIwTmpReldrY0tTVGxSYnpGRldEazNlR001YmtwYU0wMDVWME5zYVhSa2MwUTJh
      V1JQWlhCU1FuRlBhSFJIU0hoRlkxVkJUMHgxWkUwelNVNDNNM1pDVlRCa1dsbFVXQXByYVhwNVRV
      VXJibGxEUmxKSk9XWjFaemx2ZGdvOVVtcGxWZ290TFMwdExVVk9SQ0JRUjFBZ1UwbEhUa0ZVVlZK
      RkxTMHRMUzBL
  tasks:
    - name: generate Compliance report
      command: insights-client --compliance
      changed_when: false

# Reboots a system if any of the preceeding plays sets the 'insights_needs_reboot' variable to true.
# The variable can be overridden to suppress this behavior.
- name: Reboot system (if applicable)
  hosts: "scapdemo1.sambox.aws"
  become: true
  gather_facts: false
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldVaHBRMVk0ZG5jMU9FUXJhalZ3VGtGUmFrMUVRa0ZCYTJOeE1W
      WlhVbEF3VUVoMGRIRjBWMGt4UkZSdU4zcE1kbFUyU0hKd2QxSUtUbkJ3Um5SWGJWRktiM2xxYm1w
      bE5XUmFSemMxUTNCU1kzZGFPRU5XVW5sRlRVRXpVREExZW1Kc1UzSnFWbTUxVW5oNlpVeG1SbTFy
      YW1SRVJWcHdjZ3ByWTJ0d2FFazJSVUpIYWtJemEyaGFUalJ5YTNwUWRWQm1PR1pMUVdsSE1ESmxk
      SGhXVFZWV01tZHRkV3c0UjBJMmRIcEpkRk5uVFRGQlFYQkdORTFRQ2s1NFRDOUpUMlY2ZFdRMGFt
      VlFaV05KZWpGS1dtMTVkVGgzWTNoVFZqWkpTbTVPU1VGSGVHYzVWRUpVYzNNMFEwbHVaVlZXY0RG
      VWRrUlFPUzlHVXk4S2VGaFlaMFphWlM5VlZuQjBaRzA1ZDJkbmRVOXRiR2hvWVZCTVZHNU5Tbkoy
      UVRsV2FVUnZRVzV2WWt0b1VIbEtZMHBSYjJOTFdrRlRjVTF6ZWs1VWNncHVNek5JYlRoUk9IQnRW
      VTFLYldobU9VRnZkM2x4VW5GWVVHeHpXVGwzT0UxRU1WQkZjR3htY2pJeVlYTjFMMHhvYjNGNlIz
      TmtOMUUxTTJwdFMyNXBDaXM1Y0VjeWEzVkNSVXhpVVhoblRHcERiVlZsUzFCdmJuaFhjM0JuVFZs
      M2VYQjFaVFJvYnl0dmFsZG5WRGR2ZG1GbFRFNVRTMkV2UkZOS2JEWldRaThLZEd4YUwxUXJPRFZr
      Ym5ZclNWb3phbEJTZFM5bVpuZFBkVVpVV2xoNmVGTkJUalZSV1M5ak15c3hhbUZSTDBKeFdYTmhi
      M2RpUkZreGRXUXZVeXRsYVFwa2FEa3JWRkV5TlVKa1NYa3hibGh3ZWpoV1JHbHpjbEp3Y0VrNWFs
      SldWakkwTVVVelRVWkhka1ZaTm1aVFYzSlZWMWMzY0RKbFpUbGphelpOVlUweUNrNUZjRXBLWm5G
      UFNFdHBjRXRPZVRKdVFVRTJURmcxTHpNeGFWSk9VSEZZVXpKRVdqSlpkbVZTUTJOMmVDOHZPVTlo
      UzFWd1FsZElZVmxYYW5STU4wWUtSWFJWVEZGeFZESkJPVTF3WjFSU1RtOU5WbEZ4Y1haQ01GUlBP
      WE00TmxoTmRuUkdRa1IzYW5SbWIxSm9NRnBEYlUwME1FRlhRMHBxT0RKNlduTlRZUXBCYXpkUEsy
      UkpkMFl5VVQwS1BWcEtiallLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:
    - when:
        - insights_needs_reboot is defined
        - insights_needs_reboot
      block:
        - name: Reboot system
          shell: sleep 2 && shutdown -r now "Ansible triggered reboot"
          async: 1
          poll: 0
          ignore_errors: true

        - name: Wait for system to boot up
          local_action:
            module: wait_for
            host: "{{ hostvars[inventory_hostname]['ansible_host'] | default(hostvars[inventory_hostname]['ansible_ssh_host'], true) | default(inventory_hostname, true) }}"
            port: "{{ hostvars[inventory_hostname]['ansible_port'] | default(hostvars[inventory_hostname]['ansible_ssh_port'], true) | default('22', true) }}"
            delay: 15
            search_regex: OpenSSH
            timeout: 300
          become: false

- name: run insights
  hosts: "scapdemo1.sambox.aws"
  become: true
  gather_facts: false
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldVaHBRaXR6ZG5jMU9FUXJhalZ3VGtGUmFXdDRaeTh2WmtaRFoz
      QXlTblIxVEd0UU5qQnNTa3BZYm1GU1JGTjVjVVYwU0ZSNlRGY0tOVlZSVlc5MWEyUmpVRFJVUlZn
      d01EaDFhRkJHUzFaSmVrdFVTR2RsYTFOaU1UUXlkMjlQYm5sR2VUUnpRbEJrZEZoaGREVlliWEp0
      VGxsR1EwaEVWZ28xYVhSdlNrcDBPVzg1UWtkQlJVaDVZMFJ3SzBoNVNqWXphM0paZVRGUk1rOXVU
      azF3VjJaSmNtYzJUakJXVTJoa1JtVk1lR0ppTjBaMlpFaEpjbFo2Q2pJNGFrdHhOemx1Tm13eUx6
      aDZZVkJSTDFkWVZIWkNaMDVhUkVWTFJ6TmhSSFl3WVRkbWIyUnlPRWhEZGxseE5tNUhNRkZOY1RO
      U1ZFOXBkbFZtTTFnS1JuQnlhVTh2TDNKSlRDOVlSelE1TTA1NGFWSjBRakVyZEhSUk0wZHNhM1ZE
      ZFVwck1EQkdaREp0ZDNZNFprRnZaR2xUUW5aelQydEpZekZyV25adFN3cEJjR3BEY1ZKMWVHaExU
      MDgzYWxZM1FYSnRTV0p6TkhobVJrUkJVMkZaV2t4R01VMHZhME42ZWs1d1MwTjFhbE5hVUUxRlVt
      WlhhV2RHVGpGMWRqRjNDalpQSzB0b1pTdFJVRU5hUm5CV1kwVndSbTFSTVdwcWFrOVFPV2haSzNW
      alZWSnhSVEkyTlhGTWRuWnFSWE4wUW5WQk4xQkZNRVZ3UkRsaU5VaFZSM1lLTkZKemJXc3pNbFpC
      Vnl0WE5IWk1VRWQwZG1sQ00wSXpUbE0wZUhCdVIzSmlObGs1Y1cwNFZuVTJSRUZIV2xOYWRsbFlk
      bWQwTm1WR2N6RTVTVFZZUWdvMGVtcFVSRUlyTW1sT2NrcE9jM2d5YURoU1VGVnJMMmhZUzFKMGEy
      WnZZMlpKZVRkcGNWY3hiMGRsTlZSMmFqTTFSbXRqUld0YU9VRnpSMjl6WXpWMENuUlZkVlZJWWpS
      ME5EVTFSSE5EWlZWc1ZEZFNOakJDTTB4d1Z6TmlTRTF0YzFCMEx6RktNRFEwYm1KS2RFTkhUM1Jy
      UVVWWVRsVTJlbGxUTDNBMFFqSUtaSFYxY2tZdlNHUnFWWFJNVDNSdlNFTnlZVWd2WkZwaFRVNTZk
      MVZpZUc1VFZXUkdZU3R6TTBaNFJHczFVVkU0VVRaMVVucFpRbWw0WkcxeWREZGpUQXBKYTA1NlEy
      aHBRMDlrY3owS1BVMVZOMk1LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:
    - name: run insights
      command: insights-client
      changed_when: false